<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>Коллекции и свойства элементов</title>
    <link rel="stylesheet" href="../../стили/Полигон.css" />
  </head>
  <body>
    <header>
      <img src="../../avatar/avatar1.jpg" width="90" height="90" alt="Лягушка" />
      <nav>
        <a href="../../Полигон.html">Назад</a>
        <a href="Коллекции и свойства элементов/Новости 2.1.html">Сайт 1</a>
        <a href="Коллекции и свойства элементов/Новости 2.2.html">Сайт 2</a>
      </nav>
    </header>
    <main>
      <h2>Коллекции и свойства элементов</h2>
      <h3>Проверяем всплывающие подсказки</h3>
      <p>
        Новостной сат, над которым мы работали ранее, посвящён событиям в IT, и
        иногда в новостях встречаются малоизвестные названия и сложные понятия.
        Чтобы посетители не отвлекались на поисковые запросы, добавим
        всплывающие подсказки прямо на страницу с новостью.
      </p>
      <p>
        Слова, которые требуют пояснения, свёрстаны как кнопка с классом
        <span>tooltip-button</span>:
      </p>
      <code
        >&lt;button class="tooltip-button"
        type="button"&gt;DogDrones.inc&lt;/button&gt;</code
      >
      <p>
        При клике на слово-кнопку должно появляться небольшое окошко - попап.
        Внутри попапа выводится подсказка (по-английски такую подсказку называют
        tooltip)
      </p>
      <p>
        Используем метод <span>querySelector</span>, чтобы найти нужные
        элементы, и добавим словам-кнопка обработчик событий
        <span>onclick</span>. При клике на кнопку попапу добавляется класс
        <span>opened</span>, и подсказка появляется на странице:
      </p>
      <code>
        let tooltip = document.querySelector('.tooltip'); <br />
        let tooltipButton = document.querySelector('.tooltip-button'); <br />
        <br />
        tooltipButton.onclick = function () { <br />
        tooltip.classList.add('opened'); <br />
        }
      </code>
      <p>
        Если кликнуть по кнопке "Закрыт" внутри попапа, класс
        <span>opened</span> убирается, и подсказка пропадает со страницы:
      </p>
      <code>
        let closeButton = document.querySelector('.close-button'); <br />
        <br />
        closeButton.onclick = function () { <br />
        tooltip.classList.remove('opened'); <br />
        }
      </code>
      <h3>Метод querySelectorAll и коллекция</h3>
      <p>
        Мы выяснили, что попап появляется при клике на первую кнопку, но при
        клике на вторую ничего не происходит. Закрывается попап нормально, но
        вот самой подсказки в нём нет.
      </p>
      <p>
        Почему не работает вторая кнопка? Всё дело в том, что метод
        <span>querySelector</span> возвращает, то есть передаёт информацию,
        только об одном элементе. Если в скобках указан селектор, котрй подходит
        нескольким элементам на странице, то возвращается только первый из них.
        Как быть, еси нужно найти все элементы? Используем метод
        <span>querySelectorAll</span>:
      </p>
      <code>
        // Найдёт все обзацы на странице <br />
        let elements = document.querySelectorAll('p');
      </code>
      <p>
        Метод <span>querySelectorAll</span> находит все элементы на странице,
        которые соответствуют указанному селектору, и возвращает набор этих
        элементов - коллекцию.
      </p>
      <p>
        Коллекцию, как и обычный элемент, можно сохранить в переменной. Самый
        простой способ узнать, какие элементы содержит коллекция, - вывести её в
        консоль:
      </p>
      <code>
        // Выведет коллекцию в консоль <br />
        console.log(elements);
      </code>
      <p>
        В нашей консоли коллекция выглядит как список, в котором элементы
        перечислены через запятю. Весь список обёрнут в квадратные скобки, а у
        элементов указан только их тек и, например, класс.
      </p>
      <p>
        Чтобы элементы отобразились так же, как в разметке, коллекцию нужно
        развернуть, кликнув на стрелку-треугольник слева.
      </p>
      <p>
        Слова-кнопки на нашем сайте - это элементы с классом
        <span>tooltip-button</span>. Скажем JavaScript найти их все и выведем
        полученную коллекцию в консоль.
      </p>
      <h3>Обращаемся к элементам коллекции по индексу</h3>
      <p>
        Мы получили коллекцию из двух элементов и вывели её в консоль. Найденные
        элементы - это кнопки, и по клику на каждую из них должен появляться
        попап с подсказкой. Для этого каждой кнопке в коллекцию нужно добавить
        обработчик событий. Как сказать JavaScript, что мы хотим сделать что-то
        с элементом коллекции? Можно обратиться к этому элементу с помощью
        индекса.
      </p>
      <p>
        Индекс - это порядковый номер элемента в коллекции. Обратите внимание,
        отсчёт начинается с нуля, поэтому у первого элемента индекс 0, а у
        второго - 1. Индексы пишут в квадратных скобках после имени коллекции:
      </p>
      <code> коллекция[индекс] </code>
      <p>
        Обращение к элементам по индексу похоже на обращение к переменным по
        имени:
      </p>
      <code>
        let elements = document.querySelectorAll('p'); <br />
        <br />
        console.log(elements[0]); // Выведет первый элемент коллекции <br />
        console.log(elements[1]); // Выведет второй элемент коллекции
      </code>
      <h3>Добавляем обработчики обеим кнопка</h3>
      <p>
        Мы научились обращаться к элементам коллекции по индексу. Чтобы
        подсказки заработали нужно добавить словам-кнопкам в коллекции
        <span>tooltipButtons</span> обработчики кликов.
      </p>
      <p>Сейчас у нас уже есть обработчик для первой кнопки.</p>
      <code>
        tooltipButton.onclick = function () { <br />
        tooltip.classList.add("opened");<br />
        };
      </code>
      <p>
        Второй кнопке нужно добавить точно такой же обработчик. Скопируем и
        вставим написанный обработчик событий. После этого изменим оба
        обработчика так, чтобы они добавлялись элементам коллекции:
      </p>
      <code>
        tooltipButtons[0].onclick = function () {<br />
        tooltip.classList.add("opened");<br />
        };<br />
        <br />
        tooltipButtons[1].onclick = function () {<br />
        tooltip.classList.add("opened");<br />
        };
      </code>
      <p>
        Так код выглядит понятнее, и, благодаря индексам, мы можем быть уверены,
        что ни одну кнопку не пропустили. После того как мы изменим код,
        отдельная переменная для первой копнки будет уже не нужна.
      </p>
      <h3>Получаем значение data-атрибута</h3>
      <p>
        Мы научились работать с элементами в кллекции сделать так, чтобы попап
        появлялся при клике на любую из кнопок. Внутри попапа должен выводится
        текст, поясняющий слово, на которое нажал пользователь. Текст подсказки
        хранится в разметке, в атрибуте <span>data-tooltip-text</span> самой
        кнопки.
      </p>
      <p>
        Что это за атрибут? HTML - гибкий язык, и в нём можно создавать свои
        собственные атрибуты. Имена таких атрибутов начинаются с префикса
        <span>data-</span>, после которого идёт любое выбранное разработчиком
        слово. Это немного похоже на переменные; вы сами решаете, как назвать
        атрибут и какое он должен иметь значение.
      </p>
      <p>Например:</p>
      <code>&lt;div data-cat-name='Кекс'&gt;</code>
      <p>
        Атрибуты, начинающиеся с <span>data-</span>, обычно исползуют, чтобы
        хранить вспомогательную информацию.
      </p>
      <p>
        Как получить значение такого атрибута в JavaScript? Для этого используют
        свойство <span>dataset</span>, после которого указывают имя атрибута бещ
        префиска <span>data-</span>:
      </p>
      <code>элемент.dataset.имяАтрибутаБезПифекса</code>
      <p>
        Если имя атрибута состояло из нескольких слов и в нём были дефисы, то в
        JavaScript его записывают в "верблюжьем" стиле: дефисы убирают, а каждое
        слово, кроме первого, пишут с большой буквы. Чтобы получить значение
        атрибута из примера выше, нужно использовать такие инструкции:
      </p>
      <code>
        let element = document.querySelector('div'); <br />
        console.log(element.dataset.catName); // Выведет: Кекс
      </code>
      <p>
        На нашем сайте тексты подсказк ханятся в атрибуах
        <span>data-tooltip-text</span>.
      </p>
      <h3>Выводим текст подсказки на страницу</h3>
      <p>
        Мы познакомились с data-атрибутами и вывели в консоль значение атрибута
        <span>data-tooltip-text</span> обеих кнопок. Этот атрибут нам нужен,
        чтобы показать правильную подсказку. Если пользователь нажал на первую
        кнопку, то внутри попапа должен появиться текст из атрибута первой
        кнопки, а если на вторую - то второй.
      </p>
      <p>
        Выводить текст будем в элементе с классом <span>tooltip-text</span>. В
        азметке он находится внутри попапа:
      </p>
      <code>
        &lt;div class="tooltip"&gt; <br />
        &lt;span class="tooltip-text"&gt;&lt;/span&gt; <br />
        &lt;button class="close-button" type="button"&gt;Закрыть&lt;/button&gt;
        <br />
        &lt;/div&gt;
      </code>
      <p>
        Найдём этот элемент, сохраним в переменную и будем изменять его
        текстовое содержимое. Внутри первого обработчика событий используем
        текст из атрибута первой кнопки, а внутри второго - второй. Кликнем на
        обе кнопки и проверим, что в попапе выводится правильный текст
        подсказки.
      </p>
      <h3>Подключаем скрипт к другой странице</h3>
      <p>
        Подсказки готовы! Попап появляется при клике на каждую кнопку, и в нём
        выводится текст, который хранится в атрибуте
        <span>data-tooltip-text</span> нажатой кнопки.
      </p>
      <p>
        Теперь нужно убедиться, что наш скрипт достаточно универсальный и
        подходит для любой новости. Для этого мы подклюич его к страницу с
        другой новостью.
      </p>
      <h3>Цикл for of</h3>
      <p>
        Мы подключили наш скрипт к другой новости, которой оказалось четыре
        кнопки. Мы кликнули на них, но сработали только первые две, вед
        обработчики мы добавили только им. Как быть? Неужели придётся создавать
        отдельный скрипт для каждой новости и копировать обработчики? Конечно,
        нет. Используем <b>цикл</b>.
      </p>
      <p>
        Цикл - это констркуция, которая позволяет выполнить код несколько раз. В
        JavaScript существуют разные циклы, мы познакомимся с ними позже. Для
        нашей задачи используем цикл <span>for of</span>:
      </p>
      <code>
        for (переменная of коллекция) { <br />
        // код, который нужно выполнять несколько раз <br />
        }
      </code>
      <p>
        Цикл <span>for of</span> выполнит код из фигурных скобок столько раз,
        сколько элементов содержится в коллекции, указанной в круглых скобках.
        Каждое такое повторение называется <i>итерацией</i>.
      </p>
      <p>
        При создании цикла в круглых скобках также нужно указать переменную.
        Обычно для этого объявляют новую переменную и используют её только
        внутри цикла. На каждой итерации JavaScript будет автоматически
        записывать в эту переменную очередной элемент коллекции.
      </p>
      <code>
        let elements = document.querySelectorAll('p'); // Находим все абзацы
        <br />
        <br />
        for (let element of elements) { // Создаё цикл и перемменную <br />
        console.log(element); // Выводим элементы в консоль <br />
        }
      </code>
      <p>
        Если в коллекции <span>elements</span> два элемента, то JavaScript
        выполнит следющие инструкции:
      </p>
      <code>
        // Первая итерация: <br />
        //В переменную автоматически записывается перывй элемент коллекции
        <br />
        element = elements[0]; <br />
        // Выполняется код из цикла - первый элемент коллекции выводится в
        консоль <br />
        console.log(element); <br />
        <br />
        // Вторая итерация: <br />
        //В переменную автоматически записывается перывй элемент коллекции
        <br />
        element = elements[1]; <br />
        // Выполняется код из цикла, но теперь в консоль выводится второй
        элемент <br />
        console.log(element);
      </code>
      <p>
        Цикл завершится, когда в коллекции закончатся элементы. После этого
        JavaScript перейдёт к инструкциям, которые идут после цикла.
      </p>
      <p>
        Благодаря циклу нам не нужно заранее знат количество элементов в
        коллекции и копировать обработчики. Это позволяет сделать скипт
        универсальным, а код - короче и понятнее.
      </p>
      <h3>Добавляем обработчик с помощью цикла</h3>
      <p>
        Мы использовали цикл <span>for of</span>, чтобы вывести в консоль все
        элементы коллекции. Таким же образом мы можем добавить обработчик кликов
        все кнопкам в новости. Воспользуемся циклом: на каждой итерации будем
        добавлять обработчик элементу, который сейчас находится в переменной
        цикла. В результате мы получим универсальый скрипт - обработчик добавтся
        каждому элементу в коллекции, сколько бы их не было.
      </p>
      <p>Например:</p>
      <code>
        let elements = document.querySelectorAll('p'); <br />
        <br />
        for (let element of elements) { <br />
        // Добавляем обработчик всем элементам по очереди <br />
        element.onclick = function () {<br />
        console.log('Вы кликнули на абзац'); <br />
        }; <br />
        }
      </code>
      <p>
        Когда цикл из примера выполнится, обработчики добавятся всем абзацам в
        коллекции <span>elements</span>, и при клике на каждый из них будет
        выводтся сообщение в консоль.
      </p>
      <p>
        Обработчик событий, благодаря которому показываются подсказки на
        новостном сайте, уже написан. Перенесём его внутрь цикла и заменим
        обращение по индексы на переменную <span>tooltipButton</span>, которую
        мы используем в цикле.
      </p>
      <code>
        // До: <br />
        tooltipButtons[0].onclick = function () { <br />
        ... <br />
        }; <br />
        <br />
        // После: <br />
        for (let tooltipButton of tooltipButtons) { <br />
        tooltipButton.onclick = function () { <br />
        ... <br />
        }; <br />
        }
      </code>
      <p>
        Обаботчик, который мы добавляли второй кнопке, удалим, он больше не
        нужен. После этого убедимся, что при клике на каждую кнопку появляется
        попап с подсказкой.
      </p>
      <h3>Обработчик событий</h3>
      <p>
        Сейчас сделаем так, чтобы комментарии на сайте были не длинее 142
        символов. В форме коммнентария уже есть счётчик, чтобы пользователь
        видел, сколько символом он уже использовал. Если лимит символов
        превышен, то кнопка отправки комменатрия должна блокироваться, а счётчик
        символов и текста в поле ввода становится красным.
      </p>
      <p>Придётся доаботать наш скрипт с комментариями!</p>
      <p>
        Мы уже умеем получать данные из поля ввода, но только после того, как
        форма была отправлена. сйечас же нам нужно оценить длину комменатрия ещё
        до отправки. Как быть? Воскользуемся обработчиком событий
        <span>oninput</span>. инструкциивнутри обработчика
        <span>oninput</span> выполняются каждый раз, когда значение в поле ввода
        меняется. Например:
      </p>
      <code>
        // Найдём поле ввода <br />
        let textarea = document.querySelector('textarea'); <br />
        <br />
        // Добавим обработчик событий <br />
        textarea.oninput = function () { <br />
        // Выведем данные из поля ввода <br />
        console.log(textarea.value); <br />
        }
      </code>
      <p>
        Наберём слово "Кекс", потом удалим последний символ и заглянем в
        консоль:
      </p>
      <code>
        LOG: К (String) <br />
        LOG: Ке (String) <br />
        LOG: Кек (String) <br />
        LOG: Кекс (String) <br />
        LOG: Кек (String) <br />
      </code>
      <p>
        Обратите внимание, текст из поля ввода выводился в консоль при каждом
        изменении: и когда добавляли новый символ, и когда символ удаляли.
      </p>
      <p>
        Благодаря обработчику событий <span>oninput</span> мы можем получить
        текст комментария ещё до того, как пользователь его отправит.
      </p>
      <h3>Свойство length, вычисляем длину строки</h3>
      <p>
        Мы познакомились с обработчиком событий <span>oninput</span> и получили
        данные из поля вврда без отправки формы. Сделае так, чтобы комментарии
        были не длинее 142 символов и чтобы пользователь видел, сколько символов
        он уже использовал. Для этого нам нужно вычислить длину комменатрия
        вывести её на страницу.
      </p>
      <p>
        Узнать длину комменатрия нам поможет свойство <span>length</span>.
        Значение этого свойтва равно числу символов в строке. Символами
        считаются не только буквы и цифры, но также пробелы и переносы строки.
      </p>
      <code>
        let text = 'Я люблю JavaScript'; <br />
        console.log(text.length); // Выведет: 18 <br />
        <br />
        let textarea = document.querySelector('textarea'); <br />
        console.log(textarea.value); // Выведет: Кекс <br />
        console.log(textarea.value.length); // Выведет: 4 <br />
      </code>
      <p>
        Пользователи новстного сайта должны знать, какой длины набранный ими
        текст. Чтобы вывести длину на страницу, изменим текстовое содержимое
        элемента с классом <span>char-counter.</span>. Этот элемент нахдится
        прямо под полем ввода:
      </p>
      <code>
        &lt;span class="text-counter"&gt; <br />
        Использовано &lt;span class="char-counter"&gt;0&lt;/span&gt;/142
        символов <br />
        &lt;/span&gt;
      </code>
      <p>
        счётчик символов должен реагировать на каждое изменение в поле ввода,
        поэтому менять текстовое содержмое элемента мы будем внутри нашего
        обработчика <span>oninput</span>. Чтобы убедиться, что счётчик символов
        работает, начнём набирать новый комменатрий.
      </p>
      <h3>Сравниваем числа</h3>
      <p>
        Отлично, теперь счётчик символов показывает длину нового комментария!
        Если комментарий длинее 142 символов, должен появитьсясигнал об ошибке:
        счётчик символов и текст в поле ввода должны стать красными. Чтобы
        сигнал появился, форме комментария нужно добавить класс
        <span>warning</span>. С этой формой мы работали в прошлом задании, она
        сохранена в переменной <span>commentForm</span>.
      </p>
      <p>
        Сигнал об ошибке должен появляться, только если новый комментарий
        слишком длинный. Слово "если" в задаче - верный признак того, что
        понадобится условная конструкция <span>if</span>.
      </p>
      <p>
        Чтобы определить, не превышен ли лимит символов, сравним длину
        комментария с числом 142. Для этого используем оператор сравнения
        <span>&gt;</span>. Он сравнивает два числа и возвращает булево значение:
        <span>true</span>, если левое число больше первого, и
        <span>false</span> во всех остальных случаях. Например
      </p>
      <code>
        console.log(3 &gt; 2); // Вернёт: true <br />
        console.log(1 &gt; 2); // Вернёт: false <br />
        console.log(2 &gt; 2); // Вернёт: false <br />
      </code>
      <p>
        Чтобы проверить, подходит ли новый комментарий по длине, добавим в наш
        скрипт условную конструкцию: сравним длину текста из поля ввода с числом
        142 и, если длина больше, добавим класс <span>warning</span>. После
        этого протестируем, как работает проверка, и попробуем отправить слишком
        длинный комментарий.
      </p>
      <h3>Свойство disabled, блокируем кнопку</h3>
      <p>
        Мы добавили уловную конструкциюв наш скрипт, и теперь, если новый
        комментарий длинее 142 символов, появляется сигнал об ошибке. Но это не
        ешает отправить форму и опубликовать слишком длинный комментарий. Чтобы
        это исправить, нужно не только добавлть класс форме, но и блокировать
        кнопку отправки. Если кнопка заблокирована, форму отправить не
        получится.
      </p>
      <p>
        Блокировать и разблокировать кнопку в JavaScript можно, присваивая
        булевы значения свойству <span>disabled</span> этой кнопке. Если
        присвоено значение <span>true</span>, о кнопка заблокирована, а если
        <span>false</span> - разблокирована.
      </p>
      <code>
        let button = document.querySelector('button'); <br />
        <br />
        // Блокирует кнопку <br />
        button.disabled = true; <br />
        <br />
        // Разблокирует кнопку <br />
        button.disabled = false;
      </code>
      <p>
        За отправку нового комментария на нашем сайте отвечает кнопка с классом
        <span>sumbit-button</span>. Найдём её и сохраним в переменную. После
        этого дополним условную конструкцию: если комментарий слишком длинный,
        кнопка отправки должна блокироваться.
      </p>
      <h3>Добавляем ветку else</h3>
      <p>
        Задание почти выполнено: пользователи больше не могут публиковать
        слишком длинные комментарии. Если текст в поле ввода длинее 142
        символов, кнопка отправки блокируется и появляется сигнал об ошибке. В
        этом случае пользователь должен поправить комментарий. Сейчас сигнал об
        ошибке не исчезает, а кнопка отправки не блокируется, даже если
        укоротить текст до нужной длины. Как это исправить?
      </p>
      <p>
        Нам нужна альтернативная ветка <span>else</span>: если условие ложно, то
        есть комменатрий не длиннее 142 символов, то свойство
        <span>disabled</span> кнопки нужно записать <span>false</span>, а класс
        <span>warning</span> у формы убрать.
      </p>
      <p>
        Добавим в наш скрипт вторую ветку и необходимые инструкции и проверим,
        что теперь всё работает как надо: если комментарий слишком длинный,
        кнопка блокируется и появляется сигнал об ошибке, а если лимит символов
        не превышен, то кнопка разблокируется и сигнал об ошибке пропадает.
      </p>
      <h3>Обнуляем счётчик символов</h3>
      <p>
        Проверка нового комментария отлично работает: если текст в поле ввода
        длиннее 142 символов, то появляется сигнал об ошибке и отправка
        комментария блокируется, а если текст сократить, то блокировка снимается
        и сигнал исчезает. Вот только счётчик символов после отправки
        комментария не обнуляется.
      </p>
      <p>
        Это происходит потому, что обработчик <span>oninput</span> не
        срабатывает, когда мы отправляем форму и очищаем поле ввода. Чтобы
        комментарии заработали как надо, присвоим текстовому содержимому
        счётчика значение <span>0</span> внутри другого обработчика событий -
        <span>onsubmit</span>. Он уже есть в нашем скрипте, мы работали с ним
        ранее. Инструкции внутри этого обработчика выполняются в момент отправки
        формы, так что, когда пользователь отправит новый комментарий, счётчик
        обнулится.
      </p>
    </main>
    <footer>
      <h3>Здесь могла быть ваша кувшинка</h3>
    </footer>
  </body>
</html>
