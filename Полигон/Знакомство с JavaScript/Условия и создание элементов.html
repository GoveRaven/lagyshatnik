<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>Условия и создание элементов</title>
    <link rel="stylesheet" href="../../стили/Полигон.css" />
  </head>
  <body>
    <header>
      <img
        src="../../avatar/avatar1.jpg"
        width="90"
        height="90"
        alt="Лягушка"
      />
      <nav>
        <a href="../../Полигон.html">Назад</a>
        <a href="Условия и создание элементов/Новости.html">Сайт</a>
      </nav>
    </header>
    <main>
      <h2>Условия и создание элементов</h2>
      <h3>Скрипты</h3>
      <p>
        Браузер обрабатывает инструкции последовательно: сначала в первом файле,
        потом во втором - как будто они все находятся в одном месте. Программы
        чато разбивают на несколько файлов, обычно одному файлу соответствует
        одна задача: например, управление темами или подписка на рассылку.
      </p>
      <h3>Создаём счётчик лайков</h3>
      <p>
        Нам предстоит доработать систему лайков. Сейчас пользователь можнт
        ставить и отменять свои лайки, кликая на "сердечко" под картинкой в
        новости. Но при этом не учитывается и не показывается, сколько человек
        лайкнули новость. Исправим это, добавив счётчик.
      </p>
      <p>
        Кнопка "сердечко" сохранена в переменной <span>heart</span>. Когда
        пользователь ставитлайк, кнопке добавляется класс <span>added</span>, и
        "сердечко" становится полностью закрашенным. Когда лайк отменяют, класс
        <span>added</span> убирается, и кнопка возвращается в первоначальное
        состояние. За переключение класса отвечает метод
        <span>classList.toggle</span>. Для отображения числа лайков на странице
        мы подготовили элемент с классом <span>likes-number</span>.
      </p>
      <p>Вот как выглядит кнопка в разметке:</p>
      <code>
        &lt;!-- Лайка нет сердечко пустое --&gt;<br />
        &lt;button class="heart" type="button"&gt;&lt;span
        class="likes-number"&gt;&lt;/span&gt;&lt;/button&gt; <br />
        <br />
        &lt;!-- Лайка нет сердечко пустое --&gt;<br />
        &lt;button class="heart added" type="button"&gt;&lt;span
        class="likes-number"&gt;&lt;/span&gt;&lt;/button&gt;
      </code>
      <p>
        Чтобы хранить количество лайков, нам понадобится переменная-счётчик. Её
        значением будет число.
      </p>
      <code>
        // Присвоим переменной значение - число <br />
        let number = 7;
      </code>
      <p>Обратите внимание, мы не оборачиваем числа в кавычки.</p>
      <p>
        Назовём переменную-счётчик <span>counter</span> и присвоим ей значение
        <span>0</span> - пока никто не кликнул, лайков нет. После этого выедем
        значение счётчика на страниу с помощью свойства
        <span>textContent</span> элемента с классом <span>likes-number</span>
      </p>
      <h3>Изменяем значение счётчика</h3>
      <p>
        Мы создали счётчик лайков, но пока его значение не изменяется при кликах
        на "сердечко". Давайте это исправим. Нам нужно чтобы значение счётчика
        увеличивалось, когда пользователь ставит лайк, и уменьшалось, когда лайк
        отменяют.
      </p>
      <p>
        Чтобы увеличить или уменьшить число в JavaScript, можно использовать
        разные записи: полную или краткую - результат будет одинаковым.
      </p>
      <code>
        let number = 0; <br />
        <br />
        // Полная запись <br />
        number = number + 2; // Значение переменной: 2 <br />
        number = number - 2; // Значение переменной: 0 <br />
        <br />
        // Краткая запись <br />
        number += 2; // Значение переменной: 2 <br />
        number -= 2; // Значение переменной: 0 <br />
      </code>
      <p>
        Наш счётчик будет увеличиваться и уменьшаться на единицу. Это очень
        распространённая операция, и в JavaScript для нёё есть особая запись.
      </p>
      <code>
        // Увеличить число на 1 <br />
        number++; // Значение переменной: 1 <br />
        <br />
        // Уменьшит число на 1 <br />
        number--; // Значение переменной: 0
      </code>
      <p>
        Скажем JavaScript увеличивать значение <span>counter</span> на 1, когда
        пользователь кликает на "сердечко", и убедимся, что число на странице
        меняется при каждом клике.
      </p>
      <h3>Метод classList.contains, проверяем наличие класса</h3>
      <p>
        Мы создали счётчик лайков, знаение которого увеличивается при каждом
        клике. Но ведь число лайков не должно только расти.
      </p>
      <p>
        Если пользователь ещё не ставил лайк, то клик на "сердечко" лайк
        добавит, и значение счётчика должно увеличиться. А если лайк уже есть,
        то клик по кнопке его отменит, и значение счётчика должно уменьшиться.
        Как нам различать эти кнопки? Мы можем проверить, если ли у элемента
        <span>heart</span> класс <span>added</span>. Если класса у элемента ещё
        нет, то лайк добавляется, а если класс уже есть, то лайк снимается.
      </p>
      <p>
        Чтобы проверить, есть ли у элемента класс, используем метод
        <span>classList.contains</span>:
      </p>
      <code> элемент.classList.contains('класс'); </code>
      <p>
        В скобках указывается класс, наличие котрого нужно проверить. Когда
        метод сообщает какую-то информацию, говорят, что он возвращает значение.
        Метод <span>classList.contains</span> вернёт <span>true</span> (истина),
        если класс у элемента есть, и <span>false</span> (ложь), если класса
        нет.
      </p>
      <p>
        Значение <span>true</span> и <span>false</span> называют булевыми. Таких
        значений всего два.
      </p>
      <p>
        Нам нужно проверять, сть ли у элемента <span>heart</span> класс
        <span>added</span>. Посмотрим, как работает метод
        <span>classList.contains</span>: скажем JavaScript выводить в консоль
        значения, которые этот метод возвращает, и кликнем несклько раз на
        "сердечко", чтобы переключить класс.
      </p>
      <h3>Условная конструкция if</h3>
      <p>
        Мы научились определять, есть ли у элемента класс. От класса зависит,
        что нам нужно делать: увеличивать или уменьшать число на счётчике
        лайков. Как сказать JavaScript, чтобы в одном случае выполнялись одни
        инструкции, а вдругом - другие? Воспользуемся условной конструкцией.
      </p>
      <p>
        Условная конструкция позволяет выполнять действия в зависимости от
        условия. Условие - это инструкця, которая возвращает
        <span>true</span> или <span>false</span>. Условная конструкция выглядит
        так:
      </p>
      <code>
        if (условие) { <br />
        // Инструкции, которые выполнятся, если условие истинно <br />
        }
      </code>
      <p>
        Условие запиывают в <i>круглых</i> скобках после слова if. После этого
        внутри <i>фигурных</i> скобок пишут инструкции, которые выполнятся, если
        условие <i>истинно</i>. Условие считается истинным, если инструкция
        внутри круглых скобок возвращает <span>true</span>. Например:
      </p>
      <code>
        let element = document.querySelector('div'); <br />
        if (element.classList.contains('some-class')) { <br />
        // Сообщение выведется, только если класс у элемента есть <br />
        cosole.log('Условие истинно'); <br />
        }
      </code>
      <p>
        Если у элемента <span>heart</span> есть класс <span>added</span>,
        значит, пользователь уже поставил лайк и теперь хочет его отменить. В
        этом случае мы должны уменьшить значение счётчика. Добавим в скрипт
        условную конструкцию: если класс у элемента ессть, то значение счётчика
        уменьшается на 1.
      </p>
      <h3>Конструкция else, альтернативная ветка</h3>
      <p>
        Здорово, наш счётчик уже не растёт при каждом клике! Но он и не
        уменьшается, когда лайк убирают. Это происходит потому, что, когда у
        элемента <span>heart</span> есть класс <span>added</span>, мы сначала
        уменьшаем значение счётчика, а после условной конструкции снова
        увеличиваем. Сейчас конструкция <span>counter++;</span> выполняется
        независимо от условия. Как делать так, чтобы значение увеличивалось
        только тогда, когда класса нет?
      </p>
      <p>
        Используем <span>else</span>. Это конструкция, которая говорит
        JavaScript, что делать, если условие <span>if</span> ложно. Внутри
        фигурных скобок после <span>else</span> пишут инструкции, которые должны
        выполнить, если условие вернёт <span>false</span>.
      </p>
      <code>
        if (условие) { <br />
        // Инструкции, которые выполняется, если условие истинно <br />
        } else { <br />
        // Инструкции, которые выполняются, если условие ложно <br />
        }
      </code>
      <p>
        Использование уловных конструкций в скрипте ещё называют ветвлением, а
        код внутри фигурных скобок - веткой.
      </p>
      <p>
        Добавим в наш скрипт ветку <span>else</span>: скажем JavaScript
        уввеличвать значение счётчика только тогда, когда у элемент
        <span>heart ещё нет класса <span>added</span>.</span>
      </p>
      <h3>Изменяем значение из разметки</h3>
      <p>
        Счётчик лайков работает! Когда лайк ставят, значение счётчика
        увеличивается, а когда лайк отменяют, значение уменьшается. Есть только
        одна маленькая проблема: наш счётчик не учитывает других пользователей
        сайта. Что если кто-то другой уже поставил лай? Нам следует брать число
        лайков, которое уже есть на странице и изменять именно его.
      </p>
      <p>
        Возьмём значение из <span>likesNumber.textContent</span> и изменим его
        на единицу:
      </p>
      <code>
        // Увеличит значение на 1 <br />
        likesNumber.textContent++; <br />
        <br />
        // Уменьшит значение на 1 <br />
        likesNumber.textContent--;
      </code>
      <p>
        Теперь переменная <span>counter</span> уже не нужна, так что мы её
        просто удалим. Счётчик лайков готов.
      </p>
      <h3>Комментарии для новостного сайта</h3>
      <p>
        Больше, чем читать новости, люди любят их обсуждать. Поэтому на
        новостном сайте должны быть ещ и комментарии. И комментарии будут
        анонимными.
      </p>
      <p>
        Добавим на страницу ленту комментариев и форму добавления нового
        комментария. Форму сохрнаим в переменную <span>commentForm</span> и
        добавим обработчик событий.
      </p>
      <p>
        Лента, куда будут выводиться комментарии, это элемент с классом
        <span>comment-list</span>. В ленте уже есть комментарий.
      </p>
      <code>
        &lt;ol class="comment-list"&gt; <br />
        &lt;li class="user-comment"&gt;Да ну, бред какой-то...&lt;/li&gt; <br />
        &lt;/ol&gt;
      </code>
      <p>
        Скажем JavaScript найти элемент с классом <span>comment-list</span>,
        запишем этот элемент в переменную изменим его текстовое содержимое.
        Посмотрим, что из этого получится.
      </p>
      <h3>Метод append, добавление содержимого</h3>
      <p>
        Мы изменили текстовое содержание элемента <span>commentList</span> и при
        этом удалили комментарий, который уже был в ленте. Это произошло потому,
        что новое значение <span>textContent</span> переписывает всё содержимое
        элемента, а значит, с его помощью не получится устроить жаркую дискуссию
        в комментариях. Нужно, чтобы новые комментарии добавлялись в конец
        ленты, после старых комментариев. С этим на поможет метод
        <span>appaden</span>. Используем его так:
      </p>
      <code> элемент-родитель.append(добвляемый-элемент); </code>
      <p>
        Метод <span>append</span> добавляет указанный в скобках элемент в конец
        элемента-родителя. При этом содержимое элемента-родителя не затирается.
        Добавлять с помощью этого метода можно и элементы, и простые строки.
      </p>
      <p>Представим, что у нас есть следующая разметка на странице:</p>
      <code> &lt;p&gt;Хорошо быть котом.&lt;/p&gt; </code>
      <p>Найдём этот абзац и используем метод <span>append</span>:</p>
      <code>
        let paragraph = document.querySelector('p'); <br />
        paragraph.append('А разработчик - ещё лучше!');
      </code>
      <p>
        Когда команда выполнится, в браузере пользователя разметка будет
        выглядеть так:
      </p>
      <code>
        &lt;p&gt;Хорошо быть котом. А разработчиком - ещё лучше!&lt;/p&gt;
      </code>
      <p>
        Новая строка добавилась в конец элемента, ничго не удаляя. То, что нужно
        для новых комментариев! Чтобы в этом убедиться, используем метод
        <span>append</span> и добавим строку в конец ленты комментариев
      </p>
      <h3>Метод createElement, создание элемента</h3>
      <p>
        У нас получилось добавить сообщение в конец ленты и сохранить всё, что
        там было до этого!
      </p>
      <p>
        Однако каждый комментарий в ленте - это не просто строка, а отдельный
        элемент. Перед тем, как добавить его в ленту, этот элемент нужно
        создать.
      </p>
      <p>
        Чтобы создать новый элемент, воспользуемс методом
        <span>createElement</span>:
      </p>
      <code> document.createElement('имя тега') </code>
      <p>
        Мы создаём новый элемент на странице, к которой подключён скрипт,
        поэтому используем слово <span>document</span>. Внутри скобок в кавычках
        нужно указать элемент, который мы хоим создать. Например:
      </p>
      <code>
        // Создаст новый элемент &lt;div&gt; и запишет его в переменную <br />
        let newElement = document.createElement('div');
      </code>
      <p>
        Лента комментариев на нашей странице - это нумерованный список, в каждый
        комментарий - элемнт списка. Поэтому мы создаём элемент <span>li</span>:
      </p>
      <code>
        &lt;ol class="comment-list"&gt; <br />
        &lt;li class="user-comment"&gt;Да ну, бред какой-то...&lt;/li&gt;
        &lt;/ol&gt;
      </code>
      <p>
        Создадим новый элемент списка и протестируем результат: скажем
        JavaScript вывести созданный элемент в консоль
      </p>
      <h3>Добавляем элемент на страницу</h3>
      <p>
        Отлично, мы создали с помощью JavaScript новый элемент списка и вывели
        его в консоль. Но на странице новый элемент не появился. Почему? Дело в
        том, что JavaScript не знает, где его разместить. Пока мы ему не скажем,
        новый элемент будет доступен из скрипта, но в разметке не появится.
      </p>
      <p>
        Чтобы указать, где должен находиться новый элемент, воспользуемся уже
        знакомым нам методом <span>append</span>:
      </p>
      <code>
        // Создаём ноывй элемент <br />
        let newElement = document.createElement('div'); <br />
        <br />
        // Находим элемент-родитель <br />
        let parent = document.querySelector('.parent') <br />
        <br />
        // Добавляем новый элемент в конец элемента-родителя <br />
        parent.append(newElement);
      </code>
      <p>
        На новостном сайте новые комментарии должны добавляться в конец ленты.
        Вот что произойдёт, когда мы добавим созданный элемент:
      </p>
      <code>
        &lt;-- Исходная разметка --&gt; <br />
        &lt;ol class="comment-list"&gt; <br />
        &lt;li class="user-comment"&gt;Да ну, бред какой-то...&lt;/li&gt; <br />
        &lt;/ol&gt; <br />
        <br />
        &lt;!-- В браузере после comentList.appen(newComment) --&gt; <br />
        &lt;ol class="comment-list"&gt; <br />
        &lt;li class="user-comment"&gt;Да ну, бред какой-то...&lt;/li&gt; <br />
        &lt;li&gt;&lt;/li&gt; <br />
        &lt;/ol&gt;
      </code>
      <p>
        Кстати, метод <span>append</span> не копирует элементы, а перемещает.
        Если указать в скобках элемент, который уже есть в разметке, этот
        элемент исчезнет со своего прежнего места и появится так, куда его
        добавил метод <span>append</span>. Получить таким образом несколько
        элементов не выйдет.
      </p>
      <h3>Добавляем комментарий при отправке формы</h3>
      <p>Ура! Мы создали новый элемент и добавиои его на страницу!</p>
      <p>
        Чтобы система комментариев заработала, новый элемент писка должен
        появляться в ленте каждый раз, когда пользователь отправляет форму. Для
        этого создавать и добавлять ноывй элемент нужно внутри обработчика
        событий.
      </p>
      <p>
        Перенесём наш код внутрь обработчика <span>onsumbit</span> и попробуем
        добавить в ленту несколько новых элементов.
      </p>
      <h3>Меняем свойства созданного элемента</h3>
      <p>
        Мы научились создавать в ленту новые элементы при отправке формы! Чтобы
        они стали похожи на комментарий, который уже есть в ленте, нужно
        добавить новым элементам подходящий класс.
      </p>
      <p>
        Элементы, созданные с помощью метода <span>createElement</span>, можно
        изменять так же, как и любые другие. Мы можем менять их текстовое
        содержимое, переключать классы и так далее.
      </p>
      <code>
        // Создаём новый абзац <br />
        let newElement = document.createElement('p'); <br />
        <br />
        // Меняем текстовое содержимое <br />
        newElement.textContent = 'Я ноывй абзац!'; <br />
        <br />
        // Добавялем класс <br />
        newElement.classList.add('some-text')<br />
        <br />
        // Добавляем элемент на страницу <br />
        parent.append(newElement);
      </code>
      <p>
        Когда инструкции будут выполнены, на страницу появится новый абзац с
        классом <span>some-text</span>.
      </p>
      <code>
        &lt;div class='parent'&gt; <br />
        &lt;!-- Содержимое элемента parent --&gt; <br />
        &lt;p class='some-text'&gt;Я новый абзац!&lt;/p&gt; <br />
        &lt;/div&gt;
      </code>
      <p>
        У комментариев в ленте должен быть класс <span>user-coment</span>.
        Добавим его созданному элементу перед тем, как вывести его на страницу.
        А чтобы элемент ещё больше походил на комментарий, запишем в его
        текстовое содержимое времнный текст-заглушку. Его ещё называют "рыбой".
        В будущем мы будем использовать данные, которые пользователь ввёл в
        форму, но для тестирования кода хватит и "рыбы".
      </p>
      <p>Если всё правильно, в ленте появится новый комментарий</p>
      <code>
        &lt;ol class="comment-list"&gt; <br />
        &lt;li class="user-comment"&gt;Да ну, бред какой-то...&lt;/li&gt; <br />
        &lt;li class="user-comment"&gt;Новый коментарий&lt;/li&gt; <br />
        &lt;/ol&gt;
      </code>
      <h3>Завершаем работу над коментариями</h3>
      <p>
        Мы научились создавать элементы, менять их и добавлять на страницу.
        Комментарии для нвостного сайта практически готовы, остался последний
        шаг - добавить в ленту комментарий именно с тем текстом, который
        пользователь ввёл в форму.
      </p>
      <p>Для этого мы используем свойство <span>value</span>.</p>
      <code>
        let input = = document.querySelector('input'); <br />
        let paragraph = document.querySelector('p') <br />
        <br />
        // Записываем данные из поля ввода в ткстовое содержимое элемента <br />
        paragraph.textContent = input.value;
      </code>
      <p>
        Данные из поля ввода мы запишем вместо "рыбы" в
        <span>textContent</span> созданного нами элемента. А само поле ввода
        после этого очистим, чтобы пользователь по ошибке не отправил один и тот
        же комментарий несколько раз. Для этого в свойство
        <span>value</span> поля ввода запишем пустую строку. Вот так:
      </p>
      <code>input.value = ''</code>
      <p>
        Текст комментария мы возьмём из поля ввода с классом
        <span>coment-field</span> и запишем в текстовое содержимое нового
        комментария перед тем, как добавить его на страницу. После этого очистим
        поле ввода - и дело сделано!
      </p>
    </main>
    <footer>
      <h3>Здесь могла быть ваша кувшинка</h3>
    </footer>
  </body>
</html>
