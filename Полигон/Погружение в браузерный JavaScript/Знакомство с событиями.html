<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>Знакомство с событиями</title>
    <link rel="stylesheet" href="../../стили/Полигон.css" />
  </head>
  <body>
    <header>
      <img
        src="../../avatar/avatar1.jpg"
        width="90"
        height="90"
        alt="Лягушка"
      />
      <nav>
        <a href="../../Полигон.html">Назад</a>
        <a href="Знакомство с событиями/1 сайт/1 сайт.html">Сайт 1</a>
        <a href="знакомство с событиями/2 сайт/сайт 2.html">Сайт 2</a>
      </nav>
    </header>
    <main>
      <h2>Знакомство с событиями</h2>
      <h3>Знакомимся с событиями</h3>
      <p>
        Босс доволен вашим прогрессом и доверяет вам серьёзную задачу. Нужно
        запрограммировать всплывающее окно. Для краткости такое окно может
        называть проще - попап.
      </p>
      <p>
        <i
          >Ты доказал, что можешь писать код и решить задачи. Пора переходить из
          стажёров в джуниоры!</i
        >
      </p>
      <p>
        <i
          >Только не расслабляйся, работы много. Нужно оживитлять интерфейсы и
          добавлять взаимодействие с пользователем.</i
        >
      </p>
      <p>
        <i
          >Запрограммируй всплывающее окно с контактами компании. Тебе нужен
          элемент с классом <span>modal</span>.</i
        >
      </p>
      <p>
        <i
          >При клке по кнопке с классом <span>button-open</span> попапу должен
          добавляться класс <span>modal--show</span>, так окно появится на
          странице.</i
        >
      </p>
      <p>
        <i
          >По клику по кнопке с классом <span>button-close</span> у окна должен
          удаляться класс <span>modal-show</span>, и попап должен закрыться.</i
        >
      </p>
      <p>
        <i
          >Ещё попап должен закрываться, если пользователь нажал клавишу
          <span>ESC</span>, пока окно было открыто.</i
        >
      </p>
      <p>Давайте сначала разберёмся, что значит "оживлять" интерфейс?</p>
      <p>
        Пока что страница статическая. У нас есть набор тегов и текста. В
        разметке у нас есть попап с классом <span>model</span>, его не видно на
        странице. Если добавим этому попапу класс <span>modal-show</span>, окно
        отобразится в интерфейсе. Но ведь пользователь не будет сам менять
        классы в разметке?
      </p>
      <p>
        Если представить взаимодействие пользователя и страницы, получится
        примерно такой сценарий:
        <span
          >кнопка на странице, попап скрыт - пользователь нажимает на кнопку -
          попап появляется на странице</span
        >.
      </p>
      <p>
        Этап, где пользователь нажимает на кнопку - связывающее звено между
        состоянием закрытого и открытого попапа. Интерфейс становится "живым" и
        реагирует на действия пользователя. Дейтвие, когда пользователь что-то
        делает с элементами страницы (например, кликает по кнопке или нажимает
        клавишу) называется <b>событием</b>. Именно с событиями мы и будем
        работать, чтобы выполнить задачу.
      </p>
      <p>
        Сначала с помощью <span>querySelector</span> найдём попап, с которым
        будем рабоатть, и сохраним его в переменную. Затем проверим, как будет
        выглядеть окно в открытом состоянии.
      </p>
      <h3>Как добавить обработчик</h3>
      <p>
        У нас есть кнопка, клик по которой должен вызвать появление попапа. План
        такой: нам нужно поймать тот момент, когда пользователь кликнет по
        кнопке. Когда это произойдёт, мы добавим попапу класс
        <span>modal-show</span>, чтобы окно появилось на странице.
      </p>
      <p>
        Действие "помать тот момент, когда пользователь кликнет по кнопке" можно
        назват по-другому: добавить <b>обработчик события клика</b> по кнопкее.
        Далее, для простоты, опустим слово "событие" и будем говорить так:
        <i>добавить обработчик клика по кнопке.</i>
      </p>
      <p>
        Что значит добавить обработчик? Чтобы определить момент, когда
        происходит какое-то событие на странице, в нашем случае клик по кнопк,
        мы добавляем кнопке обработчик, который сработает,
        <b>когда произойдёт клик.</b>
      </p>
      <p>Посмотрим на синтаксис добавления обработчика.</p>
      <code>
        let button = document.querySelector('.button'); <br />
        <br />
        button.addEventListener('clicl', function () { <br />
        // Инструкции <br />
        })
      </code>
      <p>
        Функция <span>addEventListener()</span> говорит о том, что мы добавляем
        обработчик события на элемент. Дословно "добавляем слушатель события".
        Обработчик "слышит" всё, что происхдит на странице и обязательно
        услышит, когда произойдёт то событие, которое нам нужно. Если мы
        правильно его настроим.
      </p>
      <p>
        Дальше мы подробно разберём синтаксис обработчиков событий и их
        настройку, а пока найдём кнопку, клик по которой должен вызвать открытие
        попапа. Это кнопка с классом <span>button-open</span>. Добавим этой
        кнопке обработчик по аналогии с примером выше.
      </p>
      <h3>Как устроены события</h3>
      <p>Теперь подробно разберём, что означает подобная запись:</p>
      <code>
        let button = document.querySelector('.button'); <br />
        <br />
        button.addEventListener('clicl', function () { <br />
        // Инструкции <br />
        })
      </code>
      <h4>1. Элемнт</h4>
      <p>
        В примере выше <span>button</span> - кнопка, на которой мы будем ждать
        пользовательское событие (клик, нажатие, ввод). Этот элемент указывается
        в самом начале.
      </p>
      <p>
        Далее через точку, мы добавляем <span>addEventListener</span>. То есть
        указываем, что хотим добавить "слушатель события".
      </p>
      <h4>2. Название события</h4>
      <p>
        Первый параметр функции <span>addEventListener</span> - название
        события, которое мы хотим поймать. Название записывается строкой,
        поэтому обязательно указываается в кавычках. Для всех событий есть
        специальные зафикированные названия, поэтому мы не можем ловить событие
        клика, передав любую строку, которая придёт в голову, например,
        <span>'push'</span>.
      </p>
      <h4>3. Обработчик</h4>
      <p>
        Второй параметр <span>addEventListener</span> - функция. Это и есть
        обработчик события. Внутри этой функции мы указываем, что нужно сделать,
        когда произойдёт событие, как его нужно обработать. Инструкции внутри
        этой функции могут быть любыми: можно выводить сообщение в консоль (это
        поможет при откладке кода), менять классы или содержимое элементов,
        вызывать другие функции. Внутри это акая же функция, как и любая другая,
        толко с некоторыми особенностями, о которых мы погвоорим позже.
      </p>
      <p>
        Главное, на что нужно обратить внимание - функция, переданная в
        обработчик, <b>не выполняется сразу</b>. Действия из тела этой функции
        выполнятся только когда произоёдт установленное событие.
      </p>
      <p>
        В итоге всю запись из примера можно прочитать так: добавим обработчик
        клика на кнопку <span>button</span>. При клике по кнопке должны
        выполниться какие-то инструкции.
      </p>
      <p>
        Нужную кнопку мы уже нашли и записали в переменную
        <span>openPopupButton</span>, обработчик клика тоже добавили. Тепеь
        запишем инструкции в обаботчик. При клике будем выводить сообщение в
        консоль, чтобы убедиться, что событие действительно срабатывает.
      </p>
      <h3>Действия по умолчанию</h3>
      <p>
        Обработчик клика сработал, сообщение вывелось, но вместе с тем произошёл
        переход по ссылке на другую страницу.
      </p>
      <p>
        Кнопка свёрстана ссылкой (тег <span>&lt;a&gt;</span>), а не кнопкой (тег
        <span>&lt;button&gt;</span>) на случай, если у пользователя не будут
        рабоать скрипты. Такое бывает редко, но наш верстальщик продумал такой
        сценарий. Мы не можем поменять вёрстку наша задача - программировать
        логику. На приктике это встречается часто: разработчк получает готовую
        вёрстку и должен решать свои задачи, не меняя разметку.
      </p>
      <p>Что же делать?</p>
      <p>
        Некоторые элементы страницы имеют <i>действия по умоланию</i>. Их ещё
        называют <i>дефолтными действиями</i>. Напимер, клик по кнопке
        отправления формы вызывает отправку данных этой формы на сервер, а при
        клике по ссылке браузер переходит по этой ссылке. Это как раз наш
        случай!
      </p>
      <p>
        Дефолтные действия можно отменять при необходимости, мы так и поступм. В
        этом поможет объект <span>event</span>.
      </p>
      <p>
        Объект <span>event</span> - параметр функции-обработчика. н всегда
        передаётся браузером в эту функцию <b>в момент наступления события</b>.
        Этот объект содержит много полезных свойств и методов, в частности
        метод, который отменяет действия по умолчанию:
        <span>preventDefault()</span>.
      </p>
      <p>
        Чтобы использовать своства и методы объекта <span>event</span>,
        достаточно указать этот объект параметром функции-обработчика и написать
        инструкции. Остальное сделает JavaScript. Среди некоторых разработчиков
        принято называть параметр сокращённо - <span>evt</span>. Это позволяет
        избежать некоторых ошибок, о которых мы погвооим в будущих курсах. Мы
        тоже будем называть параметр обработчика <span>evt</span>. Объект
        события будет передан в функцию, как только это событие случится.
      </p>
      <code>
        link.addEventListener('clicl', function (evt) { <br />
        // Отменяем дейтвие по умолчанию <br />
        evt.preventDefault() <br />
        })
      </code>
      <p>
        В примере мы отменили действие по умолчанию и при клике по ссылке
        переход не произойдёт.
      </p>
      <h3>Передайте функцию, пожалуйста</h3>
      <p>
        Теперь переход по ссылке не происходит, и мы можем добавить класс
        <span>modal-show</span> элементу из переменной <span>popup</span>.
      </p>
      <p>
        Мы уже разобрались с синтаксисом событий и объектом <span>event</span>,
        но не обсудили ещё кое-что. Возможно, запись добавления обработчика
        показалась вам необычной.
      </p>
      <code>
        let button = document.querySelector('.button'); <br />
        <br />
        button.addEventListener('clicl', function () { <br />
        // Инструкции <br />
        })
      </code>
      <p>
        Мы передаём одну функцию в качестве параметра в другую функцию - в
        <span>addEventListener</span>. Така запись может удивить, но это обычная
        практика - в JavaScript так делать можно.
      </p>
      <code>
        let getString = function () { <br />
        return 'Привет из фуункции!';<br />
        }<br />
        <br />
        console.log(getString); // Выведет код функции <br />
        console.log(getString()); // Выведет: Привет из функции!
      </code>
      <p>
        Мы передали функцию и вызов функции в <span>console.log</span>. А ведь
        <span>console.log()</span> - тоже функция.
      </p>
      <code>
        console.log(function () { <br />
        return 'Привет из фуункции!';<br />
        }); <br />
        // Выведет код функции <br />
        <br />
        console.log(function() {<br />
        return 'Привет из фуункции!';<br />
        }());<br />
        // Выведет: Привет из функции!
      </code>
      <p>
        У такой функции нет своего имени, она не записана в переменную. Мы
        создаём её там же, где передаём в другую функцию. Такие функции, которые
        создаются в момент передачи и не имеют названия, называются
        <i>анонимными функциями.</i>
      </p>
      <p>
        Обатите внимание на самую важную часть - мы <b>передаёём функцию</b> в
        обработчики, а не вызываем её. Если мы вызовем обработчик, код из него
        сразу выполнится, и в нужный момент наши инструкции не сработают. Код
        выполнится только один раз в момент вызова и больше не будет
        повторяться. Это распространённая ошибка, но так делать неправильно.
      </p>
      <code>
        // Так добавлять обработчик неправильно <br />
        <br />
        button.addEvntListener ('click', function () { <br />
        console.log('Клик по кнопке'); <br />
        }()); <br />
        // В консоль сразу же выведется сообщение: Клик по кнопке
      </code>
      <p>
        Вообще JavaScript выполняет программу последовательно, команду за
        командой. Но к событиям это не относится. Дело в том, что события не
        происходят последовательно, синхронно. Мы настраиваем бработчик, но
        интрукции выполняются не сразу, а только тогда, когда произойдёт
        событие. Это может произойти и через 5 минут после открытия сайта, и
        через 10, а может пользователь вообще не кликнет по ссылке или кнопке.
        Тогда событие не случится. События <b>асинхронны</b>, то есть происходят
        не по расписанию в какое-то конкретное время, друг за другом, а тогда,
        когда понадобится. В этом случае главная сила событий.
      </p>
      <h3>Прячем всплывающее окно</h3>
      <p>
        Мы добавили обработчик и теперь попап открывается, если нажать на кнопку
        <span>'Показать контакты'</span>. Сделаем так, чтобы попап закрывался по
        клику на крестик (кнопка с классом <span>button-close</span>).
      </p>
      <p>
        Для этого сделаем уе знакомые нам действия: найдём кнопку, запишем в
        переменную, добавим ей обработчик клика. По клику будем удалять класс
        <span>model-show</span> у попапа, чтобы он закрылся.
      </p>
      <p>Как добавлять классы элементам мы знаем, а как их удалять?</p>
      <p>
        Нужно исползовать уже знакомый объект <span>classList</span>. Если для
        добавления класса мы используем метод <span>add()</span>, то для
        удаления надо обратиться к методу <span>remove()</span>, передав строку
        с классом, который нужно удалить. Выглядит это так:
      </p>
      <code>
        let popup =document.querySelector('.popup'); <br />
        // Перед названием селектора ставим точку <br />
        <br />
        popup.classList.remove('popup-open'); <br />
        // Перед названием класса точка не ставится
      </code>
      <p>Результат в разметке такой же, как при удалении класса вручную.</p>
      <p>
        Найдём кнопку с помощью <span>querySelector</span>. Только искать будем
        не по всему документу, а внутри элемента <span>popup</span>. Мы точно
        знаем, что кнопка нахдится там, поэтому избыточно запускать поиск по
        всему документу. Это ресурсоёмкая операция, потому что документ может
        быть очень большим.
      </p>
      <p>
        Добавим обработчик клика по кнопке с классом <span>button-close</span>,
        проверим, что всё настроено правилно и попап действительно закрывается.
        В этом обработчике мы не будем указывать параметр <span>evt</span>, так
        как мы не собираемся использовать объект события внутри
        функции-обработчика. Элемент <span>button-close</span> - кнопка. У неё
        нет действия по умолчанию, которые надо отменять.
      </p>
      <h3>Жми на клавишу</h3>
      <p>
        Попап уже открывается и закрывается по кликам, осталось дписать код так,
        чтобы попап закрывался по нажатию на клавишу <span>ESC</span>.
      </p>
      <p>
        С кликом по кнопке мы вроде разобрались, а как повесить обработчик на
        нажатие клавиши?
      </p>
      <p>
        У события "нажатия на клавишу" есть специальное название -
        <span>keydown</span>. Такое событие срабатывает при нажатии на любую
        клавишу. Обратите внимание, слушать это событие можно только на
        элементах, которые имеют состояние фокуса: поля ввода, кнопки, элементы
        с атрибутом <span>tabindex</span>, документ. При нажатии фокус должен
        находиться на соответствующем элементе.
      </p>
      <code>
        document.addEventListener('keydown', function() { <br />
        // Код отсюда выполнится при нажатии любой клавиши <br />
        })
      </code>
      <p>
        Добавим обработчик нажатия клавиши на документ и проверим, как он
        работает.
      </p>
      <h3>Выбор клавиши</h3>
      <p>
        Соыбтие мы назвали, оно срабатывает при нажатии на любую клавишу. Но нам
        любая не подходит, нам нужен <span>ESC</span>. Как выполнить код по
        нажатию только на одну конкретную клавишу? Обратимся к уже знакомому
        объекту <span>event</span>.
      </p>
      <p>
        Мы говорили раньше, чл у объекта события есть много полезных свойств.
        Напимер, тип события, введённый символ, координаты курсора в момент
        наступления события и многое другое. В том числе и код клавиши, которую
        нажал пользователь. Это свойство называется <span>keyCode</span>.
      </p>
      <p>
        С помощью этого свойства каждую клавишу можно определить по коду.
        Например, у <span>Enter</span> код <span>13</span>, а у
        <span>ESC</span> - код <span>27</span>. Эти номера универсальны и
        одинаковы в любой раскладке.
      </p>
      <p>
        Теперь мы значем, что есть объект <span>event</span>, который содержим
        номер нажатой клавиши в свойстве <span>keyCode</span>, и знаем код
        необходимой клавиши. Осталось всё это собрать в одном обработчике.
      </p>
      <code>
        document.addEventListener('keydown', function(evt) { <br />
        // Проверяем, что код клавиши равен 27 <br />
        if (evt.keyCode === 27) { <br />
        //Код отсюда выполнится только при нажатии на ESC <br />
        } <br />
        })
      </code>
      <p>
        Настроим наш обработчик, чтобы инструкции выполнялись только при нажатии
        <span>ESC</span>.
      </p>
      <h3>Добро пожаловать в нашу галерею</h3>
      <p><i>Нужно запрограммировать галлерею с фотографиями для сайта.</i></p>
      <p>
        <i
          >Галлерея состоит из нескольких миниатюр (элементы с классом
          <span>gallery_photo-preview</span>) и большой фотографии (класс
          <span>full-photo</span>). По клику на миниатюру должно меняться
          большое изображение. Большая картинка должна соответствовать превью,
          по которой кликнул пользователь.</i
        >
      </p>
      <p>
        <i
          >Данные для изображений собраны в массив <span>photos</span>. Каждый
          элемент массива - путь до полноразмерной фотографии. Порядок элементов
          в этом массиве такой же, как и порядок миниатюр в разметке.</i
        >
      </p>
      <p>
        Изображения превью лежат внутри кнопок с классом
        <span>gallery_photo-preview</span>, клики именно по этим кнопкам будут
        менят содержимое большого изображения (класс <span>full-photo</span>).
        От нас требуется запрограммировать взаимодействие интерфейса с
        пользователем.
      </p>
      <p>
        Сначала мы найдём все миниатюры с помощью
        <span>querySelectorAll</span> и большое изображение через
        <span>querySelector</span>, запишем найденные в переменные.
      </p>
      <h3>Click 'Em All!</h3>
      <p>
        Мы нашли все изображения на странице, теперь можно программировать
        логику. Взаимодействие должно быть таким: пользователь кликает по превью
        - меняется большая картинка.
      </p>
      <p>
        Первым делом нужно добавить обработчики клика на каждую миниатюру. Все
        миниатюры храняться в коллекции <span>thimbnails</span>. Мы можем
        перебрать эту коллекцию в цикле, добавляя обработчик клика на текущий
        элемент коллекции. Так мы добавим обработчик на каждую миниатюру.
      </p>
      <p>
        Внутри обработчика выведем строку в консол, а затем попроубем кликнуть
        по миниатюрам. Так мы убедимся, что обработчики срабатывают.
      </p>
      <h3>Добавим картинку</h3>
      <p>
        Обработчики клика добавили, убедились, что всё работает. Как заставить
        большую картинку ментся по кликам пользователя?
      </p>
      <p>
        У изображения есть атрибут <span>src</span>, которым можно управлять из
        JavaScript.
      </p>
      <p>
        Чтобы изображение элемента с классом <span>full-photo</span> (переменная
        <span>fullPhoto</span>) менялост, должно измениться значение
        <span>src</span> этого элемента.
      </p>
      <p>
        У на есть массив с данными <span>photos</span>, порядок элементов в этом
        массиве такой же, как и порядок миниатюр в разметке. Все превью
        находятся в коллекции <span>thumbnails</span>. Получается, элементы
        массива <span>photos</span> подходят элементам из коллекции
        <span>thumbnails</span> с тем же индексом.
      </p>
      <p>
        Например, пользовател кликнул по самой первой миниатюре в разметке. Она
        же <span>thumbnails[0]</span> в коллекции. Тогда в большой картинке
        должно появиться изображение с адресом <span>photos[0]</span>.
        Получается такой код:
      </p>
      <code>
        thumbnails[i].addEventListener("click", function () { <br />
        fullPhoto.src = photo[0]; <br />
        });
      </code>
      <p>
        Добавим код внутрь обработчика. Будем подставлять в атрибут
        <span>src</span> значение элемента из массива <span>photos</span>.
        Индексы миниатюры и элемента с адресом картинки будут совпадать.
      </p>
      <h3>
        В систему закралась ошибка (можно избежать, если вместо
        <i>var</i> использовать <i>let</i>)
      </h3>
      <p>
        Кажется, в нашей прогамме что-о пошло не так. Кликаем по превью, а
        большая картинка не появляется. Мы проверили работу программы в
        предыдущем задании - сообщения в консоль выводились.
      </p>
      <p>Что делатют разработчики в такой ситуации? Отлаживают код.</p>
      <p>Программа перестала работать, когда мы добавили эту запись:</p>
      <code> fullPhoto.src = photos[i] </code>
      <p>
        Что с ней может быть не так? Часть <span>fullPhoto.src</span> не
        вызывает подозрений - мы нашли изображение по классу, сохранили в
        переменную, а теперь хотим что-то записать в атрибут <span>src</span>. А
        вот <span>photo[i]</span> может быть причиной сбоя.
      </p>
      <p>
        Дело не в названии массива <span>photos</span>, его мы написали
        правильно. Остаётся индекс и текущий элемент массива. Возможно, с ним
        что-то не то.
      </p>
      <p>Мы выведем их в консоль и проверим. Кажется, проблема именно там.</p>
      <h3>Область видимости</h3>
      <p>
        Ошибка обнаружена! Индекс последнего элемента в массиве
        <span>photos</span> - <span>4</span>, а значение <span>i</span> в нашем
        коде <span>5</span>, по какой миниатюре мы бы ни кликнули. В массиве
        <span>photos</span> у нас нет элемента с таким индексом, поэтому мы и
        получаем <span>underfined</span> вместо адреса изображения и никакой
        картинки не появляется. Но почему такое вообще происходит?
      </p>
      <p>
        Давайте немного отойдём в сторону от нашей задачи и разберёмся с одной
        важной концепцией JavaScript. Это поможет решить нашу проблему с
        галереей.
      </p>
      <p>
        Напишем функцию <span>eatDinner</span>. Она выводит в консоль сообщение
        о нашем обеде. У неё есть параметр <span>drink</span> и переменная
        <span>food</span>.
      </p>
      <code>
        var eatDinner = function (drink) { <br />
        var food = 'макароны'; <br />
        console.log('Поел ' + food); <br />
        console.log('Выпил ' + drink); <br />
        }; <br />
        <br />
        eatDinner('компот'); <br />
        // Выведет: Поел макароны <br />
        // Выведет: Выпил компот <br />
        <br />
        console.log('Выпил ' + food); <br />
        // Выведет ошибку <br />
        <br />
        console.log('Выпил ' + drink); <br />
        // Выведет ошибку
      </code>
      <p>
        Если мы попробуем снаружи получить доступ к переменной
        <span>food</span> у нас ничего не получится - консоль выдаст ошибку.
        Потому что
        <b>переменные из тела функции доступны только внутри этой функции</b>.
        Снаружи их получить нельзя.
      </p>
      <p>
        То же самое произойдёт, если мы захотим обратиться снаружи к параметру
        функции. Параметр хоть и задаётся снаружи, ведёт себя, как переменная
        внутри функции.
      </p>
      <p>Почему так?</p>
      <p>
        Потому что у каждой функции есть <b>область видимости</b> - все
        значения, доступные для этой функции. Область видимости ограничивается
        самой функцией. Так как переменная <span>food</span> объявлена внутри
        функции <span>eatDinner</span>, она доступна только внути области
        видимости этой функции, как и параметр <span>drink</span>. Ткие
        переменные называются <i>локальными переменными</i> функции. Их область
        видимости ограничена функцией, в которой они объявлены, и за её
        пределами эти переменные получить нельзя, поэтому такая область видиости
        тоже называется <i>локальой</i>.
      </p>
      <p>
        Давайте в этом убедимся. Вызовем функцию, а затем снаружи попробуем
        получить доступ к параметру и переменной из тела функции
        <span>eatDinner</span>.
      </p>
      <h3>Глобальная область видимости</h3>
      <p>
        Локальная область видимости ограничена функцией, поэтому мы не можем
        получить переменную функции извне. Но внутри функции, а не снаружи, всё
        работает по-другому.
      </p>
      <p>
        Есл внутри функции есть обращение к какой-то <b>не</b> локальной
        переменной, JavaScript обратится на уровень выше, за пределы функции,
        чтобы найти необходимую переменную. Говорят, что
        <i>чтение переменных происходит изнутри области видимости наружу.</i>
      </p>
      <code>
        var food = 'салат'; <br />
        <br />
        var eatDinner = function() { <br />
        // Внутри функции не объявлены локальные переменные <br />
        console.log('Поел ' + food); <br />
        }; <br />
        <br />
        eatDinner(); <br />
        // Функция обратится к переменной food <br />
        // которая объявлена снаружи eatDinner <br />
        // Выведет: Поел салат
      </code>
      <p>
        В нашем примере переменная <span>food</span> объявлена <b>не</b> внутри
        какой-то функции. Она объявлена на уровне всей программы, поэтому её
        видно отовсюду, то есть можно использовать внутри любой функции. Такие
        переменные, которые объявляются на самом верхнем уровне, вне каких-то
        функций, называются <i>глобальными</i>. А область видимост, в которой
        они находятся, называется <i>глобальной областью видимости.</i> Из
        названия понятно, что переменные из этой области видимости видны по
        всему коду программы и доступны во всех блоках кода.
      </p>
      <p>
        Если внутри функции будет обащение к переменной, которая объявлена ни в
        одной области видимости, консоль выдаст ошибку.
      </p>
      <h3>Переменные снаружи - переменные внутри</h3>
      <p>
        Из-за того, что переменные ищутся изнутри наружу, снаружи можно
        переопределять переменные, которые используются внутри функции.
      </p>
      <p>
        Представьте, что вы школьник и , наконец-то, настало время обеда. Вы
        идёте в столовую. Сегодня на обед котлеты. И не с макарошками, а с
        пюрешкой! вы обедаете и идёте учиться дальше. Много уроков, продлёнка, и
        вот уже время ужина. Вы снова идёте в столову, а там закончились
        котлеты, поэтому на ужин сельдерей. И вы ужинаете сельдереем, деваться
        некуда. Воспроизведём этот пример в коде.
      </p>
      <code>
        var food = 'котлеты с пюрешкой'; <br />
        <br />
        var eatDinner = function () { <br />
        console.log('Поел ' + food); <br />
        }; <br />
        <br />
        eatDinner(); <br />
        // Выведет: Поел котлеты с пюрешкой <br />
        <br />
        // Переопределяем переменную food <br />
        food = 'сельдерей'; <br />
        <br />
        eatDinner(); <br />
        // Выведет: Поел сельдерей
      </code>
      <p>
        Сначала значение глобальной переменной <span>food</span> было
        <span>'котлеты с пюрешкой'</span>. Мы вызвали функцию и она использовала
        это значение, потому что оно было актуально на тот момент. Затем
        значение <span>food</span> изменилось на <span>'сельдерей'</span>. С
        этого места в коде и ниже, старого значения переменной больше нет.
        Поэтому, когда мы вызвали функцию <b>после</b> переопределения
        переменной, функция использовала новое значение.
      </p>
      <h3>Стань независимым</h3>
      <p>
        Мы выяснили, что переопределение глобальных пременных влияет на
        результат работы функции, которая эти переменные использует. Но,
        вообще-то, так делать не стоит - это не лучшая практика. Переопределение
        переменных, которые использует функция, может приводить к неожиданным
        последтвиям и ошибкам в коде. Поэтому и существуют параметры, чтобы
        переиспользовать функции, явно передавая необохдимые значения.
      </p>
      <p>
        С параметрами всё легко и понятно, если мы хотим сразу вызвать функцию и
        получить результат её работы.
      </p>
      <code>
        var eatDinner = function (food) { <br />
        console.log('Поел ' + food); <br />
        }; <br />
        <br />
        eatDinner('стейк'); <br />
        // Выведет: поел стейк
      </code>
      <p>
        Что делать, если мы хотим зафиксировать в функции какое-то значение, а
        получать результат позже? Мы поступаем так с событиями: создаём функцию,
        используем внутри какие-то значения, но результат получаем не сразу, а
        когда свершится какое-то событие. Правда, не всегда всё идёт гладко,
        прям как у нас в галерее. Но мы на пути решения проблемы.
      </p>
      <p>
        Вернёмся к примеру со школьником. Что, если школьник не хочет есть
        сельдерей? И вообще не хочет зависеть от еды, которая сейчас есть в
        столовой? Конечно, ему нужно взять еду с собой из дома! Тогда у него
        всегда будет в рюкзаке контейнер с едой. Он сможет в любой момент его
        достать и перекусить. Как реализовать это в коде?
      </p>
      <code>
        var collectContainer = function () { <br />
        var food = 'макароны'; <br />
        var eatDinner = function () { <br />
        console.log('Поел ' + food); <br />
        } <br />
        return eatDinner <br />
        }; <br />
        <br />
        var schoolkid = collectContainer(); <br />
        // В переменной функция eatDinner, <br />
        // которую вернула функция collectContainer <br />
        <br />
        // Вызываем функцию eatDinner из переменной schoolkid schoolkid(); //
        Выведет: Поел макароны
      </code>
      <p>
        Не пугайтесь, в следующем задании мы подробно разберём, как эта запись
        работает и почему. А пока давайте убедимся, что этот код действительно
        выполняется так, как показано в примере.
      </p>
      <h3>Замыкания</h3>
      <p>
        Код действительно работает. В чём секрет такой странной записи и что на
        вообще означает?
      </p>
      <code>
        var collectContainer = function () { <br />
        var food = 'макароны'; <br />
        var eatDinner = function () { <br />
        console.log('Поел ' + food); <br />
        } <br />
        return eatDinner <br />
        }; <br />
        <br />
        var schoolkid = collectContainer(); <br />
        // В переменной функция eatDinner, <br />
        // которую вернула функция collectContainer <br />
        <br />
        // Вызываем функцию eatDinner из переменной schoolkid schoolkid(); //
        Выведет: Поел макароны
      </code>
      <p>
        Мы хотим, чтобы функция получила фиксированное значение, которое бы не
        зависело от изменений в глобальной области видимости. При этом результат
        работы функции мы хотим получить не сразу. Как с событиями, когда мы
        создаём обработчик, но ждём выполнение события не сразу. В нашем примере
        мы собираем школьнику контейнер с едой, чтобы он мог перекусить любимыми
        макаронами независимо от того, что дают в столовой.
      </p>
      <p>
        Код из примера работает так: мы вызываем <span>collectContainer</span> -
        функция <span>collectContainer</span> возвращает
        <span>eatDinner</span> - вызываем <span>eatDinner</span>.
      </p>
      <p>
        Мы создаём функцию внутри функции. Таким образом мы создаём одну область
        видимости внутри другой области видимости. У <span>eatDinner</span> своя
        область видимости, в которой идёт обращение к переменной
        <span>food</span>. Эта переменная объявлена внутри
        <span>collectContainer</span>, у которой своя область видимости.
      </p>
      <p>
        Функция <span>eatDinner</span> не находит внури себя создание переменной
        <span>food</span>, смотри в соседнюю область видимости (в область
        видимости <span>collectContainer</span>). Там она находит переменную
        <span>food</span>, узнаёт, что её значение равно строке
        <span>'макароны'</span>, и фиксирует это значение в памяти.
      </p>
      <p>
        Постойте! Мы же выводили в консоль переменную <span>schoolkid</span> и
        там не было никаких макарон!
      </p>
      <code>
        var collectContainer = function () { <br />
        var food = 'макароны'; <br />
        var eatDinner = function () { <br />
        console.log('Поел ' + food); <br />
        } <br />
        return eatDinner <br />
        }; <br />
        <br />
        var schoolkid = collectContainer(); <br />
        console.log(schoolkid); <br />
        // Выведет: function() {console.log('Поел ' + food); }
      </code>
      <p>
        Всё верно. Код самой функции не меняется, просто в памяти вместе с
        функцией хранится то значение переменной, которое было при объявлении
        этой функции. Поэтому <span>eatDinner</span> 'помнит' значение
        <span>food</span>. Это особенность функций, он помнят своё окружение в
        момень своего создания. В таком случае говорят о замыкании.
        <b>Замыкание</b> - функция, которая помнит о своём окружении. То есть
        это функция + все значения переменных <b>вне</b> локлаьной области
        видимости этой функции. Речь идёт только о переменных, которые функция
        использует в своём коде.
      </p>
      <p>
        В нашем примере функция <span>eatDinner</span> вместе с переменной
        <span>food</span> являеются замыканием.
      </p>
      <p>
        Именно благодаря замыканиям код из примера выше работает.
        <span>eatDinner</span> помнит о значении <span>food</span> при своём
        создании, поэтому использует это значение в момент вызова. Как если бы
        мама сказала нам купить картошки, когда мы будем идти мимо магазина. Мы
        запомнили про картошку и пошли по своим делам. Когда мы увидели магазин,
        мы вспомнили, что именно картошка была нужна, мы её купили и пошли
        домой.
      </p>
      <h3>Собираемся в школу</h3>
      <p>Всё работает. На функцию никак не влияют глобальные переменные.</p>
      <p>
        Наш пример рабочий, но он жёстко привязан к значению внутри функции
        <span>collectContainer</span>. Может школьник не хочет есть каждый раз
        только макароны? Нужно дать ему возможность выбора. Да и чаще всего мы
        передаём какие-то значения в функцию, а не жётко фиксируем их внутри
        локальной области видимости. Добавим функции
        <span>collectContainer</span> параметр.
      </p>
      <code>
        var collectContainer = function (food) { <br />
        return function () { <br />
        console.log('Поел ' + food); <br />
        }; <br />
        }; <br />
        <br />
        var schoolkid = collectContainer('макароны'); <br />
        schoolkid(); <br />
        // Выведет: Поел макароны <br />
      </code>
      <p>
        Тепеь значение <span>food</span> будет ипользовано из параметра, а не из
        локлаьной переменной функции <span>collectContainer</span>. Рабоатть всё
        будет точно так же. Функция, которую возвращает
        <span>collectContainer</span>, будет запоминать значение параметра и
        использоватьего при своём вызове.
      </p>
      <p>
        Внутреннюю функцию мы сделали анонимной, потому что имя
        <span>eatDinner</span> нигде не используется. Это никак не повлияет на
        работу функции.
      </p>
      <p>
        Представим, что школьников теперь двое. Каждый из них возьмёт из дома
        контейнер с едой.
      </p>
      <p>
        Убедимся, что переопределение глобальных переменных не повлияет на
        работу нашей функции <span>collectContainer</span>.
      </p>
      <p>
        Обратите внимание, что каждый раз, когда мы будем вызывать функцию
        <span>collectContainer</span> и записывать результат в переменную, в
        память будет создаваться новое замыкание, которое будет помнить о
        значении параметра <span>food</span> в момент своего создания.
      </p>
      <h3>Чиним галлерею</h3>
      <p>
        После знакомства с обастью видимости и замыканиями, вернёмся к нашей
        задаче. то же случилось у нас в коде? Почему программа не работает как
        надо?
      </p>
      <code>
        for (var i = 0; i &lt; thumbnails.length; i++) { <br />
        thumbnails[i].addEventListener("click", function () { <br />
        fullPhoto.src = photos[i]; <br />
        }); <br />
        }
      </code>
      <p>
        Обработчики, которые мы создали, ипользуют значение счётчика
        <span>i</span>. Сложность в том, что обработчики срабатывают не сразу, а
        в момент наступления события. К тому моменту, когда первое событие клика
        выполняется, цикл полностью отработал, значение счётчика стало
        максимальным - <span>5</span>, и функция-обработчик берёт именно это
        значение. Цикл не создаёт отдельную область видимости, это ведь не
        функция. Поэтому значение <span>i</span> находится в глобальной области
        и каждый обработчик обращается к этому значению <span>5</span>. А у нас
        нет миниатюры с таким индексом и элемента в массиве <span>photos</span>,
        поэтому никакая картинка и не подставляется.
      </p>
      <p>Как нам это исправить? Нам помогут замыкания!</p>
      <p>
        Мы создадим функцию, которая будет принимать в качестве параметров
        миниатюру и подходящий элемент из массива <span>photos</span>. А уже
        внутри этой функции будем добавлять обработчики. Тогда каждый обработчик
        будет брать значение из своего замыкания - из параметров функции, в
        которой находится обработчик.
      </p>
      <p>
        У каждого обработчика будет собственное замыкание, поэтому значения в
        обработчиках не будут повторяться, как это было раньше.
      </p>
      <p>
        Давайте постепенно улучшим нашу программу так, чтобы она работала
        корректно.
      </p>
      <h3>Дело раскрыто</h3>
      <p>Замыкания нам помогли, галлерея почти работает!</p>
      <p>
        На каждой итерации мы передаём разные значения в
        <span>addThumbnailClickHandler</span>. Кажды обаботчик получает своё
        замыкание, в котором находятся какие-о конкретные значения параметров
        <span>thumbnail</span>, <span>photo</span>. Именно эти значения
        использует каждый обработчик при происхождении события. И теперь
        значение индекса в уже отработавшем цикле никак не влияет на нашу
        программу.
      </p>
      <p>
        Осталось заменить выводы в консоль на замену <span>src</span> у большого
        изображения, и убедиться, что код работает правильно.
      </p>
    </main>
    <footer>
      <h3>Здесь могла быть ваша кувшинка</h3>
    </footer>
  </body>
</html>
