<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>JavaScript в браузере</title>
    <link rel="stylesheet" href="../../стили/Полигон.css" />
  </head>
  <body>
    <header>
      <img
        src="../../avatar/avatar1.jpg"
        width="90"
        height="90"
        alt="Лягушка"
      />
      <nav>
        <a href="../../Полигон.html">Назад</a>
        <a href="JavaScript в браузере/Каталог 1/Каталог 1.html">Каталог 1</a>
        <a href="JavaScript в браузере/Каталог 2/Каталог 2.html">Каталог 2</a>
      </nav>
    </header>
    <main>
      <h2>JavaScript в браузере</h2>
      <h3>Скрипт на старт!</h3>
      <p>
        Кекс взял несколько заказов от интернет-магазинов и собирается заглянуть
        к вам в ближайшее время, чтобы раздать задачи. Пока Босс в пути,
        разберёмся, как подключать скрипты на страницу.
      </p>
      <p>
        До этого мы писали программы, не связанные с интерфейсом сайта. В
        интернет-магазине такое не пройдёт, здесь надо манипулировать элементами
        на странице. Чтобы это сделать, надо грамотно подключить свой код.
      </p>
      <p>
        Скрипты подключаются к странице с помощью тега <span>script</span> двумя
        способами:
      </p>
      <p><b>Инлайновый код.</b> Код пишется внутри тега <span>script</span>.</p>
      <p>
        <b>Внешний файл с кодом.</b> Тегу <span>script</span> добавляется
        атрибут <span>src</span>, в котором указывается путь до файла со
        скриптом.
      </p>
      <p>
        Обратите внимание, что эти два способа не сочетаются друг с другом. Если
        у тега <span>script</span> указан атрибут <span>src</span>, инлайновый
        код игнорируется и не выполняется, поэтому он должен находиться в другом
        теге <span>script</span>.
      </p>
      <p>
        Скипты выполняются по мере подключения на страницу. Если за тегом
        <span>script</span> находится разметка, она не отрисуется пока не
        выполнится скрипт (в случае с инлайновым кодом) или пока он не скачается
        с внешнего ресурса и не будет выполнен (при подключении внешнего файла).
      </p>
      <p>
        Поэому мы будем подключать скрипты перед закрывающим тегом
        <span>body</span> - так мы будем уверены, что вся разметка отобразилась
        на странице и с ней можно работать.
      </p>
      <h3>Метод querySelector, поиск элемента</h3>
      <p>
        Кекс добрался до офиса и первым делом заглянул к вам. Босс хочт внести
        несколько правок на страницу: указать, что отвёртка "Буравочка" - товар
        дня, и отметить молоток "Мьёльник" недоступным для заказа.
      </p>
      <p>
        Казалось бы, зачем здесь JavaScript, можно ведь поменять разметку или
        стили. Но ни к тому, ни к другому дотупа у нас нет. Так решил владелец
        магазина. Мы можем менять страницу только с помощью скриптов.
      </p>
      <p>
        JavaScript особым образом воспринимает разметку: элементы здесь не
        строки, которые мы пишем в HTML-файлах, а объекты. При этом каждый
        объект связан с другими такими же объектами и знает о своём родителе,
        сосдних объектах-элементах, вложенных объектах. В итоге получается
        древовидная структура, которая называется DOM (Document Object Model или
        объектная модель документа).
      </p>
      <p>
        В каждом DOM-дереве есть корневой объект, из которого "растут" другие
        объекты. Он называется <span>document</span>. Это глобальный объект
        доступен во всех программах, которые работают в браузере. Проще говоря,
        <span>document</span> - страница, которая содержит все элементы разметки
        (объекты).
      </p>
      <p>
        С помощью <span>document</span> разработчики могут найти любой объект на
        странице, а потом изменить его. Для этого у объекта
        <span>document</span> ест специалные методы поиска.
      </p>
      <p>
        Самый гибкий из них - <span>querySelector</span>. Этот метод принимает
        CSS-селектор и возвращает подходящий элемент. Он понимает любые
        CSS-селекторы и вызывается так:
      </p>
      <code>
        // Поиск элемнета по тегу <br />
        let list = document.querySelector('ul'); <br />
        <br />
        // Поиск последнего элемента из списка <br />
        let lastProduct = document.querySelector('li:last-child');<br />
        <br />
        //Поиск элемента по классу<br />
        let price = document.querySelector('.price');
      </code>
      <p>
        Посомтрим на страницу магазина. Перед нами список, где каждый товар -
        <span>li</span> с классом <span>product</span>. Отвёртка "Буравочка",
        которая должа стать товаром дня, вторая в разметке. Значит, нам нужно
        найти второй элемент в списе. Для этого можно использовать селектор
        <span>.product:nth-child(2)</span>. Молоток "Мьёльнир", которого нет в
        наличии, расположен последним. Его можно нати через
        <span>.product:last-child</span>.
      </p>
      <p>
        Найдём второй и последний DOM-элемент из списка товаров, выведем их в
        консоль и убедимся, что поиск сработал верно.
      </p>
      <h3>Мето classList.add, добавление класса</h3>
      <p>
        Мы нашли элементы, а что дальше? Теперь их нужно как-то визуально
        изменить. К счастью, мы обнаружили, что версальщик заботливо подготовил
        стили для разных состояний товаров. В стилях можно найт разные
        CSS-правила:
      </p>
      <ul>
        <li>
          класс <span>product--available</span> нужен для товаров в наличии;
        </li>
        <li>
          а <span>product--unavailable</span> добавляется кгда товара в наличии
          нет;
        </li>
        <li>
          а за спецпредлжение отвечает класс <span>product--special</span>
        </li>
      </ul>
      <p>
        Так как DOM-элементы - объекты, все они меют набор свойств и методов.
        Среди свойств DOM-элементов - объект <span>classList</span>. Он содержит
        методы для управления классами DOM-элемента, в том числе и метод
        <span>add()</span>. С его помощью мы можем указать, какой класс хотим
        добавить элементу.
      </p>
      <p>
        Синтаксис простой. Сначала мы указываем DOM-элемент, которому хотим
        добавить класс, затем обращаемся к свойству <span>classList</span> через
        точку и вызываем метод <span>add()</span>, передав ему строку с
        необходимым классом. Обратите внимание, что точку перед названием класса
        ставить не нужно. В итоге добавление класса выглядит так:
      </p>
      <code>
        // Когда ищем элемент по классу, используем точку<br />
        let product = document.querySelector('.product');<br />
        <br />
        // Но когда добавляем класс, точки нет! <br />
        product.classList.add('product--sale');
      </code>
      <p>
        Результат работы <span>classList.add()</span> такой же, как при ручном
        добавлении класса в разметку
      </p>
      <p>
        Добавим найденным элементам класс товара, которого нет в наличии, и
        класс спецпредложение
      </p>
      <h3>Метод querySelectorAll, поиск нескольких элементов</h3>
      <p>
        Теперь у Кекса ест выгрузка с товарами из 1-Кекс и н просит обновлять
        все товары на странице. Придётся писать более сложную программу:
      </p>
      <p>
        <i
          >Есть интернет-магазин с готовой вёрсткой. Нужно показывать в
          интерфейсе актуальную информацию о товарах: спецпредложения и наличие
          на складе.</i
        >
      </p>
      <p>
        Данные приходят в виде массива объектов <span>catalogData</span>. Каждый
        объект соответствует одному товару и содержит свойства
        <span>isAvailable</span> (в наличи товар или нет) и
        <span>isSpecial</span> (является ли товар спецпредлжением или нет).
      </p>
      <p>Для каждого состояния товара есть соответствующий класс:</p>
      <ul>
        <li><span>product--available</span> для товара в наличии;</li>
        <li>
          <span>product--unavailable</span> соответствует товару, которого в
          наличии нет;
        </li>
        <li><span>product--special</span> для спецпредложения</li>
      </ul>
      <p>
        Каждый элемент массива с данными соответствует какому-то товару на
        странице. Мы уже умеем искать DOM-элементы и могли бы находить товары по
        одному с помощью <span>querySelector</span>. Например, используя цикл:
      </p>
      <code>
        for (...) { <br />
        let product = querySelector('.product:nth-child(' + i + ')'); <br />
        }
      </code>
      <p>
        Метод <span>querySelector</span> устроен так, что всегда возвращает
        только первый найденный элемент. Поэтому на каждой итерации приходилось
        бы запускать поиско очередного элемента по DOM-дереву. Такой поиск -
        довольно дорогая операция.
      </p>
      <p>
        Намного оптимальней получить список всех элементов <i>до цикла</i>, а
        <i>внутри цикла</i> этот списое перебирать. В этом нам поможет метод
        <span>querySelectorAll</span>, который возвращает не первый найденный
        элемент, а список (коллекцию) всех элементов, подходящих по селектору.
      </p>
      <p>
        Создадим функцию <span>updateCards</span>, в котором и будем вести
        работу над задачей. Найдём все товары на странице и убедимся, что поиск
        работает верно.
      </p>
      <h3>Перебор коллекции элементов</h3>
      <p>
        Мы нашли все товары на странице. Теперь нужно обращаться по очереди к
        каждому найденному DOM-элементу из коллекции и добавлять ему подходящие
        классы. Как это сделать?
      </p>
      <p>
        Обратите внимание, что DOM-коллекция, полученная через
        <span>querySelectorAll</span> похожа на массив. Это действительно так,
        она <b>похожа</b>, но им не является. Поэтому ещё одно название таких
        коллекций - псевдомассив. Подробно о различиях коллекций и массивов мы
        поговорим позже, а пока будет перебирать нашу DOM-коллекцию. Это можно
        сделать с помощью знакомого нам цикла <span>for</span>.
      </p>
      <p>
        Пройдёмся по наденным товарам и временно добавим каждому DO-элементу
        класс доступности <span>product--available</span>. Так мы убедимся, что
        цикл действительно работает.
      </p>
      <h3>Проверяем свойство isAvailable</h3>
      <p>
        Цикл работает и корректно перебирает коллекцию DOM-элементов. Займёмя
        реализацией программы.
      </p>
      <p>
        Будем считать, что массив с данными о товарах и псевдомассив с
        DOM-элементами всегда имеют одинаковую длину, это позволит перебирать
        две структуры в одном цикле. Заведём переменную <span>product</span>,
        которая будет соответствовать текущему товару. Тогда текущий DOM-элемент
        (мы уже сохраняем его в переменную spanelement) и текущий товар будут
        совпадать друг с другом.
      </p>
      <p>
        Чтобы отобразить статус наличия товара, над добавлять DOM-элементу
        разные классы. Сделаем это в несколько шагов:
      </p>
      <ul>
        <li>
          Создадим переменную для хранния класса, связанного с наличией. По
          умолчанию считаем, что товар в наличии, поэтому исходное значение у
          переменной будет <span>product--available</span>.
        </li>
        <li>
          Добавим проверку свойства <span>isAvailable</span> у товара. Если оно
          равно <span>false</span> (товар не в наличии) изменим значение
          переменной на <span>product--unavailable</span>.
        </li>
        <li>
          С помощью <span>classList.add()</span> добавим DOM-элементу класс,
          хранящийся в переменной.
        </li>
      </ul>
      <p>
        Мы знаем, что булевы значения сами могут выступать в качестве условий.
        Поэтому наша проверка могла бы выглядеть примерно так:
      </p>
      <code>
        let value = true; <br />
        <br />
        if(value) { <br />
        // Код выполнится <br />
        }
      </code>
      <p>
        Только в нашем случае проверка должна сработать, если значение свойства
        <span>isAvailable</span> равно <span>false</span>. Поэтому нужна
        проверка с отрицанием:
      </p>
      <code>
        let value = false; <br />
        <br />
        if(!value) { <br />
        // Код выполнится <br />
        }
      </code>
      <h3>Проверяем свойство isSpecial</h3>
      <p>Осталось найти товар дня и добавить ему соответствующий класс.</p>
      <p>
        Алгоритм простой: проверяем значение свойства
        <span>isSpecial</span> текущего товара, если оно равно
        <span>true</span>, добавляем DOM-элементу класс
        <span>product--special</span>.
      </p>
      <p>
        И не забудем убрать из кода все выводы в консоль - в рабочей программе
        их быть не должно.
      </p>
      <p>Задание Кекса выполнено!</p>
      <h3>Свойство children, дочерние элементы</h3>
      <p>
        Ккс остался доволен вашей работой и подкинул новую задачу: нужно
        добавить карточки товаров на страницу магазина селфи-палок.
      </p>
      <p>
        Раньше мы получали данные о состояниях товара, в этот раз из выгрузки
        программы 1-Кекс будет приходить полная информация. Данные будут
        содержать название продукта, его цену, изображение, доступность для
        заказа и прочую информацию. Поэтому для решения задачи нам не нужен
        верстальщик, ведь все данные будут у нас. Мы сами добавим элементы в
        разметку с помощью скриптов.
      </p>
      <p>
        Сначала мы создадим одну карточку с нуля. Верстальщик показал нам, как
        должны быть свёрстаны карточки товаров, поэтмоу сейчас в разметке они же
        есть. Мы будет ориентироваться на эти карточки, создавая свою, а затем
        удалим и добавим все карточки самостоятельно.
      </p>
      <p>
        Как обычно, будем решать задачу постепенно: создадим элемент, наполним
        его необходимым контеном и добавим подходящие классы.
      </p>
      <p>
        Чтобы карточка оказалась в разметке, нужно найти родительский элемент, в
        который мы будем эту карточку добавлять. В нашем случае это список
        <span>products</span>. Именно в нём хранятся карточки товаров, и три из
        них уже есть в разметке. Мы можем найти их не только через
        <span>querySelectorAll</span>, но и с помощью свойства
        <span>children</span> списка <span>products</span>.
      </p>
      <p>
        Обращение к свойству выглядит так: <span>Don-элемент.children</span>.
        Это свойство возвращает коллекцию дочерних, то есть вложенных,
        DOM-элементов. В случае с нашим списком коллекция должна состоять из
        трёх элементов - по одному на каждый элемент списка <span>li</span>.
      </p>
      <p>
        Перед добавлением новой карточки найдём список <span>products</span> и
        выведем в консоль список его дочерних элементов с помощью
        <span>children</span>. Убедимся, что длина коллекции равна количству
        вложенных элементов, а уже затем начнём добавлять новую карточку.
      </p>
      <h3>Метод createElement, создание элемента</h3>
      <p>
        Приступим к добавлению карточки товара. Если бы мы добавляли новый
        элемент через разметку, то мы бы добавили ещё один <span>li</span> с
        классом <span>product</span> в списке товаров. В JavaScript для
        выполнения этой же задачи нужно сделать несколько шагов. Пойдём по
        порядку.
      </p>
      <h4>Создание DOM-элемента</h4>
      <p>
        Для начала нужно создать новый элемент списка, <span>li</span>.
        Создавать элементы можно разными способами, мы будем использовать метод
        <span>createElement()</span> объекта <span>document</span>. Метод
        принимает на вход строку с именем тега и возвращает созданный
        DOM-элемент. Этот элеммент можно записать в переменную для дальнейших
        манипуляций:
      </p>
      <code> let card = document.createElement('li'); </code>
      <p>
        Обратите внимание, что <span>createElement</span> - метод именно объекта
        <span>document</span>. То есть с его помощью мы создаём какой-то элемент
        для этого документа, пока не указывая, где он будет находиться в DOM.
      </p>
      <h4>Добавление класса</h4>
      <p>
        С этм шагом мы уже знакомы. Работаем с <span>classList</span> созданного
        элемента:
      </p>
      <code>
        let card = document.createElement('li'); <br />
        card.classList.add('card');
      </code>
      <h4>Добавление в DOM-дерево</h4>
      <p>
        Вновь созданный элемент по умолчанию не находится в DOM-дереве и не
        отображается на странице. Мы просто храним его где-то в переменной.
        Чтобы новый элемент появился на странице, его нужно добавить в DOM. Для
        этого найдём в текущем DOM-дереве элелмент (родитель) и вставим в него
        наш элемент.
      </p>
      <p>
        Мы будем использовать метод <span>appendChild()</span> родителя. Этот
        метод принимает на вход элемент и вставляет его в
        <b>конец</b> родительского элемента. То есть, если в списке уже есть три
        элемента, как в нашем случае, добавленный с помощью
        <span>appendChild</span> элемент станет четвёртым в списке.
      </p>
      <code>
        let list = document.querySelector('.cards'); <br />
        let card = document.createElement('li'); <br />
        card.classList.add('card'); <br />
        <br />
        // После вызова этого метода новый элемент отрисуется на странице <br />
        list.appendChild(card)
      </code>
      <p>
        Последовательность добавления элемента в DOM может быть другой: можно
        создать элемент с помощью <span>createElement</span> и сразу вставить
        его в родительский элемемнт, а уже затем добавлять классы. Но это не
        лучший путь - каждое изменение в DOM вызывает перерисовку страницы, а
        это дорогая операция, она занимает много времени.
      </p>
      <p>
        Теперь создадим карточку товара, добавим ей подходящий класс и вставим в
        конец списка товаров. Затем снова выведем в консоль
        <span>children</span> списка, чтобы убедиться, что наша карточка попала
        в коллекцию дочерних элементов. Это стандартное поведение коллекции -
        она меняется на лету вместе с изменением DOM.
      </p>
      <h3>Свойство textContent, текстовое содержимое</h3>
      <p>
        Карточка уже в разметке, но пока она пустая. Начнём наполнять её
        контентом. В первую очередь добавим название товара и его цену.
      </p>
      <p>
        Алгоритм почти такой же, как и при добавлении самой каточки: создание
        элемента, добавление класса, вставка тектового содержимого (название
        товара, его цена), добавление элемента в конец карточки. Вс шаги нам
        знакомы, кробе добавления текста. Как это сделать?
      </p>
      <p>
        У каждого DOM-элемент есть свойство <span>textContent</span>. Оно
        содержит текстовое содержимое элемента. В <span>textContent</span> не
        попадает разметка, только текст.
      </p>
      <code>
        // HTML <br />
        &lt;p&gt; Я - &lt;em&gt;текстовый элемент&lt;/em&gt;.&lt;/p&gt; <br />
        <br />
        // jslet p = docuement.querySelector('p'); <br />
        console.log(p.textContent); <br />
        // Выведет: Я - текстовый элемент.
      </code>
      <p>
        Это свойство объекта, которое моно не только прочитать, но и записать
        или перезаписать. Поэтому, если мы хотим задать элементу текстовое
        содержимое, достаточно записать в свойство необходимое значение.
      </p>
      <code>
        p.textContent = 'Теперь у меня нвоое содержимое.'; <br />
        console.log(p.textContent); <br />
        // Выведет: Теперь у меня новое содержимое. <br />
        <br />
        // В HTML содержание тега изменится <br />
        &lt;p&gt;Теперь у меня новое содержимое.&lt;/p&gt; <br />
      </code>
      <p>
        Добавим в карточку название товара и его цену. Убедимся, что все новые
        элементы отображаются на странице.
      </p>
      <h3>Функция для создания элементов</h3>
      <p>
        Обратите внимание, по мере выполнения задачи, мы всё чаще повторяем одни
        и те же операции: создаём элементы с помощью
        <span>document.createElement()</span>, добавляем им классы через
        <span>элемент.classList.add()</span>, а в некоторых случаях и текстовое
        содержимое с помощью <span>элемент.textContent</span>. Пора выести
        повторяющийся код в функию, чтобы не писать каждый раз много похожих
        строчек кода.
      </p>
      <p>
        Объявим функцию, которая будет принимать на вход три строки: имя
        тега(<span>tagName</span>), имя класса (<span>className</span>) и
        текстовое содержимое (<span>text</span>) элемента. Внутри неё будем
        создавать элемент с классом и текстом, а затем возвращать его наружу.
      </p>
      <p>
        Не у всех элементов есть тексстовое содержимое, поэтому дадим
        возможность вызывать функцию не с тремя, а с двумя параметрами.
        JavaScript сам по себе это позволяет. Но нам нужно предусмотреть
        проверку на присутствие третьего параметра. Будем добавлять в элемент
        текст с помощью <span>textContent</span> толко если параметр
        <span>text</span> существует.
      </p>
      <p>
        Как првоерить наличие параметра? Если параметр не был переданв функцию,
        его значение внутри функции будет равно <span>undefined</span>, то есть
        не определено. Значение <span>undefined</span> приводится к логическому
        значению <span>false</span>, поэтмоу жостаточно такой простейшей
        проверки:
      </p>
      <code>
        let createCard = function (required, optional) { <br />
        if (optional) { <br />
        // действия с optional <br />
        } <br />
        } <br />
        <br />
        // Функция отработает, но действия с optional выполняться не будет
        <br />
        createCard('Обязательный аргумент'); <br />
        <br />
        // Функция отработает и действия с optional выполняться <br />
        createCard('Обязательный аргумент', 'Необязательный аргумент')
      </code>
      <p>
        А что будет если аргумент передан? Во-первых, он будет равен
        <span>underfined</span>. Во-вторых, внутри оператора "круглые скобки"
        программа получит значение этого параметра и приведёт его к логическому
        типу. Т.к. строки могут сами выступать в роли условий, то пустая строка
        приводится в <span>false</span>, а непустая к <span>true</span>. То
        есть, элементу добавится текстовое содержимое только тогда, когда мы
        передадим последним аргументом непустую строку. То, что надо.
      </p>
      <h3>Оптимизируем код</h3>
      <p>
        Теперь, когда у нас есть пециальна функция, мы можем заменить для
        каждого элемента строки с созданием, добавлением класса и текстового
        содержимого на одну строку с вызовом <span>makeElement</span>. Так мы
        сделаем код более читаемым и удобным.
      </p>
      <p>
        Обратите внимание, что создавая карточку товара с помощью
        <span>makeElement</span>, мы передаём в функцию только тег
        <span>li</span> и класс <span>product</span>. Текстового содержимого у
        самой карточки нет, оно есть только у её дочерних элементов (названия
        продукта и цены). Вот и случай, для которого мы писали проверку в
        функции!
      </p>
      <h3>Свойство src, адрес изображения</h3>
      <p>
        Нашей карточкекее не хватает изображения товара. Создадим его с помощью
        <span>makeElement</span>, передав функции имя тега <span>'img'</span> и
        класс <span>'product__image'</span>. Третий параметр мы не передаём,
        потому что у изображения нет текстового содержимого.
      </p>
      <p>
        Чтобы картинка отобразилась на странице, нужно задать ей адрес файла с
        изображением, то есть значение атрибута <span>src</span>. Значением
        этого <i>атрибута</i> можно управлять с помощью одноимённого
        <i>свойства</i> DOM-элемента:
      </p>
      <code>
        let picture = document.createElement('img'); <br />
        picture.src = 'image/picture.jpg'
      </code>
      <p>
        Таким же образом добавим изображению альтернативный текст, то есть
        описание фотографии. Ели фотография не загрузится, на странице
        отобразится этот текст, чтобы пользователь понимал, что за блок
        находится перед ним. Кроме того, такой текст распознают программы,
        читающий вслух содержимое экрана (скринридеры), поэтому, добавляя такое
        описание, мы простым способом делаем элеммнт интерфейса доступным.
        Добавляем альтернативный текст через ссвойство <span>alt</span>. Как
        видите, названия <i>атрибутов тегов</i> и свойств DOM-элементов часто
        (но не всегда) совпадают.
      </p>
      <code> picture.alt = 'Непотопляемая селфи-палка'; </code>
      <p>
        После создания изображения и "настройки" его свойств, добавим
        изображение в карточку. Обратите внимание, фотографию мы должны добавить
        перед ценой товара, потому что в разметке порядок тегов именно такой.
        Поэтому и код создания картинки нужно добавить перед кодом создания
        цены.
      </p>
      <h3>Функция для создания карточки товара</h3>
      <p>
        Одну карточку мы добавили, но теперь Кекс просит добавить разом много
        карточек, основываясьна полученных данных. Данных пока нет, система
        барахлит, но мы не будем сидеть без делать и подготовим всё для решения
        задачи.
      </p>
      <p>
        Алгоритм добавления одной карточки не сильно отличается от добавления
        десяти или двадцати карточек. Мы точно так же создадим элементы,
        добавляем им классы, атрибуты и текстовое содержимое, только много раз.
        Конечно, без функции тут не обойтись.
      </p>
      <p>
        Объявим функцию <span>createCard</span>, которая будет отвечать за
        создание карточки товара. Внутри функции будет создаваться элемент
        списка, а затем будет создаваться и "упаковываться" в него другие части
        карточки: заголовк, картинка товара и стоимость. Возвращать функция
        будет готовый DOM-элемент. Снаружи функции мы оставим поиск самого
        списка товара и вставку в него DOM-элементов, возвращённых из функции.
      </p>
      <p>
        Такое "разделение труда" сдеелает наш код более универсальным. Функция
        <span>createCard</span> "не знает" ничего о том, куда именно вставлять
        DOM-элемент товара, поэтому её можно повторно использовать где угодно
        без каких-лмбо правок. Например, можно вставлять созданные в функции
        карточки товаров в список спецпредложений или в совершенно другой список
        новинок.
      </p>
      <p>
        Мы постепенно переходим от кустарного производства к конвейерному. Так и
        должно быть - готовая программа, которая стабильно и корректно работает
        с любым количеством элементов.
      </p>
      <h3>Проверяем работту функции для создания карточки</h3>
      <p>
        Разметка первых трёх товаров была нужна тлько в качестве подсказки. Мы
        подглядывали в неё, когда собирали свою карточку с помощью JavaScript.
      </p>
      <p>
        Сейчас, когда функция для создания карточки товара написана, пришло
        время избавиться от исходной разметки. В HTML-коде должен остаться
        пустой тег <span>ul</span>.
      </p>
      <p>
        Смело удаляйте все элементы списка из разметки, потом вызовите функцию
        <span>createCard</span> и добавьте результат работы этой функции в DOM.
        Так мы проверим, что функция работает корректно.
      </p>
      <h3>Живые данные</h3>
      <p>
        Наконец-то Кекс прислал пример выгрузки с данными для одного товара.
        Негусто, но этого достаточно, чтобы дорабоатть функцию
        <span>createCard</span>. Ведь сейчас все данные в ней статичные, то есть
        одинаковые, и сколько бы раз мы её не вызывали, карточки будут похожи
        друг на друга как близнецы.
      </p>
      <p>
        Информация о товаре представляет собой объект, каждое свойство которого
        описывает характеристику товара. Вначале поработаем с этими свойствами:
      </p>
      <ul>
        <li><span>imgUrl</span> - адрес изображения;</li>
        <li><span>text</span> - название товара;</li>
        <li><span>price</span> - цена</li>
      </ul>
      <p>
        Чтобы функция возвращала разные данные на выходе, нужно, чобы она
        получала разные данные на входе. Поэтому сначала добавим в функцию
        <span>createCard</span> параметр <span>product</span> и будем передавать
        в неё при вызове полученный объект с данными.
      </p>
      <p>
        Затем внутри функции нужно заменить фиксированные значения на свойства
        входного параметра. Например:
      </p>
      <code>
        // Было: let title = createElement("h2", "product_title",
        "Профессиональная селфи-палка"); picture.alt = 'Профессиональная
        селфи-палка' // Стало: let title = createElement("h2", "product_title",
        product.text); picture.alt = product.text
      </code>
      <h3>Проверяем дступность товара</h3>
      <p>
        Три свойства из выгрузки мы уже обрабатывам. На очереди четвёртое:
        <span>isAvailable</span>. Это свойство хранит булево значение, которое
        описывает наличие товара. Если товар есть, то свойство содержит
        <span>true</span>, иначе <span>false</span>.
      </p>
      <p>
        В зависимости от наличия или отсутствия товара карточки должна иметь
        один из двух дополнительных классов: <span>product--available</span> или
        <span>product--unavailable</span>.
      </p>
      <p>
        Эту задачу мы уже решали, поэтому нужно повторить её по аналогии с
        первой программой. Вот краткий пересказ событий:
      </p>
      <ol>
        <li>
          заводим переменную для хранения имени класса и записываем в неё
          значение по умолчанию;
        </li>
        <li>делаем проверку на наличие товара;</li>
        <li>если проверка не проходит, значение в переменной меняем;</li>
        <li>после проверки добавляем карточке товара класс из переменной.</li>
      </ol>
      <p>
        После доработк функции нужно её протестировать. Для этого изменим в
        объекте с данными значение свойства <span>isAvailable</span> на
        <span>false</span>. Если всё сделано правильно, то внешний ид карточки
        изменится.
      </p>
      <h3>Спецпредложение</h3>
      <p>
        Осталось обработать последний последние два свойства из выгрузки:
        <span>isSpecial</span> и <span>specialPrice</span>. Свойство
        <span>isSpecial</span> содержит <span>true</span>, если на товаре
        действует спецпредложение. У товара-спецпредложения появляется новая
        цена, которая хранится в <span>specialPrice</span>.
      </p>
      <p>
        Похожу задачу мы тоже решали: у карточки спецпредложений должен
        появляться дополнительный класс <span>product--special</span>. Но сейчас
        нужно ещё и cпециальную цену показывать. Она должна находиться в абзаце
        с классом <span>product_special-price</span>. Этот абзац должен быть
        последним дочерним элементом в карточке.
      </p>
      <p>Порядок действий такой:</p>
      <ol>
        <li>проверяем, является ли товар спецпредложением;</li>
        <li>если проверка проходит, добавляем карточке товара класс,</li>
        <li>
          а также добавляем внутрь карточки ещё один абзац с соответствующим
          классом и теcктом из свойства <span>specialPrice</span>.
        </li>
      </ol>
      <p>
        После доработки снова тестируем функцию. Измените в объекте с данными
        значения свойств <span>isSpecial</span> на <span>true</span> и
        <span>specialPrice</span> на <span>300</span> (значение
        <span>null</span> обозначает "ничего" или, ближе к нашим реалиям,
        "спеццены нет"). Если всё сделано правильно, то внешний вид карточки
        изменится.
      </p>
      <h3>Используем массив объектов</h3>
      <p>
        Пока мы писали код, пришла полная выгрузка из 1-Кекс. Данные храняться в
        массиве объектов <span>cardsData</span>.
      </p>
      <p>
        Теперь товаров много и нам нужно вызвать <span>createCard</span> для
        каждого из них. Кажется, пришло время испльзовать цикл <span>for</span>.
      </p>
      <p>
        Напишем цикл, который будет перебирать массив данных. Внутри цикла будем
        передавать текущий элемемнт <span>массив[i]</span> в функции
        <span>createCard</span> и вставлять полученный результат в конец списка
        товаров. Так мы сделаем программу универсальной для любого количества
        карточек.
      </p>
      <p>Примерно так может выглядеть цикл:</p>
      <code>
        let item; <br />
        <br />
        for (let i = 0; i &lt; array.lenght; i++) { <br />
        ite, = createdCard(array[i]); <br />
        list.appendChild(item); <br />
        }
      </code>
      <p>
        В этом коде мы сначала объявляем переменную, а затем внутри цикла
        переопределяем её значение на каждой итерации. При этом переменную мы
        используем только внутри цикла. До и после цикла она нам не нужна.
        поэтому объявлять её снаружи цикла бессмыслено. Учтём это и будем
        создавать переменную внутри цикла на каждой итераци. В неё будем
        записывать результат вызова <span>createCard(массив[i])</span>, а затем
        добавим содержимое этой переменной в конец каталога товаров. Цикл будет
        выглядеть так:
      </p>
      <code>
        for (let i = 0; i &lt;array.lenght; i++) { <br />
        let item = createdCard(array[i]);<br />
        list.appendChild(item);<br />
        }
      </code>
    </main>
    <footer>
      <h3>Здесь могла быть ваша кувшинка</h3>
    </footer>
  </body>
</html>
