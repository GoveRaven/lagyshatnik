<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>Манипуляция с DOM</title>
    <link rel="stylesheet" href="../../стили/Полигон.css" />
  </head>
  <body>
    <header>
      <img
        src="../../avatar/avatar1.jpg"
        width="90"
        height="90"
        alt="Лягушка"
      />
      <nav>
        <a href="../../Полигон.html">Назад</a>
        <a href="Манипуляции с DOM/Сайт 1/Сайт 1.html">Сайт 1</a>
        <a href="Манипуляции с DOM/Сайт 2/Клонирование и вставка элементов.html"
          >Сайт 2</a
        >
      </nav>
    </header>
    <main>
      <h2>Манипуляция с DOM</h2>
      <h3>Какие планы</h3>
      <p>
        Мы разобрались с событиями в JavaScript и отлично справились с попапом и
        галереей. Босс оценил наши успехи и приготовил новую задачу, посеьёзней.
      </p>
      <p>
        <i
          >У нас новый заказ! Надо запрограммировать приложение - список дел.</i
        >
      </p>
      <p><i>Вёрстка уже готова, всё остальное на тебе:</i></p>
      <ul>
        <li>
          <i
            >задача считается выполненой и исчезает, если юзер кликнул по
            чекбоксу;</i
          >
        </li>
        <li>
          <i
            >если все задачи выполнены, появляетс сообщение, что больше задач
            нет;</i
          >
        </li>
        <li>
          <i
            >если в пустой список добавляется новая задача, сообщение
            исчезает;</i
          >
        </li>
        <li>
          <i
            >чтобы добавить новую задачу, надо ввести описание в поле ввода и
            нажать "Добавить задачу", задача пояявится в конце списка.</i
          >
        </li>
      </ul>
      <p>
        Нам доверили сервис! А ведь не так давно мы писали свой первый
        <span>console.log()</span>!
      </p>
      <p>
        Отбросим сантименты, мы же профессионалы. Начнём выполнять ТЗ, пойдём по
        списку. Займёмся удалением выполненных задач. Чтобы что-то делать с
        задачами, надо их найти и записать в переменные. Это мы умеем. Сам
        список - элемент с классом <span>todo-list</span>, а каждый элемент
        списка имеет класс <span>todo-list-item</span>.
      </p>
      <p>
        Найдём список и каждую задачу в списке с помощью
        <span>querySelector</span> и <span>querySelectorAll</span> и убедимся,
        что всё сделано правилно.
      </p>
      <h3>Событие "change"</h3>
      <p>
        Мы нашли все элементы списка. Каждый элемент - отдельная задача. Она
        состоит из текста и поля с типом <span>checkbox</span>. Такой элемент
        работает, как переключатель или флаг: если поле пустое, задача ещё не
        выполнена и ждёт своей очереди. А если внутри стоит отметка, то задача
        сделана и её можно удалять.
      </p>
      <p>
        Чтобы что-то сделать с самими задачами, надо поймать ситуации, когда
        пользователь кликаек по чекбоксу и этот элемент становится выбранным.
        Тут нам пригодитс события.
      </p>
      <p>
        Мы могли бы добавлять события клика на всю задачу, на весь элемент
        <span>&lt;li&gt;</span>, но это решение не оптимальное. Пользователь
        может случайно кликнуть по задаче, не желая её закрывать.
      </p>
      <p>
        Можно ловить клик по чекбоксу, это вполне подходящий. Но есь и другое
        событие, которое тоже подходит - <span>change</span>. Оно срабатывает,
        когда состояние поля меняется. В случае с чекбоксами, оно срабатывает,
        когда меняется статус невыбранного поля на выбранное и наоборот.
      </p>
      <p>
        Пока мы не нашли чекбоксы внутри элементов списка. Поэтому сначала
        найдём чекбокс внутрик каждой задачи, навесим обработчик и выведем
        какое-нибудь сообщение в консоль. У нас много элементов, значит алгорит
        придётся повторять несколько раз. Поэтому будем использовать функцию. В
        этом задании мы подготовим эту функцию для работы, а в следующем вызове
        её и проверим действительно ли работает наш обработчик.
      </p>
      <h3>Как работает событие "change"</h3>
      <p>
        Мы добавили функцию, навесили обработчик, осталось проверить, как
        работает обработчик обытия <span>change</span>.
      </p>
      <p>
        Вызовем из цикла функцию <span>addCheckHandler</span> для каждого
        элемента коллекции <span>items</span>.
      </p>
      <p>
        Обратите внимание, что событие <span>change</span> срабатывает при
        изменении состояния чекбокса. Это значит, если поле будет выбранным и мы
        уберём с него отметку, событие тоже сработает.
      </p>
      <h3>Удаление элемента из списка</h3>
      <p>
        Событие срабатывает. Пора зменить вывод в консоль на удаление
        выполненной задачи.
      </p>
      <p>
        Удалять элементы со страницы можно разными способами, один из самых
        простых - вызов метода <span>remove</span> на элементе, который нужно
        удалить.
      </p>
      <code>element.remove();</code>
      <p>Метод из примера выше удалит <span>element</span> из DOM.</p>
      <p>
        Кстати, почему мы использовали именно функцию, а не добавили обработчик
        на элементо прямо внутри цикла? Всё дело в областях видимости. Мы уже
        говорили про замыкания когда делали галлерею в прошлой главе про
        события. Если бы мы навесили обработчик внутри цикла, наша программа
        работала бы некорректно, потому что удалялся бы только последний элемент
        коллекции.
      </p>
      <p>
        Воспользуемся методом <span>remove</span>, чтобы удалить выполненную
        задачу в нашем приложении.
      </p>
      <h3>Как проверить длину коллекции</h3>
      <p>Выполненные цели удаляются! Перейдём к следующему пункту ТЗ:</p>
      <ul>
        <li>
          если все задачи выполнены, появляется сообщение, что больше задач нет;
        </li>
      </ul>
      <p>
        Все задачи будут выполнены, когда из списка <span>list</span>будут
        удалены все элементы. Сейчас все задачи находятся в коллекции
        <span>items</span>, её длина равна количету элементов <span>li</span> в
        списке. Если задачи будут удалены, то и длина коллекции будет равна
        <span>0</span>. И тогда можно показать сообещние.
      </p>
      <p>
        Пока нам не нужно находить сообщение об отсутствии в разметке и пытаться
        его показать. Сначала убедимя, что длина массива действительно
        уменьшается. Для этого создадим функцию, внутри которой будем проверять
        длину. Будем вызывать эту функцию каждый раз после удаления задачи.
      </p>
      <h3>Откладка кода</h3>
      <p>
        Что-то пошло не так. Мы завершили все цели, но строка не вывелась в
        консоль. Значит, проверка <span>items.lenght === 0</span> ни разу не
        вернула <span>true</span>.
      </p>
      <p>
        Чтобы разобраться в проблеме, выведем <span>items</span> внутри функции
        <span>toogleEmptyListMessage</span> и проверим, как меняется длина
        коллекции при удалении каждой задачи. Возможно, мы что-то упустили из
        вида.
      </p>
      <p>
        Это стандартна пркатика - отлаживать код, если результат работы
        программы не такой, как ожидалось.
      </p>
      <h3>Статичные и живые коллекции</h3>
      <p>
        Мы нашли проблему - длина коллекции <span>items</span> не меняется при
        удалении задач из списка. Почему так происходит?
      </p>
      <p>
        <span>querySelectorAll</span> находит необходимые элементы один раз,
        фиксирует их и всё. Эта запсть остаётся статичной и изменения в DOM на
        неё никак не влияют. Можно скзаать, что
        <span>querySelectorAll</span> работает, как любая переменная, в которую
        мы записали какое-нибудь значение. Пока мы не переопределим переменную,
        в ней так и будет находиться то значение, которое мы в неё записали,
        независимо от того, что происходит в коде.
      </p>
      <p>Поэтому такая коллекция называется статичной.</p>
      <p>
        Кроме статичных сущетвуют живые коллекции элементом, их ещё называют
        динамическими. Динамическиме коллекции реагируют на изменения в DOM.
        Если один из элементом будет удалён из DOM, то он пропадёт из коллекции.
        Есть несколько способов с помощью которых можно получить живую
        коллекцию, один из них <span>children</span>. Он вызывается на
        родительском элемент и собирает все дочерние элементы в динамическую
        коллекцию. Синтаксис такой:
      </p>
      <code> parentElement.children; </code>
      <p>
        Проверим на практике, как работают живые коллекции. Заменим
        <span>querySelectorAll</span> на <span>children</span> в нашем коде и
        првоерим, как будет работать программа.
      </p>
      <h3>Показ сообщения на странице</h3>
      <p>
        С живой коллекцией программа стала работать, как надо. Теперь мы можем
        заменить вывод строки в консоль на показ сообщения на странице
        приложения.
      </p>
      <p>
        Для этого нам, как обычно, надо найти сообщение в DOM и записать его в
        переменную. А затем удалить в нужный момент класс <span>hidden</span> у
        сообещния, чтобы показать его на странице. Удалять классы мы уже умеем.
        Используем для этого <span>classList.remove()</span>.
      </p>
      <p>
        Напишем код и првоерим, что сообщение появляется при выполнении сех
        задач в списке.
      </p>
      <h3>Событие "submit"</h3>
      <p>
        Мы справились с показом сообщения. Теперь разберёмся с добавлением
        задачи:
      </p>
      <p>
        задача добавляется через форму, которая состоит из поля ввода и кнопки.
        Пользователь должен написать текст задачи, а затем кликнуть по кнопке и
        задача добавится в список. Но сама она не добавится, придётся ей помочь.
      </p>
      <p>
        Заглянем в разметку. Атрибут у кнопки внутри формы <span>submit</span>,
        значит, клик по ней вызовет отправку данных из формы на сервер.
      </p>
      <p>
        Для добавления задачи можно ловить клики по этой кнопке, но
        универсальней будет использовать специальное событие
        <span>submit</span>. Оно срабатывает всегда при отправке формы. Это
        событие универсально потому, что иногда форма может отправить не только
        кликом по кнопке, но и нажатием какой-то клавиши. Например, "Enter".
      </p>
      <p>
        Найдём форму в разметке, добавим ей обработчик события
        <span>submit</span> и убедимся, что событие срабатывает.
      </p>
      <h3>Отмена отправки формы</h3>
      <p>
        Событие сработало, сообщение вывелось, форма отправилась. Только нам не
        нужно отправлять данные с формы. Нам нужно отобразить данные из формы на
        той же страние.
      </p>
      <p>
        Мы уже обсждали действия по умолчанию в прошлых заданиях. Тогда мы
        работали с ссылками, теперь пришло время форм. Отправка формы - действия
        формы по умолччанию, которое нам нужно отменить. Для этого будем
        использовать <span>evt.preventDefault()</span>.
      </p>
      <p>
        Отменим действие по умолчанию, попробуем снова отправить форму и
        проверим, что отправка данных больше не происходит.
      </p>
      <h3>Как получить текст из поля ввода</h3>
      <p>
        Чтобы добавить задачу на страницу, нужно как-то получить её название.
        Оно написано в поле ввода и оттуда его можно прочитать. Для этого нужно
        обратиться к ссвойству инпута <span>value</span>. Оно хранит информацию,
        введённую в поле.
      </p>
      <code>input.value</code>
      <p>Мы можем сохранить эту строку, а затем добавить в разметку задачи.</p>
      <p>
        Чтобы прочитать <span>value</span> из поля ввода, это поле надо найти и
        записать в переменную. Мы так и сделаем. Затем найдём содержимое поля и
        выведем его на страницу.
      </p>
      <h3>Шаблоны и тег &lt;template&gt;</h3>
      <p>
        У нас есть данные, чтобы создать новую задачу. Мы знаем, в какой момент
        можно добавить задачу на страниу. Осталось разобраться, как именно будет
        реализовано добавление нового элемента.
      </p>
      <p>
        Мы уже создавали новые элементы через <span>createElement</span>, но
        этот способ долгий. Сначала надо создать элемент, задать ему класс,
        атрибуты, потом так же создать дочерние элемемнты, вложить их в родителя
        и потом отрисовать на страницу.
      </p>
      <p>
        Было бы удобнее,если бы вся необходимая разметка для будущих элементов
        уже где-то хранилась. Нам бы оставалось только подправить содержимое под
        каждый элемент. М это можно сделать с помощью тега
        <span>template</span>.
      </p>
      <p>
        Он хранит в себе шаблоны для будущих элементов. Тег
        <span>template</span> находится там же, где и вя разметка сайта, только
        его содержимое не отображается на странице. В нашей разметке тоже есть
        <span>template</span>. Он хранить шаблонную разметку новой задачи.
      </p>
      <p>
        Чтобы получить <span>template</span> в JavaScript, его можно найти по
        названию тега, например, через <span>querySelector('template')</span>. У
        это способа есть минус - шаблонов на странице может быть много. Обычно
        каждому тегу <span>template</span> дают уникальное название и
        записываются в атрибут <span>id</span> (идентификатор). Значения этого
        атрибута не могут повторяться на одной странице. По
        <span>id</span> можно найти необходимыйй шаблон.
      </p>
      <p>Шаблон в разметке:</p>
      <code>
        &lt;body&gt; <br />
        ...<br />
        &lt;template id='text-template'&gt;<br />
        &lt;p class='text'&gt;&lt;/p&gt;<br />
        &lt;/template&gt;<br />
        &lt;/body&gt;
      </code>
      <p>Поиск элемента в JavaScript</p>
      <code> document.querySelector('#text-template'); </code>
      <p>
        Решётка в параметре <span>querySelector</span> обозначает, что искать
        надо по <span>id</span>.
      </p>
      <p>
        У нашего шаблона идентификатора <span>task-template</span>. Найдём этот
        <span>template</span> и выведим содержимое тега на страницу.
      </p>
      <h3>Контент тега &lt;template&gt;, document-fragment</h3>
      <p>
        Если вы развернёте <span>taskTemplate</span> в консоли, вы увидите, что
        внутри него есть некий <span>document-fragment</span>, а уже внутри него
        тот самый шаблон, который нам нужен.
      </p>
      <p>
        Что это за <span>document-fragment</span> и как из него достать наш
        шаблон?
      </p>
      <p>
        <span>document-fragment</span> или просто фрагмент является хранилищем
        содержимого тега <span>template</span>. Именно благодаря ему разметка из
        <span>template</span> не отображается на странице. Вы можете в этом
        убедиться, если добавите самому тегу стили: например, явную ширину и
        высоту и яркий фоновый цвет. Тогда вы увидите элемент
        <span>template</span> на странице, но его содержимое нет.
      </p>
      <p>
        Если искать элементы через <span>querySelector</span> и другие методы
        поиска внутри <span>template</span>, то мы не получим нужные нам
        элементы. Они лежат в свойстве <span>content</span> этого тега. Это
        свойство и содержит <span>document-fragment</span>, внутри которого уже
        можно искать привычными методами.
      </p>
      <code>
        &lt;body&gt; <br />
        ...<br />
        &lt;template id='text-template'&gt;<br />
        &lt;p class='text'&gt;&lt;/p&gt;<br />
        &lt;/template&gt;<br />
        &lt;/body&gt;
      </code>
      <p>Если мы хотм найти элемент в шаблоне, надо искать так:</p>
      <code>
        let template = document.querySelector('#text-template'); <br />
        // Нашли template в документе<br />
        <br />
        let content = template.content;<br />
        // Получили содержимое, фрагмент<br />
        <br />
        let text = content.querySelector('.text');<br />
        // Нашли нужный шаблон
      </code>
      <p>
        Эту запись можно сократить. Например, записать в отдельную перемемнную
        контент, а в другую искомый шаблон.
      </p>
      <code>
        let textTemplate = document.querySelector('#text-template').content;<br />
        let text = textTemplate.querySelector('text');
      </code>
      <p>
        Такая запись удобней, потому что отдельно в коде элемент
        <span>template</span> обычно не используют. Вся работа ведётся с его
        контеном и шаблоном, который в этом контенте хранится.
      </p>
      <p>
        В шаблоне можно менять текст, классы, а затем добавлять элементы на
        страницу. Это мы сделаем в следущих шагах. А пока найдём
        <span>content</span> и внутри него элемент с классом <span>item</span>,
        который является шаблоном новой задачи.
      </p>
      <h3>Клонирование и вставка элементов. 1 часть</h3>
      <p>
        Мы сохранили шаблон для будущих задач. Осталось "приложить" этот шаблон
        к нашему коду и отрисовать по нему новую задачу. Чтобы это сделать,
        отвлечёмся от списка дел и разберёмя ещё один метод DOM API.
      </p>
      <p>
        Нельзя просто так взять один элемент и добавить его много раз на
        страницу. Вставка сработает только один раз.
      </p>
      <p>Давайте убедимся в этом на примере.</p>
      <p>
        Перед нами будет блок с карточками. Шаблон для карточки хранится в теге
        <span>template</span>.
      </p>
      <code>
        &lt;body&gt; <br />
        ...<br />
        &lt;template id='element-template'&gt;<br />
        &lt;div class='el'&gt; <br />
        &lt;span&gt;&lt;/span&gt;<br />
        &lt;/div&gt;<br />
        &lt;/template&gt;<br />
        &lt;/body&gt;
      </code>
      <p>
        Шаблон вставлен на страницу один раз. Попробуем вставить этот же шаблон
        на страницу повторно.
      </p>
      <p>
        Для вставки элементов на страницу мы будеи использовать метод
        <span>appendChild</span>. Он добавляет указанныые элементы
        <b>в конец</b> родительского блока.
      </p>
      <h3>Клонирование и вставка элементов. 2 часть</h3>
      <p>
        Мы вставили шаблон, после него другой элемент и нова попробовали втавить
        шаблон. В итоге шаблон оказался только один и в конце списка. Почему так
        произошло?
      </p>
      <p>
        Потому что элемнт только один, даже если это шаблон. Мы не можем
        вставить один элеммент несколько раз в разные места страницы. Мы же не
        ожем быть в нескольких местах одновременно? Вот и элементы DOM не могут.
      </p>
      <p>
        Поэтому существует клонирование DOM-элементов. Мы можем клонировать
        любые элементы, в том числе шаблоныы, и вставлять эти копии на страницу
        сколько угодно раз.
      </p>
      <p>
        Для начала разберёмся, как работает клонирование. Для этого нужно
        использовать метод <span>cloneNode</span>. Он возвращает склонированный
        элемент.
      </p>
      <p>
        Обратите вниание, у этого метода есть аргумент - булевое значение. Если
        передать значение <span>false</span>, то будет скопирован сам элемент со
        своими классами и атибутами, но без дочерних элемментов.
      </p>
      <code>
        element.cloneNode(false); // Вернёт склонированный элемент без
        вложенностей
      </code>
      <p>
        Попробуем клонировать элемент, передать в <span>cloneNode</span> агумент
        <span>false</span> и вставить такой элемент на страницу.
      </p>
      <h3>Клонирование и вставка элементов. 3 часть</h3>
      <p>
        Если при передаче <span>false</span> в <span>cloneNode</span> копируется
        элемент без сложенностей, то при передаче <span>true</span> всё
        наоборот. В таком случае клонируется сам элемент вместе со всеми
        вложенностями. Причём клонируются атрибуты, классы и текстовое
        содержимое всех вложенностей. Такое клонирвоание называется глубоким.
      </p>
      <p>
        Раньше метод <span>cloneNode</span> вёл так себя по умолчанию, даже без
        передачи <span>true</span>. В новом стандарте это изменилось и без
        аргумента метод должен делать неглубокое копирование, как если бы был
        передан <span>false</span>. Но стандарт фиксирует рекомендации, а
        браузеры решают следовать им или нет. Сейчас не все браузеры перешли на
        ноывй стандарт и для обратной совместимости сохраняют старое поведение,
        когда по умолчанию клонирование было глубоким.
      </p>
      <p>
        Поэтому лучше всегда передавать булево значение, чтобы избежать
        непредсказуемого поведения в программах.
      </p>
      <code>
        element.cloneNode(true); // Вернёт склонированный элемент со всеми
        вложенностями <br />
        element.cloneNode(); // 0_o
      </code>
      <p>
        Посмотрим как работает глубокое клонирвоание на практике. Скопируем
        шаблон, добавим в его дчерний элемент текстовое содержимое и добавим
        шаблон на страницу.
      </p>
      <h3>Клонирование и вставка элементов. 4 часть</h3>
      <p>
        Мы познакомились с клонированием элементов, но ещё не попробовали
        вставить несколько копий на страницу.
      </p>
      <p>
        Запустим цикл, в теле цикла будем клонировать шаблон, менять содержимое
        дочернего элемента и последоватльно вставлять копии на станицу.
      </p>
      <p>
        Это похоже на использование трафарета для рисования. Мы прикладывем
        трафарет и много раз рисуем по нему там, где нужно. При этом сам
        трафарет у нас один.
      </p>
      <h3>Как клонировать элементы</h3>
      <p>
        Мы разобрались с тем, как клонировать элементы. Вернёмся к нашей
        основной задаче. Мы продолжаем работать над списком дел, нам нужно
        добавлять новые задачи в список при клике по кнопке "Добавить задачу".
      </p>
      <p>
        Мы уже нашли шаблон задачи и записали его в переменную
        <span>newItemTemplate</span>. Попробуем склонировать этот шаблон и
        записать копию в новую переменную. Выведем копию в консоль, чтобы
        убедиться, что копированние сработало. Будем использовать глубокое
        копирование, чтобы сохранить все элементы в структуре задачи.
      </p>
      <h3>Добавление нового элемента в список</h3>
      <p>
        Шаблон мы склонировали. Осталось сделать так, чтобы название задачи
        подставлялось в разметку. После этого можно добавлять задачу на
        страницу.
      </p>
      <p>
        Внутри <span>task</span> мы найдём элемент, в котором указано название
        задачи. И заменим этому элементу знакомый нам
        <span>textContent</span> на название, введённое в поле ввода.
      </p>
      <p>
        Настроенный элемент <span>task</span> добавим на страницу, в конец
        списка <span>li</span>.
      </p>
      <h3>Удаление новой задачи</h3>
      <p>
        Задача добавляется! Но пока не удаляется. И сообщение не исчзает хоть
        его текст становится неактуальным при добавлении хотя бы одной овой
        задачи. Будем фиксить.
      </p>
      <p>
        Чтобы задача удалялась, надо повесить обработчик на чекбокс. При
        изменении статуса чекбокса будем удалять задачу из списка... Ничего не
        напомнает? Мы уже писали этот код, он есть в фукнции
        <span>addCheckHandler</span>. Мы передавали в эту функцию те элементы
        списка, которые уже были на странице. Теперь у нас новый элемнт, который
        до этого не существовал, и его тоже надо передать в эту функцию, чтобы
        добавить обрабтчик.
      </p>
      <p>
        М будем передавать <span>task</span> в функцию
        <span>addCheckHandler</span> до того, как будем добавлять этот элемент
        на страницу. Тогда в списке будет появляться элемент с обработчиком и
        всем необходимым функционалом. Мы как будто сначала настраиваем элемент,
        а уже затем добавляем его на страницу.
      </p>
      <p>
        Сначала добавим обработчик и убедимся, что новая задача удаляется. А
        затем разберёмся с исчезнованием сообщения.
      </p>
      <h3>Очистка поля ввода</h3>
      <p>Задача добавляется и удаляется, ура!</p>
      <p>
        Осталось пара метлочей. Нужно прятать сообщение, если задачи в списке
        появилсь. Для этого добавим ветку <span>else</span> в функцию
        <span>toogleEmptyListMessage</span>. В ней будем добавлять класс
        <span>hidden</span> абзацу с сообщением. Будем вызывать эту функцию
        сразу после того, как задача добавилась в список.
      </p>
      <p>
        Ещё будем удалять текст из поля ввода после того, как задача добавилась
        на страницу. Это маленький, но приятный элемент для пользоватеоей - не
        нужно каждый раз перед добавлением новой задачи удалять текст руками.
      </p>
    </main>
    <footer>
      <h3>Здесь могла быть ваша кувшинка</h3>
    </footer>
  </body>
</html>
