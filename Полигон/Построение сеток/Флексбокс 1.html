<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>Флексбоксы, 1 часть</title>
    <link rel="stylesheet" href="../../стили/Полигон.css" />
  </head>
  <body>
    <header>
      <img src="../../avatar/avatar1.jpg" width="90" height="90" alt="Лягушка" />
      <nav>
        <a href="../../Полигон.html">Назад</a>
      </nav>
    </header>
    <main>
      <h2>Флексбоксы, 1 часть</h2>
      <h3>
        <a href="Флексбоксы 1/Флексбокс.html"
          >Свойство display:flex, flex-элемент</a
        >
      </h3>
      <p>
        Флексбокс - это первый CSS-механизм, предназначенный для построения
        сеток и создания сложных раскладок блоков. <br />
        Другие механизмы, с помощью которых мы раньше строили сетки,
        задумывались совсем не для этого: плавающие блоки нужны для создания
        блоков, которые текст должен обтекать, а таблицы используются для
        разметки табличных данных. <br />
        Флексбокс задумывался для создания "гибких" раскладок и хранит много
        тонкостей и чудес, о которых мы поговорим. А пока начнём с простого. Как
        включить флексбокс? <br />
        Очень просто: нужно задать элементу свойство display:flex. После этого
        происходит два события:
      </p>
      <ol>
        <li>
          Элемент с display: flex; превращается во "флекс-контейнер" и внутри
          него начинает происходить вся магия гибкой раскладки
        </li>
        <li>
          Непосредственные потомки этого элемента превращаются во
          "флекс-элементы" и начинают играть по новым правилам
        </li>
      </ol>
      <p>
        Первое, что мы заметим после выполнения этого задания, это то, что блоки
        растянутся на всю высоту контейнера. Да, внутри флексбока можно делать
        элементы одинаковой высоты! <br />
      </p>
      <h3>
        <a href="Флексбоксы 1/flex-direction.html"
          >Свойство flex-direction, главная ось</a
        >
      </h3>
      <p>
        Вспомните, как ведёт себя обычный поток документа. Блоки и текст
        располагаются слева направао и сверху вниз. <br />
        В привычной блочной модели направления "лево", "право", "верх" и "низ"
        неизмены. Но внутри флекс-контейнера эти понятия могут изменяться,
        потому что там можно изменять обычное направление потока. <br />
        Вместо направлений "лево" и "право" во флексбоксе используется понятие
        "главная ось". Потом флекс-элементов "течёт" вдоль главной оси от её
        начала к её концу. <br />
        По умолчанию главная ось направлена слева направо, но её можно
        разворачивать во всех направлениях с помощью свойства flex-direction,
        которое задаётся для флекс-контейнера. Значение свойства:
      </p>
      <ul>
        <li>
          row - значение по умолчанию, главная ось направлена слева направо.
        </li>
        <li>column - главная ось направлена сверху вниз</li>
        <li>row-reverse - главная ось направлена справа налево</li>
        <li>column-reverse - главная ось направлена снизу вверх</li>
      </ul>
      <p>
        Флекс-элементы всегда располгаются вдоль главной оси, независимо от её
        направления.
      </p>
      <h3>Поперечная ось flexbox</h3>
      <p>
        Вместо направлений "верх" и "низ" во флексбоксе используется понятие
        "поперечная ось". Вдоль этой оси работают "вертикальные" выравнивания.
        <br />
        Поперечная ось всегда перпендикулярна главной оси и поворачивается
        вместе с ней:
      </p>
      <ul>
        <li>
          Если главная ось направлена горизонтально, то поперечная ось смотрит
          вниз
        </li>
        <li>
          Если главная ось направлена вертикально, то поперечная ось смотрит
          направо
        </li>
      </ul>
      <p>
        Это не совсем логичное поведение, к которому надо привыкнуть.
        Получается, что поперечная ось никогда не смотрит вверх или влево. А
        свойства для поворота поперечной оси нет.
      </p>
      <h3>
        <a href="Флексбоксы 1/justifu-content.html"
          >Свойство justifu-content, выравнивание вдоль главной оси</a
        >
      </h3>
      <p>
        Вместо "горизонтального" выравнивания во флексбоксе используется
        свойство для распределения элементов вдоль главной оси -
        justify-content. Это свойство задаётся для флекс-контейнера. <br />
        Его значением по умолчанию является flex-start. При этом значении
        элементы располгаются у начала главной оси. <br />
        Чтобы элементы располагались по центру главной оси, нужно задать для
        justify-content значения center.
      </p>
      <h3>
        <a href="Флексбоксы 1/flex-start, flex-end.html"
          >Свойство justify-content:flex-start/flex-end</a
        >
      </h3>
      <p>
        Чтобы флекс-элементы располагалис в начале главной оси, войству
        justifu-content нужно задвать значение flex-start. Оно же является и
        значением по умолчанию. <br />
        А значение flex-end расположит элементы в конце главной оси. <br />
        Обратите внимание, что justify-content: flex-end не меняет порядок
        элементов, как это происходит при изменении направлении оси
        flex-direction: row-reverse. Элементы просто прижимаются к концу главной
        оси.
      </p>
      <h3>
        <a href="Флексбоксы 1/space-between, space-around.html"
          >Свойство justify-content:space-between/space-around</a
        >
      </h3>
      <p>
        У флексбоксов есть значение justify-content, который равномерно
        распределяет флекс-элементы вдоль главной оси:
      </p>
      <ul>
        <li>
          spacce-between - расстояния между соседними элементами одинаковое,
          между элементами и краями флекс-контейнера отступов нет
        </li>
        <li>
          space-around - расстояния между соседними элементами одинаковые, между
          элементами и краями флекс-контейнера есть отступ, равный половине
          расстояния между соседними элементами
        </li>
      </ul>
      <p>
        Сейчас мы добавим третьего кота и поэкспериментируем с этими значениями
        justify-content <br />
        А пока небольшой итог. Свойство justify-content управляет распределением
        элементов вдоль главной оси и имеет пять значений:
      </p>
      <ul>
        <li>flex-start - значение по умолчанию</li>
        <li>flex-end</li>
        <li>center</li>
        <li>space-between</li>
        <li>space-around</li>
      </ul>
      <h3>
        <a href="Флексбоксы 1/align-item.html"
          >Свойство align-items, выравнивание вдоль поперечной оси</a
        >
      </h3>
      <p>
        Вместо "вертикального" выравнивания во флексбоксе используется свойство
        для выравнивания элементов вдоль поперечной оси - align-items. Это
        свойство задаётся для флекс-контейнера. <br />
        Его значением по умолчанию является stretch. Именно благодаря этому
        значению флекс-элементы и растягиваются на всю "высоту"
        флекс-контейнера. Если флекс-элементам задана высота, то растягиваться
        они не будут. <br />
        Чтобы элементы выровнялись по центру поперечной оси, нужно задать для
        align-items значение center. <br />
        Давайте выровняем бокы по центру вдоль поперечной оси и убедимся, что
        элементы действительно центрируются даже если у них разная высота.
      </p>
      <h3>
        <a href="Флексбоксы 1/align-item flex.html"
          >Свойство align-items:flex-start/flex-end</a
        >
      </h3>
      <p>
        Чтобы расположить флекс-элементы в начале или в конце поперечной оси,
        нужно использовать значения flex-start и flex-end для свойства
        align-items. <br />
        Эти значения аналогично значениям свойства justify-content, отличается
        только ось. <br />
        Проверим эти значения на примере.
      </p>
      <h3>
        <a href="Флексбоксы 1/align-item baseline.html"
          >Свойство align-items:baseline</a
        >
      </h3>
      <p>
        Ещё одно значение свойства align-items - это baseline. Если задать его
        контейнеру то флекс-элементы будут выравниваться по базовой линии текста
        в них. Эта воображаемая линия проходит по нижней части букв. <br />
        Если выровнять флекс-элементы по базовой линии, то они выстроятся так,
        чтобы ткест в них был как бы на "одной строке" <br />
        Чтобы лучше понять поведение baseline, сравним его с другим хначением -
        flex-start. <br />
        Мини-итог. Свойство align-items управляет выравниванем элементов вдоль
        поперечной оси и имеет пять значений:
      </p>
      <ul>
        <li>stretch - значение по умолчанию</li>
        <li>flex-start</li>
        <li>flex-end</li>
        <li>center</li>
        <li>baseline</li>
      </ul>
      <h3>
        <a href="Флексбоксы 1/align-self.html"
          >Свойство align-self, эгоистичное выравнивание</a
        >
      </h3>
      <p>
        Распределение элементов по главной оси задаётся для всего
        флекс-контейнера и на все флекс-элементы действует одинаково. Задать
        какому-то элементу отличное от других распределение по главной оси
        нельзя. И это вполне логично, ведь тогда элементы будут "сталкиваться"
        друг с другом. <br />
        С поперечной осью всё проще. Можно сказать, что у каждого элемента она
        своя, и можно задавать им разное поперечное выравнивание. Для этого
        используется свойство align-self, которое задаётся для саих
        флекс-элементов, а не для флекс-контейнера. <br />
        У свойства align-self те же самые значения, что и у align-items.
      </p>
      <h3>
        <a href="Флексбоксы 1/align-self baseline.html"
          >Свойство align-self:baseline</a
        >
      </h3>
      <p>
        Аналогично align-items для отдельного флекс-элемента можно задать и
        выравнивание по базовой линии с помощью align-self со значением
        baseline. <br />
        Давайте зададим выравнивание по базовой линии двум отдельным блокам.
      </p>
      <h3>
        <a href="Флексбоксы 1/flex-wrap.html"
          >Свойство flex-wrap, перенос flex-элементов</a
        >
      </h3>
      <p>
        Что будет, если флекс-элемент в контейнере станет больше, чем может
        уместиться в один ряд?
      </p>
      <ul>
        <li>Они будут сжиматься до минимально возможной ширины</li>
        <li>
          Даже если им задать ширину явно, механизм флексбокса может её
          уменьшить
        </li>
        <li>
          Если они перестанут помещаться в контейнер и после уменьшения, то они
          выйдут за его пределы, но продолжат располагаться в один ряд
        </li>
      </ul>
      <p>
        Это чем-то похоже на поведение ячеек в таблице. <br />
        Такое повежение можно изменить свойством флекс-контейнера flex-wrap. По
        умолчанию оно имеет значение nowrap, то есть перенос флекс-элементов на
        новую строку запрещён. <br />
        Значение wrap разрешает перенос флекс-элементов на новую строку, если
        они не помещаются в контейнер. <br />
        Давайте посмотрим на практике, как оно работает.
      </p>
      <h3>
        <a href="Флексбоксы 1/flex-wrap-reverse.html"
          >Свойство flex-wrap: wrap-reverse, обратный перенос</a
        >
      </h3>
      <p>
        Если перенос флекс-элементов разрешён, то ряды элементов располагаются
        вдоль поперечной оси. Первый ряд располагается в начале поперечной оси,
        а последний в конце. Но так работает только значение wrap. <br />
        Если flex-wrap задать значение wrap-reverse, то элементы будут
        переноситься, а ряды будут располагаться в обратном порядке: первый в
        конце поперечной оси, а последний в начале. <br />
        Давайте добавим в комнату ещё котиков и попроубем переносить их на новую
        строку в обратном поперечной оси направлению.
      </p>
      <h3>
        <a href="Флексбоксы 1/align-content.html"
          >Свойство align-content, выравнивание строк flex-контейнера</a
        >
      </h3>
      <p>
        Вспомните свойство justifu-content, которое управляет распределнием
        флекс-элементов вдоль главной оси. <br />
        Есть очень похожее свойство align-content, которое управляет
        выравниванием рядов флекс-элементов вдоль поперечной оси. У этих свойств
        почти одинаковые значения:
      </p>
      <ul>
        <li>flex-start</li>
        <li>flex-end</li>
        <li>center</li>
        <li>space-between</li>
        <li>space-around</li>
        <li>
          и stretch, которое есть у align-content, но нет у justify-content, и
          является значением по умолчанию.
        </li>
      </ul>
      <p>
        Свойство align-content "перекрывает" заданное значение align-items,
        которое управляет выравниванием флекс-элементов вдоль поперечной оси.
        Это происходит и в случае, когда есть только один ряд флекс-элементов, и
        когда рядов несколько
      </p>
      <h3>
        <a href="Флексбоксы 1/align-content stretch.html"
          >Свойство align-content:stretch и align-items</a
        >
      </h3>
      <p>
        В случае одновременного задания align-items и align-content свойство
        align-items не отключается полностью, а может влиять на отображение
        флекс-элементов в рядах. <br />
        Это происходит, когда мы используем для align-content значение по
        умолчанию - stretch. Оно растягивает ряды флекс-элементов, при этом
        оставшееся свободное место между ними делится поровну. <br />
        отображение строк при align-content: stretch зависит от значения
        align-items:
      </p>
      <ul>
        <li>
          Если у align-items заодно значение stretch, то элементы в строках
          растягиваются на всю высоту своей строки
        </li>
        <li>
          Если значение отлично от stretch, то элементы в строках ужимаются под
          своё содержимое и выравниваются в строках в зависимости от значения
          align-items.
        </li>
      </ul>
      <p>Давайте посмотрим на этот эффект вживую.</p>
      <h3>
        <a href="Флексбоксы 1/align-content не stretch.html"
          >Свойство align-content:не-stretch и align-items</a
        >
      </h3>
      <p>
        Значение align-items влияет на отображение рядов во флекс-контейнере,
        если у align-content задано значение stretch. В это мы убедились в
        прошлом задании. <br />
        Есть ли похожее влияние на остальные значения align-content? Нет. <br />
        Убедимся в этом на примере значения center, которое располагает ряды в
        середине поперечной оси так, что:
      </p>
      <ul>
        <li>
          Отступов между соседними рядами нет (но отступы самих элементов
          сохраняются)
        </li>
        <li>
          Расстояние между первым рядом и краем флекс-контейнера равно
          расстоянию между последним рядом и другим краем
        </li>
      </ul>
      <h3>
        <a href="Флексбоксы 1/align-content остальные значения.html"
          >Свойство align-content, остальные значения</a
        >
      </h3>
      <p>
        Остальные значения свойства align-content аналогичны значениям
        justify-content, отличается только ось:
      </p>
      <ul>
        <li>flex-start - располагает ряды в начале поперечной оси</li>
        <li>flex-end - располгает ряды в конце поперечной оси</li>
        <li>
          space-between - равномерно распределяет ряды вдоль поперечной оси,
          расстояния между соседними рядами одинаковое, отсупов у краёв нет.
        </li>
        <li>
          space-around - равномерно распределяет ряды вдоль поперечной оси,
          расстояния между соседними рядами одинаковые, отступы у краёв равны
          половине расстояния между соседними рядами
        </li>
      </ul>
      <p>
        На последок небольшое резюме. <br />
        Свойство align-content - "гибридное". Мы переводим его как
        "выравнивание", но оно больше похоже на "распределение",
        jutsify-content, от которого оно позаимствовало два значения
        space-between и space-around. <br />
        Близость с "распределением" подчёркивает и отстутствие значение baseline
        - всё-таки свойство работает с рядами, а не с отдельными элементами.
        <br />
        От "выравниваний" же, align-items и align-self, это свойство получило
        значение по умолчанию stretch и возможность "растягивать" ряды по
        высоте.
      </p>
      <h3>
        <a href="Флексбоксы 1/order.html"
          >Свойство order, порядковый номер flex-элемента</a
        >
      </h3>
      <p>
        И ещё одно свойство, которое мы рассмотрим в этой главе, - это order,
        порядковый номер флекс-элемента. <br />
        Порядковый номер задаётся целым числом, положительным или отрицательным.
        <br />
        Например:
      </p>
      <code>
        .flex-element { <br />
        order:-1 /* этот элемент станет отображаться первым в контейнере */
        <br />
        }
      </code>
      <p>
        По умолчанию порядковый номер флекс-контейнеров равен 0, а сортировка
        элементов производится по возрастанию номера. <br />
        Это очень полезное свойство, т.к. с его помощью можно менять порядок
        следования флекс-элементов в потоке, не меняя HTML-код. <br />
        Давайте попробуем ператосавать блоки с котами с помощью свойства order.
      </p>
      <h3>
        <a href="Флексбоксы 1/margin-auto.html"
          >Идеальное центрирование, margin:auto у flex-контейнера</a
        >
      </h3>
      <p>
        В следующих заданиях мы разберём примеры из жизни, в которых можно
        применять флексбокс. <br />
        Самый насущный вопрос, который можно легко и изящно решить с помощью
        флексбокса, - как отцентровать элемент по вертикали и горизонтали так,
        чтобы центровка сохранялась при изменении размеров элемента или
        контейнера. <br />
        Ответ прост: задать контейнеру раскладку флексбокса, а дочернему
        флекс-элементу margin:auto. <br />
        В этом случае флекс-элемент уменьшит свой размер под содержимое и
        отцентрируется по вертикали и горизонтали. <br />
        Стоит обратить внимание на интересный момент. Если центрируемых
        флекс-элементов чем-то похожее на justifu-content: space-around. <br />
        Давайте проверим этот момент на примере карточки товара, в которой
        картинка центрируется внутри блока.
      </p>
      <h3>
        <a href="Флексбоксы 1/flex-выравнивания.html"
          >Идеальное центрирование, flex-выравнивания</a
        >
      </h3>
      <p>
        А теперь давайте отцентрируем элементы с помощью свойств
        флекс-контейнера без margin:auto на дочерних элементах <br />
        Заметьте разницу между тем, как распределяются элементы при разных
        значениях свойства justify-content. <br />
        В этом задании вместе того, чтобы дочернему элементу задвать
        margin:auto, мы задали родительскому элементу свойства
        justify-content:space-around и align-items:center
      </p>
      <h3>
        <a href="Флексбоксы 1/Горизонтальное меню 1.html"
          >Адаптивное горизонтальное меню, чаcть 1</a
        >
      </h3>
      <p>
        Флекс полезен при создании блоков с дочерними элементами динамической
        длины. Хороший пример - меню. <br />
        Часто встречаются дизайны, в которых пункты равномерно распределены по
        блоку меню. Первый пункт примыкает к левой части блока меню, а последний
        к правой, причём с небольшим внутренними отступами. <br />
        Эту задачу можно попытаться решить, задав фиксированные отступы и ширину
        пунктам меню. Но такой способ не подойдёт, если количество пунктов меню
        или подписи внутри них будут изменяться. <br />
        И тут на помощь приходит флексбокс. Зададим меню раскладку флексбокса,
        пункты станут флекс-элементами. С помощью свойства распределения
        элементов justify-content добьёмся нужного результата.
      </p>
      <h3>
        <a href="Флексбоксы 1/Горизонтальное меню 2.html"
          >Адаптивное горизонтальное меню, часть 2</a
        >
      </h3>
      <p>
        Теперь можно запросто добавить в меню ещё один пунтк ии изменить ширину
        самого контейнера. <br />
        Отступы между пунктами меню будут "гибко" меняться, подстраиваясь под
        новые условия.
      </p>
      <h3>
        <a href="Флексбоксы 1/Горизонтальное меню 3.html"
          >Адаптивное горизонтальное меню, часть 3</a
        >
      </h3>
      <p>
        С помощью раскладки флексбокса можно также легко управлять порядком
        следования элементов, не изменяя при этом HTML-код. <br />
        В видео уроке в это меню ввставляли логотип и меняли его местоположение,
        но я поменяю местами подменю.
      </p>
      <h3>
        <a href="Флексбоксы 1/Вертикальный ряд 1.html"
          >Вертикальный ряд иконок, часть 1</a
        >
      </h3>
      <p>
        Давайте используем раскладку флексбокса ещё в одном примере. <br />
        Для начала выстроим два блока, идущих друг за другом, в ряд. Затем
        изменим порядок их отображения. <br />
        Заметьте, что флекс-элементам внутри флекс-контейнера становятся только
        прямые потомки, элементы первого уровня вложенности. <br />
        В нашем примере флекс-контейнер .post включат два флекс-элемента section
        и aside. Блоки внутри флекс-элементов ведут себя как обычно, флекс-поток
        их не затрагивает.
      </p>
      <h3>
        <a href="Флексбоксы 1/Вертикальный ряд 2.html"
          >Вертикальный ряд иконок, часть 2</a
        >
      </h3>
      <p>
        Флекс-элемент внутри флекс-контейнера можно также сделать
        флекс-контейнером. <br />
        Он будет одновременно вести себя и как флекс-элемент, то есть
        подчиняться правилам распределения и выравнивания своего родителя, и как
        самостоятельный флекс-контейнер. При этом его вложенные элементы первого
        уровня будут следовать только его флекс-правилам. <br />
        В нашем примере давайте сделаем блок с иконками вложенным
        флекс-контейнером, а его дочерние флекс-элементы распределим по всей
        высоте блока.
      </p>
      <h3>
        <a href="Флексбоксы 1/Вертикальный ряд 3.html"
          >Вертикальный ряд иконок, часть 3</a
        >
      </h3>
      <p>
        Теперь, если изменить высоту флекс элемента section, то изменится и
        высота элемента aside. А так как, aside сам является флекс-контейнером,
        то измнение его высоты перераспределит его дочерние флекс-элементы -
        синие квадратики. <br />
        Получается, что иконки всегда будут распределяться по высоте содержимого
        блока section. <br />
        Давайте првеим это, добавив ещё немного текста в блок.
      </p>
      <h3>
        <a href="Флексбоксы 1/CSS сортировка.html"
          >Сортировка эементов на CSS</a
        >
      </h3>
      <p>
        Интересного эффекта можно достичь, если комбинировать флексбокс и трюк с
        селектором :cheked ~. <br />
        Приём заключается в следующем: с помощью селектора по выделению чекбокса
        можно управлять порядком флекс-элементов, изменяя направление главной
        оси с помощью flex-direction. Лучше всего эффект работает, когда
        направление главной оси меняется с "сверху вниз" на "снизу вверх" <br />
        При этом флекс-контейнер должен находиться в разметке на одном уровне с
        чекбоксом. <br />
        Таким образом реализуется сортировка на CSS, без использования
        JavaScript.
      </p>
      <h3>
        <a href="Флексбоксы 1/Выравнивание блоков по высоте.html"
          >Выравнивание блоков по высоте с помощью flexbox</a
        >
      </h3>
      <p>
        Ещё одна часто встречающаяся задача - реализовать раскладку с блоками
        одинаковой высоты. <br />
        Надо учитывать, что одержимое блоков может быть разным и их высота может
        меняться. <br />
        В обычной лочной модели есть фундаментальный недостаток - соседние блоки
        ничего не знают друг о друге, поэтому их высоту нельзя "связать".
        Получается, что все "стандартные" варианты для решения этой задачи не
        работают:
      </p>
      <ul>
        <li>
          float или inline-block не могут "связывать" высоту соседних блоков
        </li>
        <li>
          таблицы и CSS-таблицы позволяют делать ячейки одинаковой высоты, но
          появляются ограничения, связанные с расположением элементов в строках
        </li>
        <li>
          минимальная высота не подходит, т.к. какой-то из блоков всегда может
          стать выше остальных
        </li>
        <li>
          конечно, можно задать всем блокам фиксированную высоту, но это
          решением совсем не универсальное
        </li>
      </ul>
      <p>
        А с помощью флексбоксов эта проблема решается легко и изящно, ведь
        флекс-элементы по умолчанию растягиваются на всю высоту контейнера.
        <br />
        Попробуем починить раскладку на float с помощью флексбокса.
      </p>
    </main>
    <footer>
      <h3>Здесь могла быть ваша кувшинка</h3>
    </footer>
  </body>
</html>
