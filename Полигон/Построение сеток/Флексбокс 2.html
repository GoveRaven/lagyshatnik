<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>Флексбоксы, 2 часть</title>
    <link rel="stylesheet" href="../../стили/Полигон.css" />
  </head>
  <body>
    <header>
      <img src="../../avatar/avatar1.jpg" width="90" height="90" alt="Лягушка" />
      <nav>
        <a href="../../Полигон.html">Назад</a>
      </nav>
    </header>
    <main>
      <h2>Флексбоксы, 2 часть</h2>
      <h3>
        <a href="Флексбоксы 2/Флекс-элементы и блочная модель.html"
          >Флекс-элемент и блочная модель</a
        >
      </h3>
      <p>
        В предыдущей главе про флексбоксы мы познакомились с базовым понятиями
        этого механизма раскладки и подробно изучали, как работает выравнивание
        флекс-элементов. Ну, а эта глава будет посвящена управлению размерами
        флекс-элементов. <br />
        Начнём с простого вопроса. Как работает привычная нам блочная модель
        внутри флекс-контейнера? Есть ли какие-нибудь отличия в поведении
        привычных свойств? <br />
        Ширина, высота, внутренние отступы и рамки для флекс-контейнеров и
        флекс-элементов работают как обычно: общий размер элементов складывается
        из компонентов. Это поведение также можно менять с помощью свойства
        box-sizing. <br />
        Есть и несколько важных отличий:
      </p>
      <ul>
        <li>
          флекс-элементы, в отличие от блочных элементов, не растягиваются на
          всю ширину контейнера по умолчанию
        </li>
        <li>на флекс-элементы не действует свойство float</li>
      </ul>
      <p>
        Теперь поработаем с уже знакомыми свойствами и убедимся, что они
        работают привычным нам образом.
      </p>
      <h3>
        <a href="Флексбоксы 2/Особенности margin.html"
          >Особенности свойства margin</a
        >
      </h3>
      <p>
        В предыдущем задании мы не упоминали про свойство margin, ведь оно таит
        много сюрпризов:
      </p>
      <ul>
        <li>
          внешние отступы не схлопываются, ни по горизонтали, ни по вертикали
        </li>
        <li>
          внешние отступы не выпадают, ни из флекс-контейнера, ни из
          флекс-элементов
        </li>
        <li>
          значение auto получило премию журна аФорбс в номинации "Самое
          влиятельное значение CSS-свойства внутри флекс-контейнера"
        </li>
      </ul>
      <p>
        Всё дело в механизме распределения свбодного места. Если внутри
        флекс-контейнера есть свободное место, то оно перераспределяется так:
      </p>
      <ol>
        <li>
          находятся элементы, у которых есть внешние отступы со значением auto
        </li>
        <li>
          всё свободное место в соответствующих направлениях отдаётся таким
          отступам (т.е. задаётся определённый размер отступа в пикселях)
        </li>
        <li>
          если элементы с автоматическими отступами на одном направлении
          несколько, то место между ними перераспределяется поровну
        </li>
        <li>только после этого запускаются механизмы выравнивания</li>
      </ol>
      <p>
        Поэтому margin:auto; влияет на положение флекс-элементов на обеих осях,
        а также "ломает" механизмы выравнивания, ведь выравнивание происходит,
        когда есть свободное место. Но если всё свободное место "перетекло" в
        автоматический оттуп, то и выравнивать нечего. <br />
        Эти особенности можно использовать во благо. Например, с помощью
        автоматических отступов вы можете управлять расположением элементов
        вдоль главной оси. Давайте поэкспериментируем.
      </p>
      <h3>
        <a href="Флексбоксы 2/Выравнивание и margin.html"
          >Выравнивание и внешние отступы</a
        >
      </h3>
      <p>
        В прошлом задании мы проверили, как автоматический внешний отступ влияет
        на положение флекс-элементов на главной оси. Кроме того убедились, что
        такие отступы "ломают" свойство justify-content. <br />
        Автоматический margin влияет и на выравнивание флекс-элементов вдоль
        поперечной оси. <br />
        Если у флекс-элемента отступ сверху и снизу автоматический, то на него
        не влияют ни align-items, н align-self. Такой элемент прижимается либо к
        верху контейнера, либо к низу. <br />
        А если задать автоматические отступы с противоположных сторон, то
        элемент разместиться по центру флекс-контйнера, т.к. свободное мместо
        "впитается" отступами поровну.
      </p>
      <h3>
        <a href="Флексбоксы 2/Главная ось и отступы.html"
          >Направление главной оси и внешние отступы</a
        >
      </h3>
      <p>
        "Старые нефлексовые" свойства, такие как отступы или размеры, ничего не
        знают про направление осей. Они "мыслят по-старому", понятиями "верх" и
        "низ", "право" и "лево". <br />
        Поэтому когда главная ось направлена слева направо, горизонтальные
        отступы перемещают флекс-элемены вдоль главной оси. Но если направить
        главную ось сверху вниз, то те же отступы начнут работать вдоль
        поперечной оси. <br />
        То же относится и к вертикальным отступам. <br />
        Давайте повернём ось, а затем внесём правки.
      </p>
      <h3>
        <a href="Флексбоксы 2/flex-basis.html"
          >Базовый размер флекс-элемента, flex-basis</a
        >
      </h3>
      <p>
        На примере отступов видно, что "старые" свойства внутри флекс-контейнера
        веду себя достаточно глупо. Ширина и высота тоже не умеют реагировать на
        поворот главной оси. Поэтому ввели понятия главный размер или main size
        и поперечный размер или cross size. <br />
        Если главная ось направлена горизонтально, то главный размер - это
        ширина, свойство width, а поперечный размер - это выоста, свойство
        height. Если главная ось направлена вертикально, всё наоборот. <br />
        А хотелось бы иметь "умное" свойство для задания размера
        флекс-элементов, которое знает про главную ось и "поворачивается" вместе
        с ней. <br />
        И такое свойство есть - это flex-basis. Оно задаёт базовый размер
        флекс-элемента или разммер вдоль главной оси. <br />
        Если flex-basis не задан или его значение равно auto, то базовый размер
        берётся из width и height. <br />
        Свойство flex-basis принимает те же значчение, что и width/height.
      </p>
      <code>
        flex-basis: 100px; /* базовый размер 100 пикселей*/ <br />
        flex-basis: 50%; /* базовый размер 50% */
      </code>
      <p>
        Свойство flex-basis "сильнее" свойств width и height, и если у
        флекс-элемента заданы все три свойства, то flex-basis переопределит либо
        ширину, либо ывсоту в зависимости от направления главной оси.
      </p>
      <h3>
        <a href="Флексбоксы 2/fllex-grow.html"
          >Коэффициент растягивания элементов, flex-grow</a
        >
      </h3>
      <p>
        В предыдущем задании мы кое о чём умолчали. На самом деле, базовый
        размер - это не просто размер элемента вдоль главной оси, это начальный
        или исходный размер вдоль главной оси. <br />
        Почему так важны эти начальный или исходный? <br />
        И снова сё в дело в механизме перераспределения свободного места во
        флексбоксе. <br />
        Если внутри флекс-контейнера по главной оси остаётся свободное место, то
        мы можем попросить флекс-элемент, чтобы он увеличился и занял это место.
        Это делается с помощью свойства flex-grow, которое можно назвать
        "коэффициентом флекс-жадности" флекс-элемента. <br />
        Свойств flex-grow принимает неотрицательные числовые значения, его
        значение по умолчанию - 0. <br />
        Если значение flex-grow больше нуля, то флекс-элемент будет
        увеличиваться, "захватывая" оставшееся свободное место. <br />
        Получается, что базовый размер - это исходный размер флекс-элементов до
        применения flex-grow.
      </p>
      <h3>
        <a href="Флексбоксы 2/Пропорциональное растягивание.html"
          >Пропорционалное растягивание элементов</a
        >
      </h3>
      <p>
        Если сразу у нескольких флекс-элементов значение fle-grow больше нуля,
        то они будут делить свободное место между собой. <br />
        Свободное место будет добавляться флекс-элементам пропорционально
        знаениям их "коэффициента жадности". Например, если во флек-контейнере
        есть два элемента:
      </p>
      <code>
        .element-1 {flex-grow: 1;} <br />
        .element-2 {flex-grow: 2;}
      </code>
      <p>
        То второму элементу достанется в два раза больше свободного места, чем
        первому. Если изменить значения коэффициентов у этих элементов на такие:
      </p>
      <code>
        .element1 { flex-grow: 50;} <br />
        .element2 { flex-grow: 100;}
      </code>
      <p>
        То ничего не изменится, т.к. отношения коэффициентов не изменилось: 100
        в два раза больше 50. Т.е. важно не само значеня коэффициента, а его
        соотношение с коэффициентами остальных элементов. <br />
        Это задание-загадка на подбор пропорций. Вам нужно подобрать такие
        значения flex-grow, чтобы итоговый размер элементов оказался нужного
        размера. <br />
        Сейчас поэкспериментируйте самостоятельно, а в следующем задании мы
        детально разберём алгоритм расчётов итогового размера флекс-элементов с
        ненулевыми flex-grow.
      </p>
      <h3>
        <a href="Флексбоксы 2/Расчёт размера flex-grow.html"
          >Расчёт итогового размера с flex-grow</a
        >
      </h3>
      <p><b>1 шаг.</b> Рассчитываем свободное место во флек-контейнере.</p>
      <code>
        Свободное место = Ширина контейнера - Сумма базовых размеров элементов.
      </code>
      <p><b>2 шаг.</b> Считаем размер минимальной доли свободного места:</p>
      <code>
        Доля свободного места = Свободное место / Сумма flex-grow всех
        флекс-элементов
      </code>
      <p>
        <b>3 шаг.</b> Базовый размер каждого флекс-элемента увеличиваем на
        размер минимальной доли свободного места, умноженной на значение
        flex-grow этого элемента:
      </p>
      <code>
        Итоговый размер = Базовый размер + (Доля свободного места * flex-grow)
      </code>
      <p>
        В прошлом заднии для верхнего блока с енотами хочется задать
        коэффициенты 1 и 2. Но нужные размеры блоков получаются с коэффициентами
        1 и 3. Давайте посчитаем:
      </p>
      <code>
        Свободное место = 300px - (50px *2) = 200px <br />
        Доля свободного места = 200px / (1+3) = 50px <br />
        Итоговый размер первого блока = 50px + (50px * 1) = 100px <br />
        Итоговый размер второго блока = 50px + (50px * 3) = 200px
      </code>
      <p>
        Но если задать флекс-элементам нулевыой базовый размер, свободное место
        будет занимать всю ширину флекс-контейнера, и коэффициенты жадности
        будут другими. <br />
        Использовать flex-basic: 0 и flex-grow для точного управления
        относительными размерами не стоит. Лучше использовать базовый размер в
        процентах. <br />
        <i>Тонкость.</i> На размеры оставшегоя свободного места влияет не только
        flex-basis, но и рамки, и отступы. Если flex-basis явно задано нулевое
        значение, то min-width на размеры свободного места влиять не будет, т.к.
        ограничения размеров к флекс-элементам применяются уже после
        перераспределения свободного места.
      </p>
      <h3>
        <a href="Флексбоксы 2/flex-shrink.html"
          >Коэффициент сжатия элементов, flex-shrink</a
        >
      </h3>
      <p>
        Если сумма базовых размеров флекс-элементов больше, чем размер
        флекс-контейнера, то возникает отрицательное пространство. <br />
        Механизм перераспределения работает не только для свободного места, но и
        для отрицательного пространства. Флекс-элементы умеют распределять
        отрицательное пространство между собой и сжиматься. <br />
        За уменьшение флекс-элементов отвечает свойство flex-shrink, которое
        ожно назвать "коэффициентом сжатия". <br />
        Свойство flex-shrink принимает неотрицательные числовые значения, его
        значение по умолчанию - 0. <br />
        Если значение flex-shrink больше нуля, то флекс-элемент будет
        уменьшаться, "впитывая" часть отрицательного пространства, если оно
        существует. <br />
        Если значение flex-shrink равно нулю, то флекс-элемент уменьшаться не
        будет. <br />
        Флекс-элементы стараются быть максимально "гибкими" и не выпадать из
        своего контейнера, поэтому у flex-shrink значение по умолчанию 1. Но
        если задать нулевые значения для коэффициента сжатия, то выпадения
        элементов добиться можно.
      </p>
      <h3>
        <a href="Флексбоксы 2/Пропорции сжатия.html"
          >Пропорциональное сжатие элементов</a
        >
      </h3>
      <p>
        Свойство flex-shrink очень похоже на свойство flex-grow. Оно задаёт
        пропорции, в которых флекс-элементы "впитывают" отрицательное
        пространство. <br />
        Чем больше значение коэффициента сжатия у элемента, тем больше
        отрицательного пространства он "впитает" и тем силнее сожмётся. <br />
        Когда базовые размеры флекс-элементов одинаковы, пропорции сжатия
        элементов считаются так же, как пропорции увеличения. Если базовые
        размеры флекс-элементов отличаются, то механизм усложняется. Подробно мы
        разберм в следующем задании. <br />
        А пока снова поэкспериментируйте с коэффициентами в задании-загадке.
        <br />
        Нужно подобрать такие значения flex-shrink, чтобы итоговый размер
        элементов оказался таким же, как и у кричневой и зелёной "линеек", и
        чтобы над красной "линейкой" ничего не было. <br />
        На красной линейке показан рамзер отрицательного пространства, котрое
        распределяется при сжатии флекс-элементов. <br />
      </p>
      <h3>
        <a href="Флексбоксы 2/Расчёт размера flex-shrink.html"
          >Расчёт итогового размера с flex-shrink</a
        >
      </h3>
      <p>
        Ниже опсиан механизм расчёта размеров элементов, когда место в
        контейнере не хватает: <br />
        <b>1 шаг.</b> Рассчитываем отрицательное пространство (ОП) во
        флекс-контейнере:
      </p>
      <code>
        ОП = Ширина контейнера - Сумма базовых размеров флекс-элементов
      </code>
      <p>
        <b>2 шаг.</b> Находим сумму произведений базовых рамеров (СПБР)
        элементов на их коэффициенты сжатия:
      </p>
      <code>
        СПБР = (Базовый размер<sub>1</sub> * flex-shrink<sub>1</sub>) + (Базовый
        размер<sub>2</sub> * flex-shrink<sub>2</sub>) + ... + (Базовый
        размер<sub>n</sub> * flex-shrink<sub>n</sub>)
      </code>
      <p>
        <b>3 шаг.</b> Для каждого элемента считаем "нормированный коэффициент
        сжатия" (НКС), для чего произведение базового размера элемента на его
        коэффициент сжатия делим на СПБР:
      </p>
      <code> НКС = (Базовый размер * flex-shrink)/СПБР </code>
      <p>
        <b>4 шаг.</b> Базовый размер элемента уменьшаем на часть ОП
        пропорциональную НКС элемента. ОП для расчёта берём по модулю, то есть
        отбрасывая минус:
      </p>
      <code> Итоговый размер = Базоывй размер - (НКС * ОП) </code>
      <p>
        Получается, что доля отрицательного пространства, которую "впитывает"
        элемент, зависит от двух факторов:
      </p>
      <ul>
        <li>
          соотношения коэффициента сжатия элемента с коэффициентами других
          элементов
        </li>
        <li>
          соотношения базового размера элемента с базовыми размерами других
          элементов
        </li>
      </ul>
      <p>
        Именно поэтому в формулах присутствуют нормировки. А тепепрь снова
        попробуем подобрат коэффициенты сжатия.
      </p>
      <h3>
        <a href="Флексбоксы 2/flex-shrink и min-width.html"
          >flex-shrink и min-width</a
        >
      </h3>
      <p>
        Решение предыдущего задания: коэффциенты должны быть 1 и 1. <br />
        Давайте рассчитаем размеры элементов из предыдущего задания и убедимся в
        правильности описания алгоритма.
      </p>
      <code>
        Отрицательное пространство = 200px - 100px - 300px = -200px <br />
        Сумма произведений размеров на коэффициенты = (1 * 100px) + (1 *300px) =
        400px <br />
        Нормированный коэффициент 1 элемента = (1 * 100px) / 400px = 0.25 <br />
        Нормированный коэффициент 2 элемента = (1 * 300px) / 400px = 0.75 <br />
        Итоговый размер 1 элемента = 100px - (200px * 0.25) = 50px <br />
        Итоговый размер 2 элемента = 300px - (200px * 0.75) = 150px
      </code>
      <p>Есть несколько тонкостей, касающихся сжатия флекс-элементов:</p>
      <ul>
        <li>
          элементы сжимаются в пределах своих базовых размеров, внутренние
          отступы и рамки не сжимаются
        </li>
        <li>
          "ограничительные" свойства, такие как min-width, пименяются к
          элементам после этапа перераспределения свободного места или
          отрицатльного пространства
        </li>
      </ul>
      <p>
        И эти тонкости могут приводить к ножиданным эффектам, когда элементы
        выпадают из флекс-контейнера. Давайте поэкспериментируем.
      </p>
      <h3><a href="Флексбоксы 2/flex.html">Сокращённое свойство flex</a></h3>
      <p>
        С помощью сокращённого свойства flex можно одновременно задать
        коэффициенты растягивания, сжатия и базоывый размер флекс-элемента.
        <br />
        Свойство flex состоит из трёх компонентов, которые пишутся через пробел
        в следующем порядке: flex-grow, flex-shrink и flex-basis. В примере ниже
        два правила аналогичны:
      </p>
      <code>
        .flex-item { <br />
        flex: 1 2 300px; <br />
        } <br />
        .flex-item { <br />
        flex-grow: 1; <br />
        flex-shrink: 2; <br />
        flex-basis: 300px; <br />
        }
      </code>
      <p>
        Ещё у свойства flex есть сообые значения: initial, auto, none. Также
        второй и третий компоненты необязательны. Ниже показаны различия
        значения свойства и их расшифровки.
      </p>
      <code>
        flex: initial; -> flex: 0 1 auto; <br />
        flex: auto; -> flex: 1 1 auto; <br />
        flex: none; -> flex: 0 0 auto; <br />
        flex: 1 0; -> flex: 1 0 0%; <br />
        flex: 1; -> flex: 1 1 0%
      </code>
      <p>
        В некоторых браузерах неполные или особенные значения свойства flex
        интерпретируются с ошибками. Поэтому лучше задавать все три компоненты в
        значении этого свойства
      </p>
      <h3>
        <a href="Флексбоксы 2/Многострочный контейнер и flex-shrink.html"
          >Мнгострочный флекс-контейнер и flex-shrink</a
        >
      </h3>
      <p>
        Во всех примерах, рассмотренных раньше, флекс-контейнер был
        однострочным, ведь перенос флекс-элементов на новую строку по умолчанию
        запрещён - работает flex-wrap: nowrap; <br />
        А как будет растягиваться и сжиматься элементы в многострочном
        контейнере, с flex-wrap: wrap; ? <br />
        В таком контейнере свойство flex-shrink будет работать как обычно, но
        необходимость в нём будет возникать намного реже. Ведь при нехватке
        места в строке флекс-элементы будут переноситься на новую строку. <br />
        Но если появятся флекс-элементы, базовый размер которых больше размера
        флекс-контейнера, то такие элементы будут сжиматься и занимать целую
        строку. Наверное, это единственный случай, когда flex-shrink делает
        что-то полезное в многострочном контейнере.
      </p>
      <h3>
        <a href="Флексбоксы 2/Многострочный контейнер и flex-grow.html"
          >Многострочный флекс-контейнер и flex-grow</a
        >
      </h3>
      <p>
        В отличие от flex-shrink,. свойство flex-grow в многострочном
        флекс-контейнере срабатывает намного чаще и пользы пиносит наммного
        больше. <br />
        В каждой строке такого контейнера может быть свободное место и механизм
        перераспределения этого места работает построчно. <br />
        Поэтому возможность "растянуть" флекс-элементы, чтобы строки заполнялись
        по ширине полностью, будет возникать достаточно часто.
      </p>
      <h3>
        <a href="Флексбоксы 2/fkex-basis 100 и flex-wrap.html"
          >flex-basis:100% и flex-wrap</a
        >
      </h3>
      <p>
        Познакомимся с интересным эффектом, который озникает при исползовании
        базовых размеров в процентах. <br />
        Если задать базовый размер флекс-элемента 100% и при это включить
        перенос элементов на новую строку, то элементы расположаться столбцом,
        хотя главная ость контейнера будет по прежнему направлена слева направо.
      </p>
      <h3>
        <a href="Флексбоксы 2/Заголовок с описанием.html"
          >Заголвок с описанием на флексбоксе</a
        >
      </h3>
      <p>
        Мы рассмотрели теоретическую часть и приступаем к практической части
        этой главы. Давайте разберём на реальных элементах интерфейса, в каких
        случаях бывает уместно использовать флексбокс. <br />
        Довольно распространённый ход в интерфейсе - блок с заголовком и
        небольшим уточняющим подзаголовком на одной строке. Заголовок находится
        в начале строки, а подзаголовок прижат к правому краю. <br />
        Если текст заголовка или подзаголовка сильно увеличится, то вёрстка не
        должна ломаться - тексты просто должны расположиться друг под другом.
        <br />
        Сверстать элемент с таким гибким повведением с помощью float или
        display: table не получится. Ведь нужно, чтоб блоки подписей
        одновременно и занимали свободное пространство, и чтобы их размеры
        зависели от текстового содержания, и чтобы в случае переполнения сетка
        перестраивалась. <br />
        Здесь нам поможет только флексбокс с flex-grow. <br />
        Для наглдности зададим текстовым блокам фоновый цвет и рамку, а в
        следующем задании уберём их.
      </p>
      <h3>
        <a href="Флексбоксы 2/Заголовок с описанием 2.html"
          >Заголовок описанием, часть 2</a
        >
      </h3>
      <p>
        А теперь давайте промерим, как сработает наша раскладка, если текста
        станет немного больше. <br />
        На случай "переполнения" зададим контейнеру перенос флекс-элементов на
        новую строку.
      </p>
      <h3>
        <a href="Флексбоксы 2/Гибкое меню 1.html"
          >"Гибкое" меню с переполнением</a
        >
      </h3>
      <p>
        А тепеь давайте создадим ещё одно "гибкое" меню, похожее на то, что мы
        делали в задании прошлой главы. <br />
        Напомним, что в прошлом варианте пункты равномерно распределялись внутри
        контейнера меню с помощью justify-content: space-around. <br />
        Новый вариант меню будет более адептивным: пунктвы меню будут
        переноситься на следующую строку, если места будет не хватать. А ещё для
        достижения красивой симметрии пункты будут растягиваться, чтобы занимать
        весь контейнер меню. И снова нам поможет flex-grow. <br />
        Создадим базовую раскладку и зададим перенос строк.
      </p>
      <h3>
        <a href="Флексбоксы 2/Гибкое меню 2.html"
          >"Гибкое" меню с переполнением, часть 2</a
        >
      </h3>
      <p>
        Теперь остаётся задать элементам меню коэффициент растяжения и
        проверить, как будет вести себя меню, если мы решим изменить его ширину,
        либо добавить пункты. <br />
        Получивашееся решение удобно применять для адаптации к мобильным
        интерфейсам. При этом даже не потребуется добавлять дополнительные стили
        для мобильных вьюпортов
      </p>
      <h3>
        <a href="Флексбоксы 2/Поля ввода.html"
          >Поля ввода с динамической шириной</a
        >
      </h3>
      <p>
        Ещё один случай, когда может пригодится флексбокс - поля ввода с
        динамической шириной. Требоавния к ним такие:
      </p>
      <ul>
        <li>
          На одной строке с полем могут находиться другие элементы: кнопки,
          ссылки, подписи
        </li>
        <li>
          Размер дополнительных элементов не определён, он зависит от их
          содержимого
        </li>
        <li>
          При этом поле должно растягиваться на всё оставшееся в родительском
          контейнере место
        </li>
        <li>И изменять ширину при изменении размеров контейнера</li>
      </ul>
      <p>
        Решить эту задачу можно только при помощи флексбокса. Превратим
        контейнер поля ввода во флекс-контейнер, все элементы внутри него
        превраятся во флекс-элементы, базовый размер которых буде зависеть от их
        содержания - flex-basis: auto; И останется только задать
        ненулевыекоэффициенты растягивания полям ввода. <br />
        В широко контейнере всё будет работать отлично. Прблемы могут появиться
        в слишкм узких контейнерах: по умолчанию поля ввода не будут сжиматься
        после определённой ширины, что приведёт к выпаданию текста из остальных
        элементов. <br />
        Чтобы справиться с этими проблемами, надо задать всем элементам кроме
        полей ввода нулевой коэффициент сжатия, а самим полям ввода явно
        прописать минимальную ширину.
      </p>
      <h3>
        <a href="Флексбоксы 2/Карточка курса 1.html">Карточка курса, часть 1</a>
      </h3>
      <p>
        Теперь давайте соберём на флексбоксе интерфейс с карточками курсов.
        <br />
        Флексбокс нужен, чтобы сделать этот блок адаптинвым. Вы увидите, как
        гибко он адаптируется в следующих заданиях. <br />
        Начнём работу с отдельной карточки. Сделаем карточку флекс-контейнером и
        направим её главную ось сверху вниз. Это необходимо, чтобы в дальнейшем
        гибко управлять внутренними блоками карточки. <br />
        Напомним, что флекс-элементы могут одновременно быть и
        флекс-контейнерами. <br />
        Мы превратим блок с мета-информацией в флекс-контейнер, чтобы
        расположить блоки с тегами и временем чтения.
      </p>
      <h3>
        <a href="Флексбоксы 2/Карточка курса 2.html">Карточка курса, часть 2</a>
      </h3>
      <p>
        Пишло время добавить вторую карточку. <br />
        Для управления раскладкой карточек превратим их родительский блок в
        флекс-контейнер. <br />
        И теперь уже карточки стали одновременно и флекс-элементами, и
        флекс-контейнерами.
      </p>
      <h3>
        <a href="Флексбоксы 2/Карточка курса 3.html">Карточка курса, часть 3</a>
      </h3>
      <p>
        Карточки выстроились в один ряд и теперь их высота одинакова. Это
        произошло потому что их родительский элемент - флекс-контейнер с
        поперечным выравниванием stretch. <br />
        Сейчас мы сделаем так, чтобы кнопки "Пройти курс" выравнивались по
        нижнему краю карточки. Для этого:
      </p>
      <ul>
        <li>
          Зададим блоку .card-content положительный коэффициент растяжения,
          чтобы он занял всё свободное место в карточке
        </li>
        <li>
          Превартим блок .card-content в флекс-контейнер с главной осью,
          направленной сверху вниз.
        </li>
        <li>
          Зададим кнопке автоматический оттуп сверху, чтобы она прижималась к
          концу главной оси блока .card-content
        </li>
      </ul>
      <p>
        Вспомните, как на первом шаге мы сделали карточки флекс-контейнерами.
        Без этого нельзя растянуть вложенные блоки "в высоту" с помощью
        flex-grow.
      </p>
      <h3><a href="Флексбоксы 2/Карточка курса 4.html">Много карточек</a></h3>
      <p>
        На последнем шаге мы проработаем с раскладкой карточек. <br />
        Сделаем так, чтобы карточки переносились на новую строку, если им не
        хватает места в контейнере. А если свободное место на строке осталось,
        то карточки будут его занимать. <br />
      </p>
    </main>
    <footer>
      <h3>Здесь могла быть ваша кувшинка</h3>
    </footer>
  </body>
</html>
