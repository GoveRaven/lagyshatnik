<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>Знакомство с гридами</title>
    <link rel="stylesheet" href="../../стили/Полигон.css" />
  </head>
  <body>
    <header>
      <img src="../../avatar/avatar1.jpg" width="90" height="90" alt="Лягушка" />
      <nav>
        <a href="../../Полигон.html">Назад</a>
      </nav>
    </header>
    <main>
      <h2>Знакомство с гридами</h2>
      <h3>
        <a href="Гриды/Координаты грид-элементов.html"
          >Координаты грид-элементов: grid-row-start и grid-column-start</a
        >
      </h3>
      <p>
        Гриды - новая система для построения сетки страниц. Несмотя на новизку,
        в современных браузерах у гридов хорошая поддержка. Возможно, из этих
        курсов уже успели познакомиться с другими системами построения сеток, и
        возникает вопрос - зачем нам гриды, если есть, например, флексбоксы?
        Дело в том, что в отличие от флексбоков, гриды позволяют нам работать и
        с колонками, и со строками одновременно, что замечательно, не правда ли?
        Но не будем забегать вперёд и расскажем обо всё по порядку. <br />
        В первой части главы мы займёмся изучением гридов на примере
        ландашафтного дизайна, попробуем построить грид-раскладку, представив,
        что это карта местности, и составим визуальный план того, как будут
        располагаться объекты на эой местности. <br />
        После того, как вы станете матёрыми ландшафтными дизайнерами, мы
        перейдём ко второй части главы, где с помощью гридов попробуем создать
        простые сетки реальных страниц, похожих на те, что встречаются в сети.
        Наверняка вы уже делали что-то подобное с помощью флоатов, CSS-таблиц
        или флексов. <br />
        Итак, чтобы сделать блок грид-контейнером, нужно задать ему
        соответствующее значение свойства display:
      </p>
      <code>
        .container { <br />
        display: grid; <br />
        }
      </code>
      <p>
        Непосредственные дочерние элементы в грид-контейнере становятся его
        грид-элементами и далее уже располагаются согласно раскладке грида.
        <br />
        Как мы уже упоминали, в гриде элементы располагаются по двумерной сетке.
        То есть грид состоит из рядов и столбцов, располагающихся между линиями,
        которые нумеруются по порядку. <br />
      </p>
      <img src="Гриды/Картинки/1.PNG" alt="">
      <p>
        А чтобы расположить элементы внутри грида, нужно задать ему координаты.
        То есть как бы заставить элемент говорить: <br />
        <i
          >Я - элемент грида, начинаюсь с такой-то линии столбцов и с такой-то
          линии рядов.</i
        >
        <br />
        Когда мы задаём координату начала грид-элементу по рядам или столбцам,
        он автоматически продлевается до следующей линии рядов или столбцов и
        таки образов образуется грид-ячейка. <br />
        На примере выше ячейка начинается на 4 линии столбцов и 3 линии рядов. <br>
        В коде делается это с помощью свойств grid-column-start и
        grid-row-start. <br />
        Пример:
      </p>
      <code>
        grid-column-start: 4 - элемент начинается с 4 линии столбцов. <br />
        grid-row-start: 3 - элемент начинается с 3 линии рядов
      </code>
      <p>
        Перейдём к первому заданию. У нас есть грид, который состоит из 4 рядов
        и 4 столбцов. Давайте попробуем задать элементу в том гриде свойства,
        согласно которым он будет начинаться на определённой линии рядов и на
        определённой линии столбцов.
      </p>
      <h3>
        <a href="Гриды/grid-column-start end.html"
          >Координаты грид-элементов: grid-column-start и grid-column-end</a
        >
      </h3>
      <p>
        Итак, теперь мы знаем, что будет, если указать начало грид-ячейки по
        ряду и по столбцу - её размер автоматически станет равен одному
        "делению" грида. <br />
        Если же мы захотим продлить грид-ячейку на несколько рядов или столбцов,
        то нужно указать помимо той линии, где ячейка начинается, ещё ту линию,
        где она заканчивается. <br />
      </p>
      <img src="Гриды\Картинки\2.PNG" />
      <p>
        На примере выше ячейка начинается на 3 линии столбцов, а заканчивается на 5 линии. <br>
        Для обозначения конца ячейки по столбцам существует свойство grid-column-end. <br>
        То есть в коде мы так и запишем:
      </p>
      <code>
        grid-column-start: 3 - элемент начинается с 3 линии столбцов. <br>
        grid-column-end: 5 - элемент заканчивается на 5 линии столбцов.
      </code>
      <p>
        А теперь давайте попробуем создать ячейку, которая будет располагаться на двух столбцах
      </p>
      <h3><a href="Гриды/grid-row-start end.html">Координаты грид-элементов: grid-row-start и grid-row-end</a></h3>
      <p>
        Отлично! А что если мы захоти астянуть ячейку и по рядам тоже? <br>
        Для того чтобы мы имели такую возможность, существует свойство grid-row-end, которое работает в паре с grid-row-start и задаёт ячейке нужные нам координаты.
      </p>
      <img src="Гриды/Картинки/3.PNG">
      <p>
        На примере выше ячейка начнаетсяс на 2 линии рядов, а заканчивается на 4 линии. <br>
        Код получится такой:
      </p>
      <code>
        grid-row-start: 2 - элемент начинается со 2 линии рядов. <br>
        grid-row-end: 4 - элемент заканчивается на 4 линии рядов.
      </code>
      <p>
        Теперь давайте попробуем разметить наш грид-элемент так, чтобы он располагался на двух рядах и двух столбцах одновременно.
      </p>
      <h3><a href="Гриды/Отрицательные column.html">Отрицательные значения grid-column-start и grid-column-end</a></h3>
      <p>
        Интересной особенностью грид-ячейки является возможность начинать отсчёт её координат как от начала (первой линии ряда или столбца), так и от конца грида (последней линии ряда или столбца). Вот как это выглядит схематично:
      </p>
      <img src="Гриды/Картинки/4.PNG">
      <p>
        То есть, чтобы сказать ячейке: "Начинайся на первой линии столбцов от наала и заканчивайся на первой линии столбцов с конца", нужно написать такой код:
      </p>
      <code>
        .element { <br>
            grid-column-start: 1; <br>
            grid-column-end: -1 <br>
        }
      </code>
      <p>
        А для того, чтобы сказать ячейке: "Начинайся на первой линии столбцов с конца грида и заканчивайся на первой линии с начала", нужно написать:
      </p>
      <code>
        .element { <br>
            grid-column-start: -1; <br>
            grid-column-end: 1 <br>
        }
      </code>
      <p>
        Попробуем этот приём на практике.
      </p>
      <h3><a href="Гриды/Отрицательные row.html">Отрицательные значения grid-row-start и grid-row-end</a></h3>
      <p>
        В предыдущем задании мы уже упоминали, что отрицательные значения в координатах можно использовать и по рядам. И, как вы уже догадались, для этого нам понадобятся свойства grid-row-start / grid-row-end <br>
        Мы уже брали значения -1, давайте попробуем что-то новенькое, например, значение -2, что будет означать <i>вторая линия рядов с конца грида</i>:
      </p>
      <img src="Гриды/Картинки/5.PNG">
      <p>
        В коде это будет записано так:
      </p>
      <code>
        .element { <br>
            grid-row-start: 1; <br>
            grid-row-end: -2; <br>
        }
      </code>
      <h3><a href="Гриды/Наложение.html">Наложение элемментов грида</a></h3>
      <p>
        Ура! Мы научились задавать координаты грид-элемента! Но навярняка у вас уже назрел вопрос: "Могут ли грид-элементы наслаиваться друг на друга?" <br>
        Ответ: "Да!" В случае пересечения координат двух элементов грида они просто располагаются один поверх другого в порядке следования в разметке, как будто это стопка листов. <br>
        Давайте поробуем сложить грид-элементы в "стопку".
      </p>
      <h3><a href="Гриды/z-index.html">Наложение элементов грида и свойство z-index</a></h3>
      <p>      
        Как и на абсолютном спозиционированые элементы, на пересекающиеся грид-элементы действует старое-доброе свойство z-index. <br>
        Чем выше z-index, тем выше элемент в "стопке". Если у двух элементов одинаковый z-index, то выше будет располагаться тот, который идёт следующим по разметке. <br>
        Проверим этот момент на практике.
      </p>
      <h3><a href="Гриды/grid-template-areas.html">Именованные области грида:свойств grid-template-areas</a></h3>
      <p>
        Чтобы быстро описать простую сетку с помощью гридов, нужно хорошенько поорудовать свойствами grid-row-start/grid-row-end и grid-column-start/grid-column-end. Что мы и делали в предыдущих заданиях. Но получаетсяя несколько многословно, не правда ли? <br>
        Есть более быстрый способ создания сетки и заключается он в использовании свойств grid-template-areas и grid-area. <br>
        Помните игру "крестики-нолики", где мы вписываем в сетку 3 на 3 значки? <br>
        Так вот, со свойством grid-template-areas мы будем работать похожим образом, буквально по клеточкам визуально размечая наш грид. <br>
        Приведём пример. Допустим, что мы хотим сверстать вот такой простой грид 3 на 3, который представляет из себя три столбца: 
      </p>
      <img src="Гриды/Картинки/8.PNG">
      <p>
        В разметке мы имеем контейнер с тремя дочерними элементами:
      </p>
      <code>
        &lt;div class="grid"&gt; <br>
        &lt;div class="grid-element-1"&gt;&lt;/div&gt; <br>
        &lt;div class="grid-element-2"&gt;&lt;/div&gt; <br>
        &lt;div class="grid-element-3"&gt;&lt;/div&gt; <br>
        &lt;/div&gt;
      </code>
      <p>
        В CSS нам нужно описать области грида:
      </p>
      <code>
        grid-template-areas: <br>
        "red yellow green" <br>
        "red yellow green" <br>
        "red yellow green"; <br>
      </code>
      <p>
        Строки в значении свойства grid-template-areas - ни что иное, как визуальное представление рядов грида, а значенияя в строках - представления столбцов. <br>
        О! Так теперь таким образом можно строить какие угодно по форме сетки? Увы, но нет, есть небольшое ограничение - грид должен быть прямоугольной формы, а количество объявленных столбцов в каждой строке должно быть одинаковым. <br>
        Названия областей должны начинаться с буквы и могут включать цифры и дефис. Например, "lava lava2 lava-3" - валидное значение для grid-template-areas. Название в строках перечисляются через один или несколько пробелов. <br>
        Разметив то, как долны располагаться ячейки в гриде с помощью grid-template-areas, мы сделали половину дела. Теперь нужно связать визуальное представление с конкретными элементами в HTML. И поможет нам в этом свойство grid-area. <br>
        Так и запишем:
        <i>grid-element-1, ты будешь соответствовать области red, grid-element-2, ты будешь yellow, а ты, grid-element-3 - green</i>
      </p>
      <code>
        .grid-element-1 { <br>
          grid-area: red; <br>
        } <br>
        .grid-element-2 { <br>
          grid-area: yellow; <br>
        } <br>
        .grid-element-3 { <br>
          grid-area: green; <br>
        }
      </code>
      <p>
        Обратите нимание, чо название grid-area для каждого элемента должно быть уникальным. Например, если есть 6 грид-элементов, значит должно быть и 6 названий grid-area:
      </p>
      <code>
        grid-template-areas: <br>
        "green  green red  yellow" <br>
        "yellow2 red2  green2 yellow" <br>
        "yellow2 red2  green2 yellow";
      </code>
      <p>
        А дальше для каждого элемента с первого по шестой прописывается своё название grid-area. <br>
        Одному элементу в HTML может соответствоват только одна грид-область. Если одна грид-область задана нескольким HTML-элементам, действовать будет только одно, наиболее специфичное объявление:
      </p>
      <code>
        .grid-element-1 { <br>
          grid-area: red; /* Грид-область назначается первому элементу */ <br>
        } <br>
        .grid-element-2 { <br>
          grid-area: red; /* Грид-область red переназначается второму элементу */
        }
      </code>
      <p>
        Итак, секрет, как быстро создавать несложные сетки на гридах, раскрыт. Попробуем на практике.
      </p>
      <h3><a href="Гриды/grid-template-areas 2.html">Свойство grid-template-areas и пустые области грида</a></h3>
      <p>
        Свойство grid-template-areas позволяет некоторые области почеать как пустые. <br>
        Для этого вместо буквенного именования области используется символ точки . <br>
        К примеру, возьмём код из прошлой теории, где был грид из трёх столбцов.
      </p>
      <img src="Гриды/Картинки/8.PNG"> <br>
      <code>
        grid-template-areas: <br>
        "red yellow green" <br>
        "red yellow green" <br>
        "red yellow green"; <br>
      </code>
      <p>
        Если мы хотим, чтобы в первом ряду осталось только последняя зелённая ячейка. то заменим red и yellow в первой строке на точки:
      </p>
      <code>
        grid-template-areas: <br>
        ". . green" <br>
        "red yellow green" <br>
        "red yellow green"; <br>
      </code>
      <p>
        Получается нужный нам результат:
      </p>
      <img src="Гриды/Картинки/9.PNG">
      <p>
        Давайте дополним пустыми областями пример из прошлого задания.
      </p>
      <h3><a href="Гриды/Грид-столбцы.html">Автоматические кординаты элемнтов в гриде: столбцы</a></h3>
      <p>
        Окей, мы научились экономить время и использовать именованные области! Круто! <br>
        Но давайте теперь ввернёмся в самое начало, к первым заданиях этой главы. В них мы имели дело с гридами фиксированной ширины 4 на 4 ячейки. Сейчас мы рассмотрим свойства grid-template-columns и grid-template-rows. <br>
        Свойство grid-template-columns пеечисляет количество и ширину будущих столбцов грида. К примеру, запиь grid-template-columns: 100px 100px 100px; говорит гриду: <br>
        <i>Ты будешь иметь три столбца, каждый шириной 100px</i>
      </p>
      <img src="Гриды/Картинки/10.PNG">
      <p>
        А что же в это время происходит с рядами? <br>
        Если не задавать параметры для рядов, то их количество становится переменным. Порядок действий такой:
      </p>
      <ol>
        <li>Все грид-элементы выытраиваются в один ряд согласно объявленной раскладке столбцов.</li>
        <li>Если грид-элементов больше, чем столбцов, то не вписавшиеся в один ряд элементы переносятся на следующий ряд и заполняют его.</li>
        <li>Новые ряды формируются до тех пор, пока все гриды-элементы не будут вписаны в раскладку по столбцам. Если последний ряд заполняется элементами не полностью, то оставшееся место в гриде остаётся пустым</li>
      </ol>
      <p>
        Рассмотрим пример. Возьмём грид с пятью элементами, которому задан один столбец. По раскладке получается, что первый ряд грида может поместиться всего один грид-элемент. Остальные элементы будут переноситься на новый ряд, и таким образом сформируются пять рядов, то есть выстроятся в столбец:
      </p>
      <img src="Гриды/Картинки/10.2.PNG">
      <p>
        Если же мы увеличим количество столбцов до двух, то в один ряд будут помещаться уже по два элемента. То есть всего элементы сформируют три ряда, в первом и втором ряду будет по два элемента, а в третьем - один:
      </p>
      <img src="Гриды/Картинки/10.3.PNG">
      <p>
        Что касается высоты рдов, то она распределится равномерно, чтобы ряды заполнили всё пространство грида. <br>
        Ну, а чтобы всё стало совсем понятно, перейдём к практике.
      </p>
      <h3><a href="Гриды/Грид-столбы и ряды.html">Автоматические координаты элементов в гриде: столбцы и ряды</a></h3>
      <p>
        Аналогично grid-template-columns работает и свойство grid-template-rows, только оно сообщает гриду сколько рядов он будет содержать и какой они будут высоты. К примеру, запись grid-template-rows: 100px 200px 100px; говорит гриду: <br>
        <i>Ты будешь иметь три ряда, первый высотой 100px, второй высотой 200px и третий - 100px.</i>
      </p>
      <img src="Гриды/Картинки/11.PNG">
      <p>
        Если при этом столбцам не заданы явные параметры, то по умолчанию, будет существовать всего один столбец, элементы в котором растянутся на всю его ширину. <br>
        В случае, если в гриде есть ряды, которым не задана явная высота в grid-template-rows, оставшееся свободное пространство по высоте распределится среди них равномерно. <br>
        Таким образом, зная об особенностях распределениях ячеек в гридах и используя свойство grid-template-columns и grid-template-rows, можно создавать нужные вам сетки. 
      </p>
      <h3><a href="Гриды/Комбинируем координаты.html">Комбинируем автоматические и явные координаты</a></h3>
      <p>
        Итак, мы выяснили, как свойства grid-template-columns и grid-template-rows влияют на количество и размеры столбцов и рядов грида, а свойства grid-column-start / grid-column-end и grid-row-start / grid-row-end помогают нам распределять грид-элементы по конкретным координатам в грид-раскладке. <br>
        Теперь самое время разобраться, как использовать эти свойства совместно. <br>
        Давайте создадим грид с нуля и определим для него столбцы и ряды, а затем будем управлять отдельными элементами. <br>
        Начнём с создания грид-контейнера. Заметьте, что по умолчанию, при его создании, грид будет иметь всего один столбец во всю ширину контейнера, а каждый его элемент будет занимать целый ряд.
      </p>
      <h3><a href="Гриды/Комбинируем координаты 2.html">Комбинируем автоматические и явные координаты, часть 2</a></h3>
      <p>
        Как мы заметили, у нас появились пустые незаполненные элементы области, которые мы можем использовать. Поэтому следующим нашим шгом после определения рядов и столбцов будет распределение элементов. Зачем пропадать драгоценному пространству? <br>
        Идея в том, чтобы правильо распределить это пространство среди уже имеющихся элементов. <br>
        Как это сделать? Задавать всем элементам начало и конец? Не обязательно. Часть из элементов может иметь чёткие координаты в гриде, а часть занимать оставшееся место, то есть распределяться браузером автоматически. <br>
        Работает это следующим образом:
      </p>
      <ol>
        <li>Сначала выстраиваются элементы с явными координатами.</li>
        <li>Затем выстраиваются элементы, которым координаты явно не заданы. Они выстраиваются по очереди в порядке следования в размметке в оставшиеся "свободные ячейки" от начала грида к концу. По размерам такие грид-элементы занимают одну ячейку</li>
      </ol>
      <h3><a href="Гриды/Нефиксированные столбцы.html">Нефиксировання ширина столбцов</a></h3>
      <p>
        Выполненяя прошлые задания, мы убедились, что если не задавать строкам и столбцам грида явные размеры, то они по умолчанию будут занимать всё свободное прстранство. Давайте разберёмся, как мы можем извлечь из этого пользу. <br>
        Рассмотрим пример, когда нам нужно задать явную ширину первому и последнему столбцу трёхколоночного грида, а среднему столбцу отдать всё оставшееся пространство по ширине, не фиксируя его размеры. <br>
        Сейчас мы умеем задавать размеры столбцов с помощью фиксированных значений, например, вот так:
      </p>
      <code>
        grid-template-columns: 100px 100px 100px;
      </code>
      <p>
        Но если мы хотим оставить среднему столбцу автоматический размер, то в объявлении должно появиться ключевое слово auto. То есть код станет таким:
      </p>
      <code>
        grid-template-columns: 100px auto 100px
      </code>
      <h3><a href="Гриды/Нефиксированные столбцы и ряды.html">Нефиксированная ширина столбцов и рядов</a></h3>
      <p>
        Значение auto можно использовать и в определении столбцов, и в определении строк. Можно даже делать это одновременно. <br>
        К примеру, давайте создадим такой грид: вся шиина грида распределяется на два столбца поровну автоматически, первый и последний ряды имеют фиксированные значения
      </p>
      <h3><a href="Гриды/grid-gap.html">Грид-интервал: свойство gap</a></h3>
      <p>
        В реальных проектах часто бывает так, что при создании сетки между столбцами и рядами требуется оставить небольшой промежуток. <br>
        Разработчики спецификации гридов предусмотрели и эту возможность, придумав для нас свойство gap, позволяющее добавлять равномерный интервал сразу и между рядами, и между столбцами. Определяется это свойство в px, % и других единицах измерения:
      </p>
      <code>
        .grid { <br>
          gap: 10px; <br>
        }
      </code>
      <p>
        Выглядят интервалы следующим образом:
      </p>
      <img src="Гриды/Картинки/16.PNG">
      <p>
        Интересная ообенность грид-интервалов: они не появляются меду краями контейнера и крайними элементами. То есть это пустые пространства между элементами только изнутри грида.
      </p>
      <h3><a href="Гриды/gap с column и row.html">Грид-интервал: свойства row-gap и column-gap</a></h3>
      <p>
        Не всегда нам необходимы одинаковые интервалы между рядами и столбцами, и в этом случае к нам на помощью приходят свойства column-gap и row-gap. <br>
        Как вы уже догадались, первое свойство задаёт интервал между столбцами, а второе - между рядами.
      </p>
      <img src="Гриды/Картинки/17.PNG"> <br>
      <code>
        .grid { <br>
          row-gap: 20px /* грид-интервал между рядами */ <br>
          column-gap: 50px /* грид-интервал между столбцами */ <br>
        }
      </code>
      <p>
        На самом деле с помощью свойства gap тоже можно задавать интервал отдельно для столбцов и для рядов. Если задать gap не одно, а два значения, первое будет определять интервал между рядами, а второе - между столбцами. Второе значение задаётся через пробел после первого:
      </p>
      <code>
        .grid { <br>
          /* <br>
          грид-интервал между рядами 20px, <br>
          грид-интервал между столбцами 50px <br>
          */ <br>
          gap: 20px 50px; <br>
        }
      </code>
      <h3><a href="Гриды/Раскладка простой страницы 1.html">Раскладка простой страницы: создаём грид</a></h3>
      <p>
        Хорошо, на парках и зонах отдыхах мы натренировались достаточно. Теперь пора вернуться к интерфейсам, ведь мы же для этого тут собрались? <br>
        В следующей серии заданий мы разберём, как, используя гриды, сделать сетку двух страниц типового интернет-магазина: главной страницы и каталога с товарами. <br>
        Итак, начнём с главной страницы. У нас есть контейнер .index-rgid и набор блоков в нём: шапка с навигационным меню, промоблок с картинкой, блок со статьями, список отзывов и подвал. <br>
        Сейчас они стилизованы, но не расположены по сетке, а просто идут друг за другом сверху вниз. Нашей задачей будет исправить это и построить вот такую сетку:
      </p>
      <img src="Гриды/Картинки/18.PNG" style="max-width: 95% ;">
      <p>
        В приведённой схеме раскладке красные области показывают, как будут идти столбцы грида. Боковая клонка будет шириной в один столбец, а основное содержимое страницы будет занимать два столбца. Для единобразия все три столбца будут одинаковой ширины. <br>
        Начнём писатькод: сделаем раскладку нашей страницы гридом, добавим интервалы между рядами и столбцами, а потом зададим гриду три столбца.
      </p>
      <h3><a href="Гриды/Раскладка простой страницы 2.html">Раскладка простой страницы: шапка</a></h3>
      <p>
        Мы справились, но наша страница всё ещё не выглядит так, будто мы зашли на настоящий сайт. Сейчас она представляет собой три столбца, по которым распределились все наши блоки, автоматически подстроив высоту рядов под контент. <br>
        Поэтому не будет останавливаться на достигнутом и растянем шапку на всю ширину грида, чтобы остальные на достигнутом и растянем шапку на всю ширину грида, чтобы остальные элементы перешли ниже, в следующие ряды.
      </p>
      <h3><a href="Гриды/Раскладка простой страницы 3.html">Раскладка простой страницы: промоблок</a></h3>
      <p>
        Заметьте, что мы не стали фиксировать высоту ряда, в котором находится шапка сайте. Шапка содержит меню, количество пунктов которого может увеличиваться, что изменит высоту блока. <br>
        Следующему ряду давайте добавим фиксированную высоту. Ряд включает промоблок с картинкой, в сетке этот грид-элемент будет занимать два столбца. Не пугайтесь фиксированной высоты ряда. Мы можем позволить себе такую дерзость, так как сейчас этот ряд содержит только блок с картинкой, и в нём нет текста, соответственно высота этого блока может оставаться неизменной. И всё будет хорошо.
      </p>
      <h3><a href="Гриды/Раскладка простой страницы 4.html">Раскладка простой страницы: боковая колонка</a></h3>
      <p>
        В этом задании займёмся боковым столбцов, в который нам нужно поместить блок с отзывами. <br>
        В разметке блок .sidebar находится почти в самом концу, перед подвалом, но с помощью гридов мы можем запросто переместить его в любое место на страницу, ничего при этом не меняя в разметке. Ещё одна прекрасная особенность гридов! <br>
        Поместим его справа от промоблока, он будет занимать весь третий столбец и два ряда: второй и следующий за ним. <br>
        Примечательно, что блок начинается на фиксированном по высоте втором ряду и продолжается на третьем ряду, у которого высота автоматическая. Почему так, ведь в нашем блоке есть текст? <br>
        Дело в том, что всё-таки допустимо делать фиксированную высоту ряда, даже если в нём есть блоки с тектовым содержанием. Но нужно обязательно убедиться, что такие блоки расположены, помимо грид-ячеек с фиксированной высотой, ещё и в грид-ячейках с автоматической высотой, чтобы оставалась возможность увеличения размера текстов.
      </p>
      <h3><a href="Гриды/Раскладка простой страницы 5.html">Раскладка простой страницы: блок</a></h3>
      <p>
        Пришла очередь третьего ряда. На нём у нас будет располагаться блок со статьями, а также часть блока с отзывами. <br>
        Как вы уже догадались, блок со статьями, как и промоблок, занимает два столбца. <br>
        Но в отличие от промоблока, здесь нам нельщя фиксировать размеры элементов, так как по высоте у нас оба блока, что статьи, что отзывы, не должны быть ограничены. Почему? Правильно, потому что они оба содержат текстово содержимое, которое может меняться. <br>
        Обратите внимание, что у грид-строки с автоматическим размером высота формируется по высоте самого высокого грид-элемента, а остальные грид-элементы, которые тоже располагаются на этой грид-строке - растягиваются на её высоту. <br>
        Давайте проконтролируем, как будет ратягиваться третий нефиксированный ряд нашего грида, если в разметке появится ещё одна статься блока. <br>
        Заметьте, что grid-template-rows мы ничего не дописываем, так как по умолчанию размеры оставшихся рядов задаются автоматически, а нас это пока устраивает.
      </p>
      <h3><a href="Гриды/Раскладка простой страницы 6.html">Раскладка простой страницы: завершение</a></h3>
      <p>
        Остался финальный рывок - зафиксировать размеры четвёртого ряда, на котором будет располагаться подвал. <br>
        Аналогично шапке, подвал растягиваетс на все три столбца, то есть на всю ширину грида. <br>
        На этом раскладка нашей страницы готова!
      </p>
      <h3><a href="Гриды/Раскладка каталога 1.html">Раскладка каталога интернет-магазина: создаём внутренний грид</a></h3>
      <p>
        Мы отлично справились с предыдущими задания, но не время расслабляться. <br>
        Вторым интерфейсом, который мы сверстаем с помощью гридов, будет каталог интернет-магазина. И как в любом каталоге здесь тоже есть: шапка, фильтр, сортировка, ассортимент товаров и подвал. <br>
        Ну, а чтобы вы не заскучали и чтобы открыть вам приём, который удобен в реальных проектах - мы возьмём часть с шапкой и подвала из прошлой страницы и сделаем из неёё каркас. Общему контейнеру дадим класс inner-grid, что обозначает "внутреннюю" страницу. Внутрь поместим отличающийся контент, который будет самостоятльным и независимым блоком, что даёт нам возможность делать исправления, ничего не ломая, или легко заменить его на что-то другое. <br>
        Вот как будет выглядеть итогавая сетка: 
      </p>
      <img src="Гриды/Картинки/24.PNG">
      <p>
        Обратите внимание на исходный код задания: блок .inner-grid содержит три ряда - подвал имеет фиксированный размер, у ряда с шапкой автоматическая высота, как и в прошлом задании, а под контент отводится оставшееся место:
      </p>
      <code>
        .inner-grrid { <br>
          display: grid; <br>
          grid-template-rows: auto auto 100px; <br>
        }
      </code>
      <p>
        В качестве контентной части выступает блок .catalog-grid, который тоже в свою очередь мы сделаем гридом. Один грид будет включён во второй. Магия! <br>
        Начнём, как и в прошлый раз, с создания грида, задания грид-интервалов и объявления трёхколоночной сетки.
      </p>
      <h3><a href="Гриды/Раскладка каталога 2.html">Раскладка каталога интернет-магазина: блок сортировки</a></h3>
      <p>
        Теперь во внутреннем гиде объявим первый ряд, который будет иметь фиксированные размеры. В нём буду располагаться сортировка, занимающая вторую и третью колонку, а также часть фильтра, который также продолжится на следующих рядах.
      </p>
      <h3><a href="Гриды/Раскладка каталога 3.html">Раскладка каталога интернет-магазина: блок с фильтрами</a></h3>
      <p>
        Выглядит наша страничка пока что не очень. А всё потому, что первый ряд ограничен по высоте и это ограничение дествует не только не только на блок с сортировкой, как задумывалось, но и на фильтр, который не должен быть жёстко фиксирован по высоте, так как количество элементов в нём в дальнейшем может меняться. <br>
        Поэтому в качестве рещения сделаем фильтр "немного переменной высоты", привязав её к рядам грида. Сейчас фильтр примерно равен по высоте блоку сортировка + три ряда товаров. То есть, можно сказать, что филтр будет начинаться с первой линии ряда и заканчиваться на пятой линии. <br>
        Текущее решение, конечно, не идеально, и высота элемента всё-таки привязана к контенту, но менее жёстко, чем фиксированная, поэтому нбольшие изменения контента он вполне себе выдержит.
      </p>
      <h3><a href="Гриды/Раскладка каталога 4.html">Раскладка каталога интернет-магазина: завершение</a></h3>
      <p>
        Итак, что мы имеем. Мы прописали минимум свойств для достижения вполне себе приличного результата: размеры столбцов, размер первого ряда и координаты блоков сортировки и фильтра в гриде. Остальные элементы расположились автоматически без использования дополнительного кода. <br>
        Если добавлять дополнительные товары в разметку, то согласно раскладке грида они начнут "заползать" под фильтр и далее занимать все доступные столбцы (очень похоже на поведение float-ов, не правда ли?) <br>
        Надеемся, вы уже догадались за что можно любить гриды? А ведь мы только начинаем своё знакомство с ними.
      </p>
    </main>
    <footer>
      <h3>Здесь могла быть ваша кувшинка</h3>
    </footer>
  </body>
</html>
