<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>Сетки</title>
    <link rel="stylesheet" href="../../стили/Полигон.css" />
  </head>
  <body>
    <header>
      <img
        src="../../avatar/avatar1.jpg"
        width="90"
        height="90"
        alt="Лягушка"
      />
      <nav>
        <a href="../../Полигон.html">Назад</a>
      </nav>
    </header>
    <main>
      <h2>Сетки</h2>
      <h3>
        <a href="Сетки\Управление потоком.html">Пробуем управлять потоком</a>
      </h3>
      <p>
        Поток - это порядок отображения элементов на странице. По умолчанию
        блочные элементы отображаются как прямоугольные области, идущие друг за
        другом сверху вниз, а строчные элементы располагаются сверху вниз и
        слева направо и при необходимости переносятся на новую строку.<br />
        Потоком можно управлять и изменять привычное поведение элементов в
        потоке. Например, можно заставить блочные элементы двигаться не сверху
        вниз, а выстраиваться в несколько колонок.<br />
        Научившись управлять потоком, вы сможете строить сетки.<br />
        В первой серии заданий мы продемонстрируем как один и тот же HTML-код
        можно выстроить в разные потоки
      </p>
      <h3>
        <a href="Сетки/Управление потоком 2.html">Управление потоком, шаг 2</a>
      </h3>
      <p>
        На первом шаге мы с помощью свойства float изменили поведение первого
        блока.<br />
        Обратите внимание, как он стал наезжать на последующие блоки. Это одна
        из особенностей флоатов, которую мы разберём позже.
      </p>
      <h3>
        <a href="Сетки/Управление потоком 3.html">Управление потоком, шаг 3</a>
      </h3>
      <p>
        Со вторым блоком разобрались. Теперь уже первые два блока наезжают на
        третий.<br />
        Чтобы плучить нужный нам поток, остлось задать размеры третьему блоку,
        отцентровать его и избавиться от эффекта "наезжания". <br />
        Поможет нам в этом свойство clear.
      </p>
      <h3><a href="Сетки/Другой поток.html">Создадим другой поток</a></h3>
      <p>
        У нас получилось создать первый поток. Теперь попробуем те же самые
        элементы выстроить по другому.
      </p>
      <h3><a href="Сетки/Другой поток 2.html">Другой поток, шаг 2</a></h3>
      <p>
        А пока мы пошагово создаём второй поток, поговорим о сетках.<br />
        Сетка - это взаимное расположение крупных блоков сайта. Вспомните любой
        сайт, например Вконтакте или HTML Academy<br />
        У ВКонтакте простая сетка, которая состоит из верхней части, или
        "хедера", под которой располагаются две колонки, а в самом низу
        расположен "футер" или нижняя часть сайта. <br />
        У HTML Academy на разных страницах используются разные сетки. Например,
        на главной странице есть двухколончатый хедер, под ним содержание
        страницы в три колонки, затем нижнее меню и двухколончатый футер.<br />
        Как вы понимаете, сетки могут быть самыми разными.
      </p>
      <h3><a href="Сетки/Другой поток 3.html">Другой поток, шаг 3</a></h3>
      <p>Что нужно знать и уметь, чтобы строить сетки? Две вещи:</p>
      <ol>
        <li>Управлять размерами элементов</li>
        <li>Управлять поведением элементов в потоке</li>
      </ol>
      <h3><a href="Сетки/Другой поток 4.html">Другой поток, финал</a></h3>
      <p>Существует несколько способов управлять потоком и строить сетки:</p>
      <ol>
        <li>Флоат</li>
        <li>Инлайн-блоки</li>
        <li>Табличная вёрстка</li>
        <li>Флексбоксы</li>
      </ol>
      <p>
        Табличная вёрстка - самый простой для понимая способ построения сеток.
        Но он считается устаревшим и использовать его не рекомендуется. Сейчас
        уже можно использовать для такой вёрстки не таблицы, а элементы с
        display: table, display: table-row и display: table-cell. <br />
        Флексбоксы - это новая и очнь мощная технология для построения сеток.
        Подробнее разберём её в следующих уроках.<br />
        В этих уроках мы подробно разберём флоаты и инлайн-блоки. Основной упор
        сделаем на флоат, т.к. сейчас на многих сайтах сетки построены на
        них.<br />
        А пока что завершим создание своей второй сетки.
      </p>
      <h3><a href="Сетки/Флоат.html">Погружение во флоаты</a></h3>
      <p>
        А теперь детально разберём свойство float, его значение, особенности
        поведения и способы применения.<br />
        Изначально float было предназначено для того, чтобы включать обтекание
        элементов текстом. Наподобие того, как в более старой версии HTML текст
        обтекал изображение с атрибутами align = "left" или align = "right".<br />
        Т.е., можно сказать, что float - это свойство, включающее режим
        обтекания. Но, как часто бывает, судьба уготовила ему совсем другую
        роль.<br />
        Свойство float имеет следующие значения:
      </p>
      <ol>
        <li>
          left - прижимает элемент к левому краю родителя, другие элементы
          обтекают его справа;
        </li>
        <li>
          right - прижимает элемент к правому краю родителя, другие элементы
          обтекают его слева
        </li>
        <li>
          none - отключает режим обтекания и возвращает элементу нормальное
          поведение
        </li>
      </ol>
      <p>Обратите внимание, что заофлотить элемент по центру нельзя</p>
      <h3><a href="Сетки/Флоат и ширина.html">Float и ширина</a></h3>
      <p>
        Мы уже знаем, что по умолчанию блочные элементы растягиваются на всю
        доступную ширину родителя. <br />
        Если мы задаём элементу свойство float:left или float:right, то он
        прижимается к левому или правому краю, а также начинает ужиматься по
        ширне под своё содержимое. С той стороны, которая не прижата к краю
        родителя, появляется свободное место. Это место может быть занято
        другими элементами.<br />
        Заофлоаченному элементу можно явно задать размеры и отступы. Есть
        тонкость, связанная со строчными элементами. Если заофлоатить сточный
        элемент, то он начинает вести себя как блочный, а именно: воспринимать
        размеры и отступы.
      </p>
      <h3>
        <a href="Сетки/Выпадение из потока.html">float и выпадение из потока</a>
      </h3>
      <p>Зафлоаченные элементы выпадают из потока, но лишь частично:</p>
      <ul>
        <li>
          Блочные элементы, которые идут в коде после зафлоаченного блока,
          перестают его замечать. Они подтягиваются вверх и занимают его место,
          как будто его и нет.
        </li>
        <li>
          Строчные же элементы, расположенные в коде после зафлоаченного блока,
          начинают обтекать его со свободной стороны.
        </li>
      </ul>
      <p>
        Ещё раз: для блочных элементов флоатные не существуют, но текст внутри
        блков флоатные обтекает.<br />
        Такое поведение флоатов даёт интересные эффекты:
      </p>
      <ol>
        <li>
          Эффект прохождения сквозь блоки. Проявляется, когда зафлоаченный
          элемент выше, чем несколько последующих за ним блоков.
        </li>
        <li>
          Эффект выпадения из родителя или схлопывания родителя. Проявляется
          тогда, когда все дочерние блоки в родителе зафлоачены. В этом случае
          родитель схлопывается по высоте, как будто в нём нет содержимого, а
          блоки выпадают из него.
        </li>
      </ol>
      <h3><a href="Сетки/Флоат с флоатом.html">Флоат рядом с флоат</a></h3>
      <p>
        Флоатные элементы становятся невидимыми для блочных элементов и видимыми
        для текста. А как же они взаимодействуют друг с другом?<br />
        Если вкратце то: флоатные элементы видят друго друга.<br />
        Идущие друг за другом флоаты выстраиваются в ряд, пока им хватает
        свободного места. Если места не хватает, то они начинают переноситься на
        следующую строчку. Почти как текст.<br />
        Как раз эта особенность флоатов и позволила применять их для создания
        сеток. Ведь в начале двухтысячных в CSS не было никакого другого способа
        создавать колонки и задавать им размеры.<br />
        Блочные элементы всегда располагались в разных строках. А строчные
        элементы, хоть и могли располагаться на одной строке, совершенно не
        воспринимали размеры. Позиционирование тоже не подходило для сеток,
        т.к.элементы выпадали из потока.<br />
        В общем, флоаты оказались как нельзя кстати для тех, кто решил уходить с
        табличной вёрстки.
      </p>
      <h3>
        <a href="Сетки/Много флоатов.html">Когда флоатов много, а места мало</a>
      </h3>
      <p>
        Следует отметить, что поведение нескольких флоатов, когда им не хватает
        места в одной строке, является очень странным.<br />
        Когда не влезающий флоат переносится на новую строку, возможно несколько
        вариантов и не все из них логичны. Например, флоат может "зацепиться" за
        один из предшествующих флоатов и встать ниже не в самом наале строки, а
        за предшествующим<br />
        В этом упражнении примеры специально подобраны так, чтобы вы увидели
        странности поведения флоатов при недостатке места.<br />
        Естественно, эти особенности повлияли на приёмы использования флоатов в
        создании раскладок (ещё одно название для сеток). Но об этом позже.
      </p>
      <h3><a href="Сетки/clear.html">Свойство clear</a></h3>
      <p>
        Свойство clear запрещает обтекание элемента другими элементами. Вот его
        значения:
      </p>
      <ol>
        <li>left - запрещено обтекать слева</li>
        <li>right - запрещено обтекать справа</li>
        <li>both - запрещено обтекать с обеих сторон</li>
        <li>none - обтекание разрешено</li>
      </ol>
      <p>
        Если после флоатного элемента расположен элемент с запрещённым
        обтеканием, то последний опускается под флоатный. <br />
        Свойство clear учит блочные элементы "видеть" зафлоаченные.
      </p>
      <h3>
        <a href="Сетки/Распорка.html">Борьба с выпадением флоатов: распорки</a>
      </h3>
      <p>
        Эффект выпадения флоатов из родителя был большой проблемой при
        построении сеток. Ведь сетки на флоатах обычно делаются вот так:
      </p>
      <ol>
        <li>Создаём блок-контейнер для колонок.</li>
        <li>В контейнер добавляем флоатные блоки-колонки.</li>
        <li>
          Рассчитываем ширину колонок так, чтобы их хватало места в родителе.
        </li>
      </ol>
      <p>
        Такой подход работает неплохо. Но проблемы начинаются тогда, когда у
        контейнера есть фон, отличающийся от фона страницы. Когда колонки
        выпадали, родитель схлопывался и фон пропадал. <br />
        Необходимо было найти способ борьбы с падением. Тут и пригодилось
        свойство clear:both. Стали применять такую структуру
      </p>
      <code>
        &lt;div class="container"&gt; - блок-контейнер <br />
        &lt;div class="column1"&gt;...&lt;/div&gt; - колонка, флоат <br />
        &lt;div class="column2"&gt;...&lt;/div&gt; - колонка, флоат <br />
        &lt;div class="clearfix"&gt;&lt;/div&gt; - распорка с clear:both <br />
        &lt;/div&gt;
      </code>
      <p>
        Т.е. начали добавлять после зафлоаченных колонок пустой элемент-распорку
        со свойством clear:both. Этот элемент видел колонки, не давал им пройти
        через себя, а заодно и растягивал родительский блок по высоте. <br />
        Для таких распорок прижилось специальное название класса - clearfix.
      </p>
      <h3>
        <a href="Сетки/Псевдораспорка.html"
          >Борьба с выпадением флоатов:псевдораспорка</a
        >
      </h3>
      <p>
        Хорошие верстальщики не очень любят, когда в вёрстке появляются ненужные
        дополнительные элементы и стараются от них избавляться. <br />
        До поры до времени с блоками-распорками приходилось мириться, т.к. без
        них было никак не обойтись. Но время шло и в браузерах появилась
        поддержка так называемых псевдоэлементов. <br />
        Псевдоэлементы позволяют с помощью CSS вставить в структуру
        HTML-документа узлы, которых нет в HTML коде. Т.е. можно вставить в код
        элемент и не писать его в HTML. Благодаря псевдоэлемнтам появилось
        решение проблемы флоатов без использования дополнительного элемента.
        <br />
        Назовём это решение псевдораспорками. Есть несколько его вариаций, но
        вот одна израспространённых. В CSS добавляется следующее правило:
      </p>
      <code>
        .clearfix::after { <br />
        content: ""; <br />
        display: table; <br />
        clear: both; <br />
        }
      </code>
      <p>
        А затем класс clearfix добавляется к контейнеру, внутри которого лежат
        флоатные колонки. После этого в контейнер не нужно добавлять
        дополнительные элемент-распорку, т.к. распорка создаётся с помощью
        псевдоэлемента.
      </p>
      <h3><a href="Сетки/Простая сетка 1.html">Простейшая сетка, шаг 1</a></h3>
      <p>
        Мы разобрали по косточкам свойство float, познакомились с clear и
        научились бороться с некоторыми проблемами флоатов.<br />
        Теерь иы будем практиковаться строить сетки на флоатах. <br />
        И начнём с простейшей сетки "хедер - две колонки - футер". Одна колонка
        будет фиксированной шириной, а вторая будет растягиваться в зависимости
        от ширины контейнера. <br />
        В исходном состонии у нас 4 блока, расположенных друг под другом. Первым
        делом займёмся боковой панелью или "сайдабром": зафлоатим её влево и
        зададим её фиксированную ширину.
      </p>
      <h3><a href="Сетки/Простая сетка 2.html">Простейшая сетка, шаг 2</a></h3>
      <p>
        Мы зафлоатили сайдбар, и он вывалился из контейнера и залез на футер.
        Исправим это с помощью псевдораспорки. <br />
        Вам нужно будет добавить контейнеру колонок класс clearfix. А после
        этого добавить несколько свойств в CSS-правило для всевдораспорки.
      </p>
      <h3><a href="Сетки/Простая сетка 3.html">Простейшая сетка, финал</a></h3>
      <p>
        Поздравляем! Вы победили выпадение. Теперь завершим сетку. <br />
        В почти готовую сетку мы добавили немного текста, чтобы присмотреть как
        она будет себя вести с наполнением. Сейчас видно, что синий блок
        контента частично залез под сайбер. Чтобы избавиться от этого эффекта,
        млжно задать блоку контента маргин слева. <br />
        После этого сетка будет завершена. Кстати, мы получили ещё один
        интересный результат. Мы не зафлоатили блока контента, поэтому он
        тянется на всю ширину родительского контейнера. А фиксированный маргин
        слева предохраняет его от заползания под сайдбар. <br />
        Т.о., у нас получилась сетка из двух колонок, одна из которых
        фиксированная, а вторая тянется. Здесь важно следующее - сайдбар в HTML
        коде должен располагаться до блока контента, иначе такого эффекта не
        получится.
      </p>
      <h3><a href="Сетки/Сложная сетка 1.html">Сетка посложнее, шаг 1</a></h3>
      <p>
        Теперь построим более сложную сетку: двухколонный хедер и контент в три
        колонки. <br />
        На этом шаге создадим сетку хедер. Пока что работаем без содержания.
      </p>
      <h3><a href="Сетки/Сложная сетка 2.html">Сетка посложнее, шаг 2</a></h3>
      <p>
        Обратите внимание на способ именования классов: колонки имеют класс
        layout-column. <br />
        Префикс layout обозначает "сетка" или "раскладка". Т.о. мы даём понять,
        что классы с этим префиксом предназначены для создания сетки. Обычно для
        таких классов задают только флоаты, размеры и внешние отступы. <br />
        Использование значимых префиксов для именования классов - хороший приём.
        Используйте его в своей вёрстке. <br />
        На втором шаге мы создадим колонки содержания.
      </p>
      <h3><a href="Сетки/Сложная сетка 3.html">Сетка посложнее, шаг 3</a></h3>
      <p>
        Теперь нам надо задать отступы между колонками содержания. Сделать это
        просто - добавим маргин справа. <br />
        Но есть небольшая проблема. По макету последняя колонка дожна
        прижиматься к правому краю контейнера. Поэтому нам нужно обнулить маргин
        справа у последней колонки в содержании, иначе она не будет влезать в
        контейнер и перенесётся на следующую строку. <br />
        Чтобы выбрать последнюю колонку, мы можем использовать псевдокласс
        :last-child.
      </p>
      <h3>Сетка посложнее, добавляем содержание (нет)</h3>
      <p>
        Обратите внимание ещё на один подход построения сеток. Он заключается в
        том, что блокам разметки задаются только размеры и внешние отступы.
        Внутренние же отступы добавляются дополнительным элементам, вложенным в
        ячейки сетки. <br />
        Такой подход упрощает расчёт сеток. Как вы помните, блочная модель
        устроена таким образом, что общий размер элемента складывается из
        ширины/высоты, маргинов и паддингов, а также ширины рамок. Поэтому,
        чтобы получить правильные размеры блоков сетки, всегд нужно помнить об
        этом. Если же блокам сетки задавать только ширину и внешние отступы, то
        слагаемых становится намного меньге, а шанс совершить ошибку
        уменьшается. <br />
        Сайта с примером не будет, т.к. в уроке эту сетку просто наполнили
        содержанием
      </p>
      <h3><a href="Сетки/Последняя сетка 1.html">Последняя сетка, шаг 1</a></h3>
      <p>
        На самом деле это прошлая сетка, но мы немного её усложним. Мы будем
        делать сетку, у которой он хедера и футера растягивается на всю ширину
        окна браузера. <br />
        Сначала нам нужно изменить HTML-разметку. Мы избавимся от блока wrapper,
        который центрирует всё содержание страницы. <br />
        Затем нужно будет добавить внутрь хедера, контента и футера
        дополнительный бок, который будет центрировать их содержание. Вот так:
      </p>
      <code>
        &lt;div class="header clearfix"&gt; <br />
        &lt;div class="layout-positioner"&gt; <br />
        &lt;!-- блоки колонок --&gt; <br />
        &lt;/div&gt; <br />
        &lt;/div&gt;
      </code>
      <h3><a href="Сетки/Последняя сетка 2.html">Последняя сетка, шаг 2</a></h3>
      <p>
        Блоки с классом layout-positioner добавлены в код. Это невидимые
        блоки-центровщики. Теперь хедер и футер могут тянуться на всю ширину
        окна, а их содержимое будет отцентровано с помощью добавленных блоков.
        <br />
        Мы задали голубую рамку для центровщиков, чтобы было видно, как они себя
        ведут. Также мы добавили им псевдораспоркт, поэтому можно удалитьб класс
        clearfix из HTML кода. <br />
        И ещё одна мелочь: класс wrapper уже нигде не используется, прэтому он
        удалён из CSS. Класс clearfix мы оставили в CSS, т.к. это
        вспомогательный класс, который может пригодиться при вёрстке. <br />
        На этом шаге наша задача - отцентрировать цетровщики.
      </p>
      <h3>Последняя сетка завершена</h3>
      <p>
        Приём с дополнительными блоками, которые позиционируют содержаниме,
        чтобы родительские блоки могли тянуться на всю ширину окна, достаточно
        распространён. Дизайн с подобными сетками тоже встречается очень часто.
        <br />
        Сайта с примеро снова не будет, причина та же - в уроке просто добавили
        контент.
      </p>
      <h3><a href="Сетки/inline-block.html">Погружение в inline-block</a></h3>
      <p>
        С бочно-строчными элементами мы уже знакомились. Напомним, что это
        элементы, у которых свойство display имеет значение inline-block. <br />
        Блочно-строчные элементы ведут себя двояко. Снаружи они выглядят как
        обычные строчные, но внутри они ведут себя как блочные. <br />
        От строчных им достались следующие черты:
      </p>
      <ul>
        <li>По ширине они ужимаются под своё содержимое</li>
        <li>Могут располагаться в одну строку</li>
        <li>Реагируют на вертикальное выравнивание, vertical-align</li>
        <li>
          Реагируют на горизонтальное выравнивание, text-align, заданное у
          родителя.
        </li>
      </ul>
      <p>От блочных:</p>
      <ul>
        <li>Им можно задавать размеры с помощью width и height</li>
        <li>
          А также внешние и внутренние отступы и рамки, которые работают во всех
          направлниях и увеличивают размер элемента.
        </li>
      </ul>
      <h3>
        <a href="Сетки/float vs inline-block.html">Float vs inline-block</a>
      </h3>
      <p>
        Блочно-строчные элементы могут выстраиваться друг за другом, а если не
        хватает места, то они переносятся на следующую строку. <br />
        Поведение похоже на флоатные элементы, однако, есть существенное
        отличие. <br />
        При переносе на следующую строку блочно-строчные ведут себя намного
        логичней. Высота строк у их рассчитывается по максимальному элементу с
        учётом отспуов. <br />
        Это упражнение создано, чтобы продемнстрировать отличие в поведении
        флоатов и инлайн-блоков. В исходном состоянии мы видим несколько
        флоатных блоков, которые не смогли выстроиться в ряды, т.к. зацепились
        друг за друга. <br />
        Мы изменим тип блокаов на блочно-строчные и сами всё увидим, насколько
        ведут себя инлайн-блоки.
      </p>
      <h3>
        <a href="Сетки/Сетка на inline-block.html"
          >Простая сетка на inline-block</a
        >
      </h3>
      <p>
        Блочно-строчные элементы очень часто используют для создания
        декоративных элементов: кнопок, плашек, блочков. Также благодаря их
        умному поведению с их помощью создают различные списки товаров в
        каталогах. <br />
        Для создания сеток страниц эти элементы используются реже. Первая
        причина заключается в том, что их не поддердивают старые браузеры. А
        сетка страницы - слишком критичная вещь, чтобы позволять ей ломаться
        даже в старых браузерах. <br />
        Есть и ещё одна проблема, с которой мы столкнёмся в этом задании. Мы
        построим сетку, когда у нас края товаров вплотную прилегают к краям
        контейнера. <br />
        Ширина контейнера 400px, ширина товара с рамками 120px, отступ между
        товарами 20px. Чтобы три товара влезали в строку "пиксель-в-пиксель",
        нужно у каждого третьего товара (т.к. в строку помещается только 3
        товара) обнулить отступ справа. Используем для этого селектор
        .item:nth-child (3n)
      </p>
      <h3>
        <a href="Сетки/inline-block и проблема.html"
          >inline-block и проблемы в коде</a
        >
      </h3>
      <p>
        Мы расчитали всё правильно, однако по три товара в строку не помещается.
        <br />
        Причина заключается в пробелах после тегов в HTML-коде. Блочно-строчные
        ведут себя как текст, поэтому если в коде есть пробел между элементами,
        то он отображается и на странице. Этот пробел увеличивает отступы между
        товарами, не давая поместиться в одну строку. <br />
        Бороться с пробелом после блочно-строчных можно несколькими способами:
      </p>
      <ul>
        <li>Удалять пробелы в коде</li>
        <li>Обнулять размеры шрифта</li>
        <li>Играться с маргинами после блочно-строчного.</li>
      </ul>
      <p>
        У каждого из способов есть свои недостатки. <br />
        Мы попробуем два способа. <br />
        Способ со шрифтом заключается в том, что мы задаём нулевой размер шрифта
        у контейнера инлайн-блоков, а самим инлайн-блокам задаём исходный размер
        шрифта. Способ не работает, если вы спользуете относительные размеры
        шрифта. <br />
        Способ с маргинами заключается в том, что мы уменьшаем отступ после
        инлайн-блока на ширину пробела, около 4-5px. А если нам нужно, чтобы
        элементы стояли вплотную друг к другу, то задаём отрицательный отступ.
        Проблема с этим способом заключается в том, что размер пробела может
        быть разным в разных шрифтах и может изменяться при изменении размера
        шрифта.
      </p>
    </main>
    <footer>
      <h3>Здесь могла быть ваша кувшинка</h3>
    </footer>
  </body>
</html>
