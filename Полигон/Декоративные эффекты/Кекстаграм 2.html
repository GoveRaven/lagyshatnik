<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>Кекстаграм. JavaScript</title>
    <link rel="stylesheet" href="../../стили/Полигон.css" />
  </head>
  <body>
    <header>
      <img src="../../avatar/avatar1.jpg" width="90" height="90" alt="Лягушка" />
      <nav>
        <a href="../../Полигон.html">Назад</a>
        <a href="Кекстаграм 2/Кекстаграм.html">Кекстаграм</a>
      </nav>
    </header>
    <main>
      <h2>Кекстаграм. JavaScript</h2>
      <h3>Разметка</h3>
      <p>Теперь мы знаме о фильтрах достаточно, чтобы посмтроить Кекстаграм с помощью HTML, CSS и JavaScript.</p>
      <p>В процессе ы создадим несколько фильтров, которые будут применяться к фотографии в блоке <span>.photo</span>. Переключатели фильтров мы разместим в блоке <span>.toogle-controls</span>, а само переключение будет работать на JavaScript.</p>
      <p>Сначала подготовим разметку для нашего будущего фотоприложения.</p>
      <h3>Первый фильтр</h3>
      <p>Теперь давайте создадим первый набор фильтров для класса <span>.walden</span>. Набор фильтров применится к большому фото и к переключателю.</p>
      <p>Итоговый фильтр сымитирует у фотографии цвета фотоплёнки: немного сдвинет их по цветовому кругу, сделает фото чуть ярче и насыщенее, а также немного умменьшит контрастность.</p>
      <h3>Репетируем переключение</h3>
      <p>Отлично, у нас есть первый фильтр и первый переключатель.</p>
      <p>Давайте добавим заготовку для ещё одного переключателя. Класс для второго фильтра будет называться <span>toaster</span>.</p>
      <p>Затем "отрепетируем" переключение фильтра без использования JavaScript. Для этого пока будем менять HTML-код вручную. При переключении фильтра происходят два события:</p>
      <p><i>Первое.</i> В переключателе класс <span>active</span> перемещается на текущий фильтр:</p>
      <code>
        Было: <br>
        &lt;div class="toogle-controls"&gt; <br>
        &lt;button class="filter1 <b>active</b>" type="button"&gt;&lt;/button&gt; <br>
        &lt;button class="filter2" type="button"&gt;&lt;/button&gt; <br>
        &lt;/div&gt; <br> <br>
        Стало: <br>
        &lt;div class="toogle-controls"&gt; <br>
        &lt;button class="filter1" type="button"&gt;&lt;/button&gt;<br>
        &lt;button class="filter2 <b>active</b>" type="button"&gt;&lt;/button&gt; <br>
        &lt;/div&gt;
      </code>
      <p><i>Второе.</i>У блока с большим фото меняется класс текущего фильтра:</p>
      <code>
        Было: &lt;div class="photo <b>filter1</b>"&gt;&lt;/div&gt; <br>
        Стало: &lt;div class="photo <b>filter2</b>"&gt;&lt;/div&gt; <br>
      </code>
      <h3>Второй фильтр</h3>
      <p>Мы "переключили" текущий фильтр, а чтобы увидеть его эффект, зададим его стили.</p>
      <p>Этот фильтр будет делать фото ещё винтаажнее, чем <span>walden</span>: сделает его малоконстаным с яркими цветами, небольшим поворотом по цветовому кругу и эффектом сепии.</p>
      <h3>Наконец-то JavaScript</h3>
      <p>Всё готово для "оживления" интерфейса с помощью JavaScript. HTML-код Кекстаграма приведён в исходное состояние: фильтр ещё не выбран и к фото не применён.</p>
      <p>Сначала включим фильтр <span>toaster</span> и применим его к фотографии. Для этого:</p>
      <p>1. Найдём кнопку с классом <span>toaster</span> и сохраним её в переменную <span>control</span>:</p>
      <code>
        let control = document.querySelector('button.toaster');
      </code>
      <p>2. Найдём блок с фотографией с классом <span>photo</span> и сохраним его в переменную <span>photo</span>.</p>
      <code>
        let photo = document.querySelector('.photo');
      </code>
      <p>3. Теперь к кнопке, хранящейся в переменной <span>control</span>, добавим класс <span>active</span>.</p>
      <code>
        control.classList.add('active');
      </code>
      <p>4. А к блоку большой фотографии, она уже в перменной <span>photo</span>, добавим класс <span>toaster</span>:</p>
      <code>
        photo.classList.add('toaster')
      </code>
      <p>Обратите внимание, что при добавлении класса с помощью <span>classList.add</span> точка в начале строки не пишется.</p>
      <h3>Играем с классами</h3>
      <p>На предыдущем шаге мы "включили" фильтр <span>toaster</span> из исходного состояния, а сейчас переключим его на <span>walden</span>. Для этого:</p>
      <p>1. Снова найдём кнопку с классом <span>toaster</span>, сохраним её в переменную <span>toasterControl</span> и удалим у неё класс <span>active</span>, добавленный ранее:</p>
      <code>
        let toasterControl = document.querySelector('button.toaster'); <br>
        toasterControl.classList.remove('active');
      </code>
      <p>2. Найдём кнопку с классом <span>walden</span>, сохраним её в переменную <span>waldenControl</span> и добавим ей класс <span>active</span>:</p>
      <code>
        let waldenControl = document.querySelector('button.walden');
        waldenControl.classList.add('active')
      </code>
      <p>3. Найдём элемент с классом <span>photo</span> и сохраним его в переменную <span>photo</span>:</p>
      <code>let photo = document.querySelector('.photo')</code>
      <p>4. Удалим у фото класс <span>toaster</span> и добавим класс <span>walden</span>:</p>
      <code>
        photo.classList.remove('toaster'); <br>
        photo.classList.add('walden');
      </code>
      <h3>Расшифровка кода</h3>
      <p>Разберёмся подробнее в том коде, который мы написали. Вот один из фрагментов</p>
      <code>
        let toasterControl = document.querySelector("button.toaster"); <br>
        if (toasterControl) { <br>
        toasterControl.classList.remove("active"); <br>
        }
      </code>
      <p><span>let toasterControl</span> - объявления переменной.</p>
      <p><span>document</span> - это специальная переменная, в которой хранится корневой элемент HTML-документа. <span>querySelector</span> - это <i>метод</i> документа, который по указанному селектору ищет и возвращает первый найденный элемент, подходящий под селектор.</p>
      <p>У элементов, которые мы находим с помощью <span>querySelector</span>, есть свойство <span>classList</span>, в котором хранится список классов элемента.</p>
      <p>Теперь немного отдохнём от JavaScript и создадим ещё один фильтр.</p>
      <h3>Третий фильтр</h3>
      <p>Теперь для класса <span>.kelvin</span> создадим набор фильтров. Эти фильтры будут делать фотографию более контрастной, яркой, насыщенной, а также добавлять ей небольшой оттенок сепии.</p>
      <p>Такой фильтр оживит любую блёклую фотографию, а сепия добавит эффект фотоплёнки.</p>
      <h3>Строки и переменные</h3>
      <p>Вернёмся к JavaScript и немного улучшим наш код. Посомтрите эти строчки:</p>
      <code>
        let Control = document.querySelector("button.toaster");
        photo.classList.add("toaster");
      </code>
      <p>Название фиьтра <span>toaster</span> в коде повторяется два раза. Чтобы "переключить" фильтр, придётяс поменять код в двух местах. А это лишняя работа!</p>
      <p>Избавимся от дублирования. В начале кода создадим переменную с названием фильтра:</p>
      <code>let filterName='toaster';</code>
      <p>В метод поиска элементов мы передаём строку <span>button.toaster</span>. Чтобы получить такую же строку из переменной, воспользуемся операцией "склеивания" строк:</p>
      <code>'button.' + filterName // результаа: 'button.toaster'</code>
      <p>В коде для поиска переключателя заменим строку на выражение с переменой:</p>
      <code>
        Было: let control = document.querySelector('button.toaster'); <br>
        Стало: let control = document.querySelector('button.' + filterName);
      </code>
      <p>Внутри <span>photo.classList.add</span> находится такое же значение, как и в переменной, поэтому просто заменяем строку на переменную:</p>
      <code>
        Было: photo.classList.add('toaster'); <br>
        Стало: photo.classList.add(filterName);
      </code>
      <h3>Используем функцию</h3>
      <p>Продолжим улучшать наш JavaScript. Теперь упакуем весь код, отвечающий за переключение фильтров, в функцию. Это позволит проще его использовать и изменять.</p>
      <p>В этом коде мы создадим функцию для суммирования чисел и именем <span>sum</span>:</p>
      <code>
        // Определение функции <br>
        function sum (a, b) { <br>
          return a + b; <br>
        } <br>
        <br>
        sum (1, 5); // Вызов функции. Результат выполнения: 6.
      </code>
      <p>Обернём наш код для переключения фильтров в функцию <span>toogleFilter</span>, у которой будет один параметр - <span>filterName</span>. А затем вызовем функцию с разными названиями фильтра в качестве параметра.</p>
      <p>Кстати, переменная <span>filterName</span> нам больше не нужна, так как название фильтра передаётся в функцию в параметре с таким же именем, поэтому в коде создания переменной закомментировано</p>
      <h3>Эксперементируем с вызовом функции.</h3>
      <p>Мы сздали функцию, но она ещё требует серьёзной доработки. Сейча мы в этом убедимся.</p>
      <p>На первый взгляд функция работает правильно. Но только при одном переключении фильтра, когда мы запускаем функцию только один раз. Ведт при каждом обновлении кода страница в браузере обновляется целиком. Поэтому при первом запуске мы имеем дело с "чистым" исходным состоянием.</p>
      <p>Если же вызвать созданную функцию несколько раз подряд с разными параметрами:</p>
      <code>
        toogleFilter('toaster'); <br>
        toogleFilter('kelvin');
      </code>
      <p>То активным станут сразу несколько переключателей, а к фотографии применятся несколько фильтров одновременно.</p>
      <h3>Добавляем data-атрибуты</h3>
      <p>У HTML-элементов есть возмоность создавать специальные атрибуты, в которых можно хранить вспомогательную информацию и легко передавать её в JavaScript. Такие атрибуты начинатся с префикса <span>data-</span></p>
      <p>При этом data-атрибуты валидны и никак не влияют на отображения элементов в браузере</p>
      <p>Давайте добавим переключатеям data-атрибуты <span>data-filter</span>, в которых будем хранить название каждого фильтра</p>
      <h3>Используем data-атрибуты</h3>
      <p>Чтобы с помощью JavaScript считать значения data-атрибутов, нужно испоьзовать свойство <span>dataset</span>. Пример:</p>
      <code>
        HTML: <br>
        &lt;div class='control' data-filtername='walden'&gt;&lt;/div&gt; <br>
        <br>
        JavaScript: <br>
        let control = document.querySelector(.control); <br>
        let filter = control.dataset.filtername; <br>
        // в переменной filter тепеь строка 'walden'
      </code>
      <p>В свойстве <span>dataset</span> HTML-элемента хранятся все значения его data-атрибутов. Обратиться к ним можно по названию data-атрибута, удалив из названия приставку <span>data-</span>.</p>
      <p>Добавляем содержимое в HTML-элемент через JavaScript можно с помощью свойства <span>innerHTML</span>.</p>
      <code>
        let control = document.querySelector('.control'); <br>
        control.innerHTML = 'walden'; 
      </code>
      <p>Присвоенная свойству <span>innerHTML</span> строка заменяет всё содержимое HTML-элемент. В этой строке можно использовать любой HTML-код.</p>
      <p>Двайте попробуем получить значение data-атрибута из JavaScript и записать полученную строку в переключатель.</p>
      <h3>Знакомимся с циклом</h3>
      <p>Если нужно совершить несколько однотипных действий, то можно использовать цикл <span>for</span>. Вот его синтаксис:</p>
      <code>
        for (let num = 0; num &lt;=5; num++) { <br>
          console.log(num); <br>
        } <br>
        // Выведет в "консоль" числа 0, 1, 2, 3, 4 и 5
      </code>
      <p>Ранее мы использовали метод <span>querySelector</span>, который возвращает только один элемент: первый элемент, соответствующий селектору. Другой метод <span>querySelectorAll</span> возвращает все элементы, соответсвующий селектору.</p>
      <p>С помощью <span>for</span> удобно перебирать найденные элементы:</p>
      <code>
        let controls = document.querySelectorAll('.toogle-contols button'); <br>
        for (let i = 0; i &lt; controls.length; i++) { <br>
          controls[i].innerHTML = 'переключатель'; <br> 
        }
      </code>
      <p>В Кекстаграме может быть много фильтров, еоличетво и названия которых мы можем не знать. Поэтому нельзя искать каждый переключатель по его классу и задавать его название.</p>
      <p>Лучше найти все переключатели внутри списка и перебрать их с помощью цикла. И внутри цикла задавать название каждому переключателю.</p>
      <h3>Используем цикл</h3>
      <p>Начнём исправлять ошибк в функции переключения фильтров, которые возникают, когда она запускается несколько раз</p>
      <p>Первая ошибка заключается в том, что все переключатели подсвечиваютяс как активные. Причина в том, что внутри функции класс <span>active</span> добавляется текущему переключателю, но не удаляется у ставших неактивными.</p>
      <p>Простейшим решением проблемы будет сначала удалять класс <span>active</span> у всех переключателей, а затем добавлять его текущему.</p>
      <p>На предыдущем шаге мы уже находили все переключатели и сохраняли их в переменную <span>conrols</span>.</p>
      <code>let controls = document.querySelectorAll('.toogle-contols button'); </code>
      <p>Теперь мы можем использовать эту переменную внутри функции - добавить в начало функции ещё один цикл, который пройдётся по всем переключателям и удалит у них класс.</p>
      <h3>Завершаем функцию переключения.</h3>
      <p>Ошибку с выделением активного переключателя исправили. Осталось вторая ошибка: фильтр на большой фотографии примняется неправильно. Причина - лишние классы фильтров у большой фотографии. Вот что происходит с HTMLL, когда функция переключаения вызывается несколько раз:</p>
      <code>
        &lt;div class="whoto  walden toaster kelvin"&gt;&lt;/div&gt;
      </code>
      <p>Чтобы исправить ошибку, надо удалять классы фильтров у блока фотографи при каждо переключении. Но класс <span>photo</span> удалять нельзя. Классы фильтров мы знаем, ведь они хранятся в data-атрибутах переключателей.</p>
      <p>Поэтому в том же цикле, где сбрасывается класс <span>active</span>, можно у каждого переключателя брать название фильтра и удалять этот класс у большого фото:</p>
      <code>
        for (let j=0; j &lt; controls.length; j++) { <br>
          ... <br>
          photo.classList.remove(имя фильтра из dataset-атрибута переключателя); <br>
        }
      </code>
      <p>И ещё одна важнаяя деталь. Переменная <span>photo</span> теперь используется в самом начале функции, поэтому мы вынесем строчку поиска переменной из функции в самый верх кода:</p>
      <code>
        let controls = document.querySelectorAll(".toggle-controls button"); <br>
        let photo = document.querySelector(".photo");
      </code>
      <p>А внутри функции переменную <span>photo</span> надо удалить. Заодно мы ускорим работу скрипта, избавившись от ненужного поиска элемента .photo, который происходит при каждом переключении фильтра</p>
      <h3>Программируем переключатели, часть 1</h3>
      <p>В предыдущих шагах мы подготовили функцию для переключения фильтров и запускали её из JavaScript-кода. Сейчас мы сделаем так, чтобы пользователь сам мог енять фильтры, щёлкая по переключателям мышкой.</p>
      <p>Для этого нам нужно научиться отслеживать и обрабатывать события, которые происходят на веб-странице. Для этого в JavaScript, существует метод <span>addEventListener</span>:</p>
      <code>
        let toaster = document.querySelector('button.toaster'); <br>
        toaster.addEventListener('click', function() { <br>
          toogleFilter(toaster.dataset.filter); <br>
        })
      </code>
      <p>В этом фрагменте кода мы сделали следующее:</p>
      <ol>
        <li>Нашли элемент списка и у него вызвали метод <span>addEventListener</span>.</li>
        <li>Указал отслеживать событие <span>click</span> или 'щелчок мыши'.</li>
        <li>Для щелчков указали функцию-обработчик без названия, внутри которой вызвали функцию переключения фильтров.</li>
      </ol>
      <p>Метод <span>addEventListener</span> был вызван у одного элемента, поэтому будут обрабатываться события только этого элемента. Первый параметр задаёт тип события, второй функцию-обработчик.</p>
      <h3>Программируем переключатели, часть 2</h3>
      <p>Мы добавили обработку клика для одного переключателя. Не забываем, что переключателей может быть много, их количество и названия наперёд мы знать не можем</p>
      <p>Поэтому, чтобы обрабатывать щелчки по всем переключателям, лучше воспользоваться циклом. Тем более, что цикл по всем переключателям у нас уже есть.</p>
      <p>А чтобы сократить код в цикле, создадим новую функцию:</p>
      <code>
        function cliclControl(control) { <br>
          control.addEventListener('click', function(){ <br>
            toggleFilter(control.dataset.filter); <br>
          }); <br>
        }
      </code>
      <p>Функция <span>clickControl</span> принимает найденный элемент и добавляет ему обработчик щелчков мыши, в котором вызывается функция переключения фильтра. Название фильтра для функциии переключения берётся из data-атрибута самого элемента.</p>
      <p>Благодаря <span>clickControl</span> нам нужно добавить только одну строчку в цикл, чтобы все переключатели заработали:</p>
      <code>
        for (let i=; 0 &lt; controls.length; i++) { <br>
          ... <br>
          clickControl(controls[i]); <br>
        }
      </code>
      <h3>Завершаем переключатели</h3>
      <p>И снова код. В функции переключатения есть проблема: в качестве параметра используются названия фильтра, по которому каждый раз происходит поиск переключателя. Но ведь можно передавать в функцию сами переключатели. Для этого.</p>
      <p>1. Изменим обработчик внутри <span>clickControl</span>:</p>
      <code>
        Было: toogleFilter(control.dataset.filter); <br>
        Стало: toogleFilter(control);
      </code>
      <p>2. Изменим параметр у <span>toogleFilter</span>, теперь это не строка, а элемент:</p>
      <code>
        Было: function toogleFilter(filterName) <br>
        Стало: function toogleFilter(control)
      </code>
      <p>3. В <span>toogleFilter</span> передаётя переключатель и искать его уже не надо, удаялем лишний код</p>
      <code>
        <s>let control = document.querySelector('button.' + filterName); if (control) {</s> <br>
          control.classList.add('active'); <br>
          <s>}</s>
      </code>
      <p>4. Название фильтра для фото теперь берём из data-атрибута переключателя:</p>
      <code>
        Было: photo.classList.add(filterName); <br>
        Стало: photo.classList.add(control.dataset.filter)
      </code>
      <p>А теперь последний штрих. При загрузке страницы должен быть выбран фильтр по умолчанию. Для этого нужно в конце кода добавить новую переменну, сохранить в неёё нужный переключатель и с этой переменной вызвать функцию переключения.</p>
      <h3>Сравнение фото</h3>
      <p>Итак, приложение работает! по нажатию на переключатели меняются фильтры.</p>
      <p>В последней серии заданий мы добавим озможность сравнивать изображения с фильтром и без фильтра.</p>
      <p>Сначала добавим блок с оригинальной фотографией. У этого блока будут такие же размеры, координаты и фотографи на фоне, что и у блока с фльтром. Но оригинал будет расположен над 'фильтрованным' фото.</p>
      <h3>Ползунок-разделитель</h3>
      <p>Теперь нам нужен специальный ползунок-разделитель на границе двух фотографий.</p>
      <p>С помощью этого ползунка мы будем изменять ширину фотографии-оригинала, чтобы сравнивать азные части изображений.</p>
      <p>Ползунок мы разместим в том же блоке, что и фотографии, спозиционируем его абсолютно и зададим коордианаты такм образом, чтобы с помощью JavaScript было удобно его перемещать.</p>
      <p>По умолчанию ползунок будет находиться в центре блока с фото. Для центровки мы применим приём с трансформацией перемещения.</p>
      <h3>Двигаем ползунок</h3>
      <p>Разберём механику "перемещения" разделителя с помощью JavaScript. Чтобы получить этот эффект, нужно изменять стили двух элементов:</p>
      <ol>
        <li>Менять левую координату ползунка-разделителя, чтобы он двигаля право или влево.</li>
        <li>Менять ширину блока с изображением-оригиналом так, чтобы граница фотографий оставалась под ползунком.</li>
      </ol>
      <p>К счастью, мы подготовили очень удобную вёрстку, в которой начало координат у обоих блоков совпадает. Поэтому достаточно задават одинаковые значения для левой координаты разделителя и ширины блока с оригиналом фото.</p>
      <p>Чтобы изменит CSS-свойства элемента в скрипте, нужно обратиться к свойству <span>style</span> элемента. Например:</p>
      <code>
        let element = document.querySelector('.photo-original'); <br>
        element.style.width = '10px'
      </code>
      <p>В коде элементу задаётся ширина <span>10px</span>.</p>
      <p>С помощью <span>element.style</span> можно и получать, и изменять значения свойств.</p>
      <p>Но название свойства в JavaScript не всегда совпадают с их названиями в CSS. Например, CSS-свойство <span>left</span> совпадает с <span>style.left</span>, но CSS-свойство <span>background-color</span> уже отличается: <span>style.backgroundColor</span>.</p>
      <h3>Четвёртый фильтр</h3>
      <p>Давайте создадим ещё один набор фильтров для большой фотографии. Он будет называться <span>oldie</span>.</p>
      <h3>Четвёртый фильтр, завершение</h3>
      <p>Теперь для класса <span>.oldie</span> создадим набор фильтров.</p>
      <p>Эти фильтры сделают фотографию слегка "сумашедшей".</p>
      <h3>Финал</h3>
      <p>Чтобы пользователь мог самостоятельно перемещать разделитель с помощью мыши, нужно добавит обработку событий перетягивания. Это достаточно сложная задача, которую мы будем рассматривать в одном из последующих курсов.</p>
      <p>А сейчас мы подготовили скрипт, в котром перетягивание уже реализовано.</p>
    </main>
    <footer>
      <h3>Здесь могла быть ваша кувшинка</h3>
    </footer>
  </body>
</html>
