<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>Двумерные трансформации</title>
    <link rel="stylesheet" href="../../стили/Полигон.css" />
  </head>
  <body>
    <header>
      <img src="../../avatar/avatar1.jpg" width="90" height="90" alt="Лягушка" />
      <nav>
        <a href="../../Полигон.html">Назад</a>
      </nav>
    </header>
    <main>
      <h2>Двумерные трансформации</h2>
      <h3>
        <a href="Двумерная трансформация/По горизонтали.html"
          >Перемещение по горизонтали</a
        >
      </h3>
      <p>
        В этой главн мы рассмотрим возможности двухмерных трансформаций в CSS.
      </p>
      <p>
        То, что раньше можно было сделать в окне браузера только с помощью
        JavaScript - плавное перемещение и маштабирование блоков, повороты и
        наклоны - тепперь с лёгкостью реализуется на чистом CSS.
      </p>
      <p>
        Для начала давайте разберёмся с системой кординат, в которой
        перемещается объект:
      </p>
      <img src="Двумерная трансформация/Картинки/1.PNG" />
      <p>
        Её ключевой особенностью является то, что ось Y направлена вниз, а не
        вверх, так как веб-страница начинается с левого верхнего угла и идёт
        вниз, а в CSS используетсяс обратная система координат
      </p>
      <p>
        Первое перемещение, которое мы осуществим - горизонтальное. Мы будем
        двигать объекты влево и вправо
      </p>
      <p>Для этой и других трансформаций используется следующий синтаксис:</p>
      <code>transform: функция трансформации (значение трансформации)</code>
      <p>
        Горизонтальное перемещение осуществляется функцией
        <span>translateX</span>. Значение функции трансформации численное, а
        возможные единицы измерения - <span>px, %, em, in</span>. Например,
        такая функция переместит объект на 100 пикселей вправо по оси X:
      </p>
      <code>transform: translateX(100px)</code>
      <h3>
        <a href="Двумерная трансформация/По вертикали.html"
          >Пермещение по вертикали</a
        >
      </h3>
      <p>Теперь давайте попробуем перемещать объекты по вртикали.</p>
      <p>
        Для этого воспользуемся похожей на "горизонтальную" функицей
        <span>translateY</span>.
      </p>
      <code>transform: translateY(-100px)</code>
      <p>
        Такая функция переместит объект на 100 пикселей вертикально вверх.
        Заметьте, что для движения вверх используется отрицательное значение
        трансформации.
      </p>
      <p>
        Как вы уж увидели в предыдущем задании, к объекту может быть
        одновременно применено несколько функций трансформации. При этом функции
        просто перечисляются через пробел после имени свойства
        <span>transform</span>, например:
      </p>
      <code>transform: translateY(-100px) translateX(100px)</code>
      <p>
        Такая трансформация переместит объект на 100 пикселей право и вверх по
        оси координат.
      </p>
      <h3><a href="Двумерная трансформация/Тренировка.html">Тренировка</a></h3>
      <p>
        Сейчас потренируемся использовать <span>translateX</span> и
        <span>translateY</span>, а также новое более лаконичную функцию,
        объединяющее перемещение сразу по двум осям - <span>translate</span>
      </p>
      <code
        >transform: translate(перемещение по оси X[, перемещение по оси
        Y])</code
      >
      <p>
        Квадратные скобки указывают на то, что значение перемещения по оси Y
        является необязательным аргументом. В коде квадратные скобки писать не
        нужно, два значения просто перечисляются через запятую, причём у них
        могут быть разные единицы измерения. Если не указать значение
        перемещения по оси Y, а написать
        <span>translate(перемещение по оси Х)</span>, то значение перемещения по
        Y будет считаться равным 0 и функция будет работать аналогично
        <span>translateX</span>
      </p>
      <code
        >//Эти функции работают одинаково: <br />
        tranform: translate(100px) <br />
        tranform: translate(100px, 0) <br />
        transform: translateX(100px)</code
      >
      <h3>
        <a href="Двумерная трансформация/scale.html">Увеличение, уменьшение</a>
      </h3>
      <p>
        Ещё одной возможностью CSS-трансформацией является масштабирование
        блоков. С помощью функции scale можно увеличивать или уменьшать
        элементы.
      </p>
      <p>
        Значением этой функции может быть любое число. При этом значении
        <span>1</span> считается точкой отсчёта, когда блок имеет оригинальные
        размеры. Рассмотрим примеры:
      </p>
      <ul>
        <li><span>scale(0.5)</span> уменьшит объект в 2 раза;</li>
        <li><span>scale(2)</span> увеличит объект в 2 раза;</li>
        <li>
          <span>scale(1)</span> полностью "схлопнет" объект, и его не будет
          видно;
        </li>
        <li><span>scale(1)</span> оставит объект без изменений.</li>
      </ul>
      <img src="Двумерная трансформация/Картинки/4.PNG" />
      <p>
        Вообще функция <span>scale</span>, как и <span>translate</span>,
        принимает 2 аргумента:
      </p>
      <code>scale(масштаб-по-Х[, масштаб-по-Y]</code>
      <p>
        Если необязательный аргумент <span>масштаб-по-Y</span> не задан, то
        считается, что он такой же, как <span>масштаб-по-X</span>
      </p>
      <code>transform: scale(2) то же самое, что transform: scale(2,2)</code>
      <p>
        Также в случае, когда необходимо масштабировать объект только по одной
        оси независимо от другой, существуют функции
        <span>scaleX(масштаб-по-X)</span> и <span>scaleY(масштаб-по-Y)</span>
      </p>
      <h3><a href="Двумерная трансформация/rotate.html">Rotate</a></h3>
      <p>
        В этом задании нам понадобится с функцией поворота
        <span>tranform: rotate</span>. Её синтаксис:
        <span>transform: rotate(угол наклона)</span>.
      </p>
      <p>
        Положительное значение угла поеврнёт объект по часовой стрелке, а
        отрицательное - против. Единица измерения поворота - градусы
        <span>deg</span>, например:
        <span>transform: rotate(180deg)</span> повернёт объект на
        <span>180</span> по часовой стрелке, то есть перевернёт его.
      </p>
      <p>
        При совместном применении транформации поворота и перемещения есть
        небольшая тонкость. При повороте вместе с объектом на заданный угол
        поворачивается и вся его система координат:
      </p>
      <img src="Двумерная трансформация/Картинки/5.PNG" />
      <p>
        То есть, что перевернутый блок двигать по горизонтали, нужно применять
        <span>translateY</span>, а по вертикали - <span>translateX</span>
      </p>
      <h3><a href="Двумерная трансформация/skew.html">ScewX и ScewY</a></h3>
      <p>
        Ещё одна возможность CSS-трансформации - наклон объекта по осям X и Y
        под заданным углом. Наклоны создаются с помощью функий
        <span>skewX</span> и <span>skewY</span>
      </p>
      <p>Угол наклона задаётся в градусах - deg. Например:</p>
      <code>
        transform: skewX(45deg) <br />
        transform: skewY(30deg)
      </code>
      <p>
        Для оси X положительное значение угла наклоняет объект влево, а
        отрицательное - вправо. Для оси Y - вниз и вверх соответственно
      </p>
      <p>
        В примере ниже первый блок наклонён на <span>25</span> влево, а второй -
        на <span>25</span> вниз:
      </p>
      <img src="Двумерная трансформация/Картинки/9.PNG" />
      <p>
        Заметим, что наряду со <span>skewX</span> и
        <span>skewY</span> существует обобщающая функция <span>skew</span>,
        которая принимает два аргумента:
        <span>skew(наклон-по-Х [, наклон-по-Y]</span>. Значение наклона по оси Y
        является необязательным аргуменов и по умолчанию равно 0. Но при этом
        поведение функции <span>skew</span> при трансформации отличается от
        одновременного применения <span>skewX</span> и <span>skewY</span>.
        Исторически так сложилось, что реализация <span>skew</span> в браузерах
        поддерживается сейчас только для совместимости прежнего контента, и даже
        исключалась из рабочего черновика спецификации CSS. В общем, вместо
        <span>skew</span> лучше пользоваться <span>skewX</span> и
        <span>skewY</span>
      </p>
      <h3>
        <a href="Двумерная трансформация/scale 2.html">Ещё немного про scale</a>
      </h3>
      <p>
        У <span>transform: scale</span> есть одна особенность. А именно то, как
        ведёт себя объект при задании отрицательных чиловых значений: при
        <span>scaleX(-1)</span>, например, оригинальный объект зеркально
        отражается по горизонтали, а при <span>scale(-1, -1)</span> - отражается
        и по оси X, и Y. Большее, чем <span>-1</span> значение ещё шире растянет
        отзеркалированный объект.
      </p>
      <p>Ниже представлены примеры подобных трансформаци:</p>
      <img src="Двумерная трансформация/Картинки/11.PNG" />
      <h3>
        <a href="Двумерная трансформация/transform-origin 1.html"
          >Особенности transform-origin - часть 1</a
        >
      </h3>
      <p>Впереди ещё одно свойство - <span>transform-origin</span>.</p>
      <p>
        Это свойство используется со свойством <span>transform</span> и задаёт
        точку отсчёта системы коориднат, в рамках которой будет работать
        трансформация.
      </p>
      <p>
        Синтаксис <span>transform-origin</span> для двумерных трансформаций
        следующий:
      </p>
      <code>transform-origin: точка-отсчёта-по-X [точка-отсчёта-по-Y]</code>
      <p>
        Значения свойства задаётся в единицах измерения ширины в браузере
        (<span>px</span>, <span>em</span>...), в <span>%</span>, а также
        ключевыми словами <span>left, right, top, bottom, center</span>
      </p>
      <p>
        По умолчанию, значение <span>transform-origin</span> равно
        <span>50% 50%</span>, то есть начало системы координат находится в ентре
        объекта. Если не указывать значение <span>точка-отсчёта-по-Y</span>, то
        оно считается равным <span>50%</span>.
      </p>
      <p>
        Давайте разберёмся на примере функции scale, как ведёт себя
        трансформация при различных значениях <span>transform-origin</span>: в
        данном случае блок будет менять размеры относительно заданной точки.
      </p>
      <h3>
        <a href="Двумерная трансформация/transform-origin 2.html"
          >Особенности transform-origin - часть 2</a
        >
      </h3>
      <p>
        А тепперь попробуем сделать трансформацию плавной. Для этого в CSS
        предусмотрено свойство <span>transition</span>. Не будем пока вдаваться
        в подробности, как именно работает и применяется
        <span>transition</span> - это рассмотрии чть позже
      </p>
      <p>
        Если в двух словах, <span>transition</span> позволяет изменить значение
        какого-либо свойства плавно. В нашем случае плавно будет меняться
        свойство <span>transform</span> с функцией <span>scale</span>, а переход
        между двумя значениями будет длится полсекунды.
      </p>
      <p>
        Всё это наглядно покажет, как при разных значениях
        <span>transform-origin</span> меняется точка начала системы координат.
        Для демонстрации наведите курсор на картинку
      </p>
      <h3>
        <a href="Двумерная трансформация/transform-origin 3.html"
          >Особенности transform-origin - часть 3</a
        >
      </h3>
      <p>
        А теперь давайте посмори, как меняется поведение транформации поворота
        <span>transform: rotate</span> в зависимости от разных значений
        <span>transform-origin</span>
      </p>
      <p>
        В данном случае будет изменяться расположение оси вращения элемента.
      </p>
      <h3>
        <a href="Двумерная трансформация/transform-origin 4.html"
          >Особенности transform-origin - часть 4</a
        >
      </h3>
      <p>
        На статичном примере не так хорошо видн, как изменяется ось вращения
        элемента, когда мы изменяем <span>transform-origin</span>
      </p>
      <p>
        Поэтому мы сделаем ещё одно задание, где элемент будет прокручиаться на
        <span>360</span> при наведении на него. И здесь будет отлично видно, как
        изменяется ось вращения
      </p>
      <h3>
        <a href="Двумерная трансформация/Центровка с translate.html"
          >Центровка с помощью transform:translate</a
        >
      </h3>
      <p>
        Для центровки одного блока внутри другого обычно используются
        классический трюк с позиционированием, относительными координатами и
        отрицательными маргинами.
      </p>
      <p>
        Этот приём хорошо работает, когда центрируемый блок имеет фиксированные
        размеры, но если его размеры могут изменяться, то возникают проблемы.
      </p>
      <p>
        С помощью трансформаци можно решить эту проблему и центрировать блокси с
        переменными размерами. Делается это с помощью <span>translate</span>.
      </p>
      <h3>
        <a href="Двумерная трансформация/Поворот текста.html"
          >Поворот текста в блоках</a
        >
      </h3>
      <p>
        В этом задании мы перевернём заголовок статьи и поместим его сбоку. Для
        этого воспользуемся уже знакомыми свойствами
        <span>transform-origin</span> и <span>transform: rotate</span>
      </p>
      <h3>
        <a href="Двумерная трансформация/Поворот текста 2.html"
          >Поворот текста в фоне</a
        >
      </h3>
      <p>
        Вот ещё один интересный эффект, создаваемый с помощью трансформации
        поворота.
      </p>
      <p>
        На этот раз мы буде поворачивать "фоновый" текст, а также немного
        наклоним блок с заголовком функцией <span>skew</span>. А чобы наклонным
        был только блок, но не текст внутри, - наклоним текст в обратную сторону
        на тот же угол.
      </p>
      <h3>
        <a href="Двумерная трансформация/Нестандартные тени.html"
          >Нестандартные тени</a
        >
      </h3>
      <p>
        Иногда бывает нуно реализовать тени, отличающиеся от стандартных
        <span>box-shadow</span>, без применения картинок.
      </p>
      <p>Например, тени, наклонённые в разные стороны.</p>
      <p>
        Сделать это с помощью <span>box-shadow</span> невозможно. Поэтому нужно
        использовать более сложный приём:
      </p>
      <ul>
        <li>
          с помощью псевдоэлементов <span>before</span> и
          <span>after</span> создаём два блока с обычными тенями;
        </li>
        <li>наклоняем эти блоки с помощью <span>rotate</span>;</li>
        <li>задаём им отрицательный <span>z-index</span></li>
      </ul>
      <p>
        Это переместит блоки с тенями под родительский контейнертак, что наружу
        будут выглядывать только кусочки теней.
      </p>
      <h3>
        <a href="Двумерная трансформация/Кнопки 1.html"
          >Эффекты при наведении: кнопки - часть 1</a
        >
      </h3>
      <p>
        Довольно много интересных эффектов можно добиться с помощью
        трансформаций при реализации разных элементов интерфейса, например,
        кнопок. Им можно добавить немного динамики, используя
        <span>transform</span> совместно с <span>transition</span> для создания
        простейшей плавной анимации.
      </p>
      <p>
        В следующих нескольких примерах мы создадим эффекты при наведении на
        кнопку. Во всех случаях будет применятся свойство
        <span>transition</span> для плавной смены значений трансформации или
        прозрачности. Детально тема плавных переходов будет разбираться в
        ближайших курсах.
      </p>
      <p>
        В этом задании при наведении на кнопку давайте будем динамически
        оборачивать вокруг своей оси иконку и одновременно немного её
        увеличивать
      </p>
      <h3>
        <a href="Двумерная трансформация/Кнопки 2.html"
          >Эффекты при наведении: кнопки - часть 2</a
        >
      </h3>
      <p>
        В этом задании создадим вторую кнопку с немного другим эффектом у
        иконки: при наведении иконка должна увеличиваться и одновременно
        становиться полностью прозрачной, а на её месте синхроно будет
        появляться дополнительный скрытый блок с ценой <span>.hidden</span>
      </p>
      <p>
        Здесь будет использован плавный переход между двумя значениями
        позрачности <span>opacity</span> и <span>transform: scale</span>.
      </p>
      <h3>
        <a href="Двумерная трансформация/Кнопки 3.html"
          >Эффекты при наведении: кнопки - часть 3</a
        >
      </h3>
      <p>
        Ещё одна кнопка и ещё один эффект, похожий на предыдущий: при наведении
        давайте будем плавно скрывать иконку свойством <span>opacity</span> и
        одновременно показывать скрытый блок <span>.hidden</span>. При этом
        можно ещё дополнить эффект тем, что скрытый блок будет изначально
        "схлопнут" свойством <span>scale</span> до нуля, и при появлени он будет
        увеличиваться вместе с увеличением непрозрачности.
      </p>
      <h3>
        <a href="Двумерная трансформация/Галлерея.html"
          >Эффекты при наведении: галлерея</a
        >
      </h3>
      <p>
        В любой ситуации, когда стоит задача плавно менять позицию или размеры
        блока, а также каким-либо способом менять его внешний вид, встаёт выбор:
        пользоваться связкой <span>transition</span> +
        <span>transform</span> или же задействовать JavaScript и динамически
        менять ширину/высоту, координаты объектов в скрипте.
      </p>
      <p>
        Зачастую выбор падает на JS-реализацию с помощью библеотеки jQuery, но в
        большинстве случаев "чистая" CSS-реализация простых визуальных эффектов
        намного производительнее аналогичных jQuery-функций. Кроме того, в ряде
        случаев определённые трансформации в CSS могут для повышения
        производительности задействовать не только центральный процессор
        компьютера или мобильного девайса, но и ресурсы графического адаптера,
        что позволяет разгрузить процессор и избаваиться от "тормознутости"
        эффектов.
      </p>
      <p>
        В этом задании с помощью трансформации и плавных переходов давайте
        реализуем простую мини-галлерею картинок, которые увеличиваются и
        становятся полупрозрачные при наведении.
      </p>
      <h3><a href="Двумерная трансформация/Стопка.html">"Стопка" карт</a></h3>
      <p>
        В том задании давайте создадим "стопку" карт. Без эффектов эти картинки
        абсолютно спозиционированы и располагаются слоями друг под другом. Наша
        задача - немного повернуть нжележащие карты, чтобы они выглядывали
        из-под верхних. Как обычно восползуемся <span>transform: rotate</span>.
      </p>
      <h3>
        <a href="Двумерная трансформация/Круговое меню 1.html"
          >Круговое меню, подготовка</a
        >
      </h3>
      <p>
        В этой серии заданий мы построим сложный элемент интерфейса, в котором
        ключевую роль играют трансформации. Это круговое меню.
      </p>
      <p>
        Разметка меню не отличается от обычной. Внутри тега
        <span>&lt;nav&gt;</span> расположен обычный список
        <span>&lt;ul&gt;</span> с несколькими элементами списка со ссылками
      </p>
      <p>
        Мы разберём подход на двух пунктах меню, а потом добавим остальные по
        аналогии.
      </p>
      <p>
        Для того чтобы вращать элементы списка в меню, нужно правильно
        расположить их и задать иим ось вращения:
      </p>
      <ul>
        <li>ось должна находиться в правмо нижнем углу элемента списка</li>
        <li>это угол должен совпадать с центро меню</li>
      </ul>
      <p>
        Для решения эой задачи используем свойство
        <span>transform-origin</span>, а также свойства позиционирования.
      </p>
      <p>
        Кстати, чтобы меню получилось ровным, его пункты должны немного выходить
        за границы контейнера.
      </p>
      <h3>
        <a href="Двумерная трансформация/Круговое меню 2.html"
          >Круговое меню, шаг 1</a
        >
      </h3>
      <p>
        Теперь можно рассчитывать углы секторов меню и углы поворота пунктов.
        Используем такие формулы:
      </p>
      <code>
        [угол селектора] = 360 / [количество пунктов меню] <br />
        [поворот пункта n] = (n - 1) * [угол поворота]
      </code>
      <p>
        В нашем меню может быть максимум 6 пунктов, поэтому для его получатся
        такие значения:
      </p>
      <code>
        [угол селектора] = 360 / 6 = 60 <br />
        [поворот 1 пункта] = (1 - 1) * 60 = 0 <br />
        [поворот 2 пункта] = (2 - 1) * 60 = 60
      </code>
      <p>
        Для вращения пунктов, мы используем <span>rotate</span>. Но одного
        вращения недостаточно, так как элементы списка будут пересекаться, ведь
        их угол больше 60
      </p>
      <p>
        Чтобы исправить это, мы искривим пункты с помощью <span>skew</span>. А
        угол наклона посчитаем так:
      </p>
      <code> [угол наклона] = 90 - [угол сектора] </code>
      <p>В нашем случае получится 30</p>
      <p>
        Итого: первый элемент списка нужно наклонить на 30, а второй - повернуть
        на 60 и наклонить на 30
      </p>
      <p>Кстати, возможны две записи:</p>
      <code>
        transform: rotate(60deg) skew(30deg) // 1 вариант <br />
        tranform: skew(3deg) rotate(60deg) // 2 вариант
      </code>
      <p>
        Их эффекты будут отличаться, так как порядок трансформаций важен. И нам
        нужен первый вариант.
      </p>
      <h3>
        <a href="Двумерная трансформация/Круговое меню 3.html"
          >Круговое меню, шаг 2</a
        >
      </h3>
      <p>
        Внутри пунктов меню расположены ссылки. Для них задан блочный тип,
        размеры и фон
      </p>
      <p>
        На предыдущем шаге мы повернули и скосили пункты меню, но при этом
        косилось и их содердимое, тое есть ссылки. Чтобы вернуть им нормальый
        вид, нужно их "разнаклонить" и развернут обратно.
      </p>
      <p>
        "Разнаклонять" будем на противоположный угол, то есть на
        <span>-30</span>.
      </p>
      <p>Расчёт угла разворота сложнее, вот формула:</p>
      <code> [угол разворота] = -1 * (90 - ([угол сектора] / 2)) </code>
      <p>В нашем случае получится:</p>
      <code> [угол разворота] = -1 * (90 - (60 / 2)) = -60 </code>
      <p>
        Обратите внимание на порядок трансформаций для ссылок: сначала
        <span>skew</span>, потом <span>rotate</span>.
      </p>
      <p>
        И ещё одна важная деталь. На нужно сместить ссылки так, чтобы они
        располагались во внутренней половине пунктов меню. Для этого используем
        маргины.
      </p>
      <h3>
        <a href="Двумерная трансформация/Круговое меню 4.html"
          >Круговое меню, шаг 3</a
        >
      </h3>
      <p>
        Промежуточный результат не очень похож на круглое меню, но ещё несколько
        строчек CSS-кода и всё изменится.
      </p>
      <p>
        Первым делом мы обрежем части ссылок, которые выходят за пределы пунктов
        меню, и избавимся от избыточных пересечений. Для этого зададим свойство
        <span>overflow</span> со значением <span>hidden</span> для элементов
        списка.
      </p>
      <p>Затем нужно будет придать меню круглую форму</p>
      <p>
        Для этого будем работать с саим список <span>ul</span>, который сейчас
        выглядит как квадрат с сней рамкой. Добавим свойство
        <span>border-radius</span> со значением <span>50%</span>, и квадрат
        превратится в круг
      </p>
      <p>
        А дальше останется только обрезать всё, выходящее за пределы круга. И
        снова используем <span>overflow</span>.
      </p>
      <p>
        Круглое меню из двух пунктов готов, можно убрать вспомогатльные фоны и
        рамки.
      </p>
      <h3>
        <a href="Двумерная трансформация/Круговое меню 5.html"
          >Круговое меню, финал</a
        >
      </h3>
      <p>Вот вся техника для создания круглого меню:</p>
      <ol>
        <li>
          Переносим ось вращения пунктв в угол с помощью
          <span>transform-origin</span> и совмещаем этот угол с центром меню.
        </li>
        <li>
          Наклоняем и поворачиваем пункты меню, используя формулы:
          <code>
            [угол селектора] = 360 / [количество пунктов меню] <br />
            [поворот пункта n] = (n - 1) * [угол поворота]
          </code>
        </li>
        <li>
          "Разнаклоняем" и разворачиваем содержимое мунктов меню:
          <code>
            [угол наклона содержимого] = -1 * [угол наклона пункта] [угол
            разворота] = -1 * (90 - (60 / 2)) = -60
          </code>
        </li>
        <li>Смещаем содержимое пунктов к центру круга</li>
        <li>
          Закругляем контейнр меню с помощью <span>border-radius</span> и
          обрезаем всё лишнее с помощью <span>overflow: hidden</span>
        </li>
      </ol>
      <p>
        А после этих шагов можно применять дополнительное оформление. Например,
        задавать разные фоны пунктов, рамку для контейнера меню и так далее.
      </p>
      <p>
        Давайте напоследок добавим третий пункт меню, чтобы у нас получился
        полукруг. Угол поворота третьего пункта равен <span>120</span>
      </p>
    </main>
    <footer>
      <h3>Здесь могла быть ваша кувшинка</h3>
    </footer>
  </body>
</html>
