<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>Циклы</title>
    <link rel="stylesheet" href="../../стили/Полигон.css" />
  </head>
  <body>
    <header>
      <img
        src="../../avatar/avatar1.jpg"
        width="90"
        height="90"
        alt="Лягушка"
      />
      <nav>
        <a href="../../Полигон.html">Назад</a>
      </nav>
    </header>
    <main>
      <h2>Циклы</h2>
      <h3>Новый проект: разработка драйвера</h3>
      <p>
        У на новый большой проект: разработка драйверов для нового принтера.
        Драйвер - это специальная программа, которая позволяет компьютеру
        управлять техникой.
      </p>
      <p>
        Новый принтер достаточно простой, он долежн уметь печатать все страницы
        в прямом и обратном порядке, печатать чётные и нечётные страницы и
        делать копии одной страницы. И ваша программа-драйвер должна это
        обеспечить.
      </p>
      <p>
        Правда, тестовый образец принтера ещё не прислали. Поэтому логику работы
        драверов будем отрабатывать с помощью
        <span>console.log</span>, которая принимает на вход номер страницы. Вот
        пример:
      </p>
      <code>
        // Выведет в консоль: Печать страницу №1 <br />
        let page = 1; <br />
        <br />
        console.log('Печать страницы №' + page) <br />
      </code>
      <p>
        Начнём с простой задачи: нужно заставить принтер печатать заданную
        страницу несколько раз:
      </p>
      <code>
        let page = 7; <br />
        <br />
        console.log('Печать страницы №' + page) <br />
        console.log('Печать страницы №' + page) <br />
        console.log('Печать страницы №' + page) <br />
      </code>
      <h3>Управлять количеством копий</h3>
      <p>
        Драйвер умеет делать три копии заданной страницы. Теперь нужно научить
        его делать разное количество копий в зависимости от ситуации. Вы знаете
        условия, поэтому могли бы написать программу как-то так:
      </p>
      <code>
        // Переменная хранить нужное количество копий <br />
        let count = 3; <br />
        <br />
        if (count === 2) { <br />
        console.log('Печать страницы №' + page) <br />
        console.log('Печать страницы №' + page) <br />
        } <br />
        <br />
        if (count === 3) { <br />
        console.log('Печать страницы №' + page) <br />
        console.log('Печать страницы №' + page) <br />
        console.log('Печать страницы №' + page) <br />
        } <br />
      </code>
      <p>
        Вообще, подход рабочий, но никто так не пишет. Представьте программу,
        которая умеет делать сто копий одной страницы.
      </p>
      <p>
        Чтобы удобно выполнять такие повторящеся команды, в языках
        программирования существуют циклы. Например, цикл <span>for</span>:
      </p>
      <code>
        for (let i = 0; i &lt; count; i = i + 1) { <br />
        // повторяющиеся команды <br />
        }
      </code>
      <p>
        Если мы записали цикл <span>for</span> таким образом, действия внутри
        фигурных скобок выполнятся <span>count</span> раз. Внимательное
        рассмотрение содержимого <span>for</span> мы пока отложим до следующего
        задания, а пока посомтри как оно работает.
      </p>
      <code>
        let page = 7; <br />
        let count = 3; <br />
        <br />
        for (let i = 0; i &lt; count; i = i + 1) { <br />
        console.log('Печать страницы №' + page) <br />
        }
      </code>
      <h3>Разбираем цикл for</h3>
      <p>
        Перва часть драйвера реализована. Второй шаг: печать всех страниц
        документа.
      </p>
      <p>
        В этой задаче тоже много повторяющихся действий, поэтому без циклов
        решить её не получится. Давайте разберём цикл
        <span>for</span> подробнее:
      </p>
      <code>
        for (let i = 0; i &lt; 5; i = i + 1) { <br />
        // повторяющиеся команды, или "тело цикла" <br />
        }
      </code>
      <p>
        Как работает цикл <span>for</span>? Он выполняет действия из тела цикла
        снова и снова, пока условие врзвращает <span>true</span>. Что за условие
        и как грамотно писать циклы, м сейчас разберём.
      </p>
      <p>
        В круглых скобках записывается код управления циклом. Он состоит из трёх
        частей, разделённых <span>;</span>. Смысл каждой части такой:
      </p>
      <ol>
        <li>
          <p>
            Первая часть - подготовительная. Команды отсюда запускаются
            <i>один раз</i> перед началом работы цикла. Обычно здесь задаётся
            исходное значение для переменной-счётчика. Можно сказать, что первая
            часть - стартовая настройка для цикла
          </p>
          <p>
            В примере мы создали переменную-счётчик <span>i</span> и задали ей
            начальное значение <span>0</span>. Именно этому значению будет равна
            переменная, когда цикл начнёт свою работу.
          </p>
          <p>
            Обратите внимание, что в цикле мы создаём переменную-счётчик с
            помощью <span>let</span>, как в случае с любой другой переменной.
            Традиционно такая переменная называется <span>i</span> (от слова
            index), но у неё может быть любое другое название. Например, если
            цикл считает дни, переменная-счётчик может называться
            <span>day</span>, а если страницы документа, то <span>page</span>.
          </p>
          <code> for (<b>let i = 0</b>; i &lt; 5; i = i + 1) {} </code>
        </li>
        <li>
          <p>
            Вторая часть - проверочная. Она содержит условие и запускается
            <i>перед</i> каждым новым витком цикла .Условие здесь работает по
            знакомому вам алгоритму. Если условие возвращает <span>true</span>,
            цикл делает ещё один виток, иначе цикл завершает свою работу.
          </p>
          <p>
            В примере мы указалли, что цикл должен рабоать пока переменная
            <span>i</span> будет меньше <span>5</span>.
          </p>
          <code> for (let i = 0; <b>i &lt; 5</b>; i = i + 1) {} </code>
        </li>
        <li>
          <p>
            Третья часть - дополняющая, хотя по-научному она называется "закон
            изменения". Код третьей части запускается <i>после</i> каждого витка
            цикла. То ест после того, как выполнится код из тела цикла. Обычно
            там изменяется переменная-счётчик.
          </p>
          <p>
            В нашем случае мы указали, что после каждого витка цикла, переменная
            <span>i</span> должна увеличиваться на единицу.
          </p>
          <code> for (let i = 0; i &lt; 5; <b>i = i + 1</b>) {} </code>
        </li>
      </ol>
      <p>
        Мы разобрали, как устроен цикл <span>for</span> в теории. Теперь напишем
        программу для печати всех страниц. Количество страниц хранится в
        переменной <span>totalPages</span>:
      </p>
      <code>
        let = totalPages = 7; <br />
        <br />
        for (let page = 0; page &lt; totalPages; page = page + 1) { <br />
        console.log('Печать страницы') <br />
        }
      </code>
      <h3>Исправляем цикл</h3>
      <p>
        Что-то пошло не так, и вметсо того, чтобы выводить странцы с первой по
        седьмую, драйвер выводит пустую страницу и затем страницы с первой по
        шесту. Рассмотрим, в какой послеовательности выполняются части
        конструкции <span>for</span> на примере:
      </p>
      <code>
        for (let i = 0; i &lt; 5; i = i + 1) { <br />
        console.log(i); <br />
        }
      </code>
      <ol>
        <li>
          Сначала сработает <span>let i = 0;</span>. Будет создана переменная
          <span>i</span>, равная <span>0</span>.
        </li>
        <li>
          Затем выполнится проверка <span>i &lt; 5;</span>. Так как
          <span>i</span> равна <span>0</span> и это значение меньше
          <span>5</span>, условие вернёт <span>true</span>. Это значит, что цикл
          может продолжить свою работу и перейти к выполнению кода из тела
          цикла.
        </li>
        <li>
          Выполнить код из тела цикла. В нашем случае в консоль выведется
          <span>0</span> - текущее значение переменной <span>i</span>.
        </li>
        <li>
          Выполнится <span>i = i + 1</span>. Переменная <span>i</span> станет
          равна <span>1</span>.
        </li>
        <li>
          Выполнится проверка <span>i &lt; 5;</span>. Она снова вернёт
          <span>true</span>, так как <span>1</span> меньше <span>5</span>.
        </li>
        <li>
          Снова выполнится тело цикла, затем значение <span>i</span> увеличитс
          на единицу, и так дальше по круг, пока условие
          <span>i &lt; 5;</span> не вернёт <span>false</span>. Тогда цикл
          закончит свою работу.
        </li>
      </ol>
      <p>
        Теперь посомтри на пример из предыдущего задания. Почему-то первой
        выводится пустая страница.
      </p>
      <p>
        На первом витке, или, по-научному, <i>итерации цилка</i>, переменная
        <span>page</span> ещё равна нулю. А увеличивается до единицы она уже
        после первой итерации. Если изменить исходное значение переменной
        <span>page</span> с <span>0</span> на <span>1</span>, то проблема
        исчезнет.
      </p>
      <p>А почему страниц шесть, а не семь? Разберём цикл по шагам:</p>
      <code>
        Подготовка: totalPages = 7; page = 0 <br />
        1 интерация: page = 0; 0 &lt; 7? да! Вывод страницы 0; page = 1 <br />
        2 интерация: page = 1; 1 &lt; 7? да! Вывод страницы 1; page = 2 <br />
        3 интерация: page = 2; 2 &lt; 7? да! Вывод страницы 2; page = 3 <br />
        4 интерация: page = 3; 3 &lt; 7? да! Вывод страницы 3; page = 4<br />
        5 интерация: page = 4; 4 &lt; 7? да! Вывод страницы 4; page = 5 <br />
        6 интерация: page = 5; 5 &lt; 7? да! Вывод страницы 5; page = 6 <br />
        7 интерация: page = 6; 6 &lt; 7? да! Вывод страницы 6; page = 7 <br />
        8 интерация: page = 7; 7 &lt; 7? нет! Завершаем цикл!
      </code>
      <p>
        Для получения седьмой страницы нужно изменить сравнение с "меньше" на
        "меньше или равно". В этом случае проверка на восьмом витке цикла
        сработает и выведется седьмая страница.
      </p>
      <code>
        8 интерация: page = 7; 7 &lt;= 7? да! Вывод страницы 7; page = 8 <br />
        9 интерация: page = 8; 8 &lt;= 7? нет! Завершаем цикл!
      </code>
      <p>
        Подытожим: чтобы всё печаталос, как надо, нужно начать отсчёт со
        страницы номер <span>1</span> и исползовать знак <span>&lt;=</span> в
        условии, чтобы включить последнюю страницу в расчёт.
      </p>
      <h3>Печатаем страницы в обратном порядке</h3>
      <p>
        Второй ржим работы драйвера завершён! Теперь принтер мжет печатат все
        страницы документа и копии заданной страницы. Впечатляет.
      </p>
      <p>Переходим к третьему режиму: печати страниц в обратнм порядке.</p>
      <p>
        Это нужная и полезная функция. Если напечатать страницы в обратном
        порядке, то их моно сразу сшивать в один документ беез необходимости
        переворачивать.
      </p>
      <p>
        Вы уже знаете все детали работы цикла <span>for</span>, так что
        остальные режимы реализуете без проблем.
      </p>
      <p>
        Для печати в обратном порядке сначала нужно вывести поледнюю страницу,
        затем предпоследнюю и так далее, пока не дойдём до первой. Что это
        значит в термнах циклов:
      </p>
      <ol>
        <li>
          На подготовительном шаге нужно установить номер траницы равным
          количеству страниц в документе.
        </li>
        <li>
          Перед каждой итерацией цикла проверяем, что номер страницы больше нуля
          (либо больше или равен единице)
        </li>
        <li>
          После каждой итерации номер страницы нужно <i>уменьшать</i> на
          единицу, а не увеличивать, как мы делали ранее.
        </li>
      </ol>
      <code>
        let totalPages = 5; <br />
        <br />
        for (let page = totalPages; page &gt; 0; page = page - 1) { <br />
        console.log('Печать страницы') <br />
        }
      </code>
      <h3>Печатаем только нечётные страницы</h3>
      <p>
        Осталось печать чётных и нечётных. Печататьь только нечётные страницы
        легко:
      </p>
      <ul>
        <li>Начинать печатать нужно с первой страницы.</li>
        <li>
          Посе каждой итерации цикла нужно увеличивать номер текущей страницы на
          <span>2</span>, а не на <span>1</span>.
        </li>
      </ul>
      <p>
        Наверное вы уже заметили, что в циклах постоянно используется увеличение
        или уменьшение переменных на какое-то число. И на постоянно приходится
        писать громоздкие конструкции, типа <span>page = page + 1</span>. К
        счастью, в JavaScript есть несколько удобных операторов, которые
        позволяют сокатить код. Вот они:
      </p>
      <table>
        <tr>
          <th>Название</th>
          <th>Пример</th>
          <th>Аналог</th>
        </tr>
        <tr>
          <td>Инкремент (увеличение на единицу)</td>
          <td><span>i++</span></td>
          <td><span>i = i + 1</span></td>
        </tr>
        <tr>
          <td>Декремент (уменьшение на единицу)</td>
          <td><span>i--</span></td>
          <td><span>i = i - 1</span></td>
        </tr>
        <tr>
          <td>К-к-комбо!</td>
          <td><span>i += 2</span></td>
          <td><span>i = i + 2</span></td>
        </tr>
      </table>
      <p>
        Комбинировать можно не только сложение, но и остальные математические
        операции: вычитание <span>-=</span>, умножение <span>*=</span> и
        нахождение остатка <span>%=</span>. Например, <span>i *= 10</span> будет
        аналогично <span>i = i * 10</span>.
      </p>
      <p>А тепеь код для написания нечётных страниц:</p>
      <code>
        let totalPages = 12 <br />
        <br />
        for (let page = 1; page &lt;= totalPages; page += 2) { <br />
        console.log('Печать страницы') <br />
        }
      </code>
      <h3>Печатаем только чётные страницы</h3>
      <p>
        Печать чётных страниц отличается от печати нечётных совсем немного:
        по=прежнему печатать страницы, увеличивая номер страницы на два, но
        начинаем не с первой страницы, а со второй:
      </p>
      <code>
        let totalPages = 9 <br />
        <br />
        for (let page = 2; page &lt;= totalPages; page += 2) { <br />
        console.log('Печать страницы') <br />
        }
      </code>
      <h3>Драйвер печати: режим копий</h3>
      <p>Все режимы печати реализованы.</p>
      <p>
        Настало время написать единую программу, которая в зависимости от
        выставленного режима, будет печатать страниы, как на нужно: несколько
        копий одной страницы, все страницы документа в прямом и обратном пордке,
        только чётные и только нечётные страницы.
      </p>
      <p>
        Начнём с режима копирования страницы и будем постепенно добавлять
        остальные режимы. Название режима будем хранить в переменной
        <span>mode</span>.
      </p>
      <p>
        Конечно, тут не обойдётся без цикла. Давайте на примере разберёмся, как
        подобная формулировка переводится в код: "Добавьте цикл, который
        увеличивает переменную i с нуля до 10 включително. Значение i должно
        увеличиватья на единицу после каждой итерации."
      </p>
      <p>
        Лучше разбирать такую задау по частям. "Добавьте цикл, который
        <b>увеличивает переменную i с нуля</b> до 10 включително". Выходит,
        переменная, которая будет менять своё значение по ходу работы цикла,
        будет <span>i</span>. Значит, это и есть переменная-счётчик. Её значение
        будет меняяться от <span>0</span> и дальше. То есть стартовое значение
        счётчика - <span>0</span>. Так и записываем:
      </p>
      <code>
        for (<b>let i = 0;</b>) { <br />
        ... <br />
        }
      </code>
      <p>
        Обратите внимание, что мы используем <span>let</span> для объвления
        счётчика. Это такая же переменная, как и любая другая, и объвлять её
        надо с помощью <span>let</span>.
      </p>
      <p>
        Идём дальше. "... увеличивать переменную i с нуля
        <b>до 10 включительно</b>". Значит, значение счётчика (переменной
        <span>i</span>) будет расти до <span>10</span>. Так как в тексте
        сказано, "до 10 включительно", то последнее значение <span>i</span>, с
        которым цикл выполнится, будет <span>10</span>. Чтобы это значение
        попало в переменную <span>i</span> и цикл выполнился, используем знак
        <span>&lt;=</span>.
      </p>
      <code>
        for (let i = 0; <b>i &lt;= 10;</b>) { <br />
        ... <br />
        }
      </code>
      <p>
        "Значение i должно увеличиваться на единицу после каждой итерации".
        Значит, мы должны прибавлять к <span>i</span> единицу после каждого
        витка цикла. Будем использовать инкремент.
      </p>
      <code>
        for (let i = 0; i &lt;= 10; <b>i++</b>) { <br />
        ... <br />
        }
      </code>
      <p>
        В примере мы использовали стандартное название <span>i</span> для
        счётчика цикла. В случае с копиями страниц мы будем считать сколко копий
        уже сделано и сравнивать это число с необхдимым количетвом. То есть
        будем увеличивать число копий. Поэтомй для счётчика тут вполне подйдёт
        имя <span>copies</span>:
      </p>
      <code>
        let mode = 'pageCopy'; // Режим работы драйвера печати<br />
        let pageNumber = 5; // Номер копируемой страницы<br />
        let copyCount = 7; // Количетво копий<br />
        <br />
        if (mode === 'pageCopy') { <br />
        for (let copies = 1; copies &lt;= copyCount; copies++ ) { <br />
        console.log ('Печать страницы №' + pageNumber) <br />
        } <br />
        }
      </code>
      <h3>Драйвер печати: все страницы</h3>
      <p>Первый режим добавлен, хорошо!</p>
      <p>
        Теперь добавим режим расппечатки всех страниц документа. Он будет
        называться <span>'document'</span>. Общее количество страниц хранится в
        переменной <span>totalPages</span>.
      </p>
      <p>
        Здесь мы будем печатать страницы одну за другой и следить, чтобы все они
        были напечатаны. Поэтому счётчик можно назвать <span>page</span>, он
        будет показывать номер страницы, которую напечатал принтер.
      </p>
      <code>
        let mode = 'document'; <br />
        let totalPages = 6; // Всего страниц в документе <br />
        <br />
        if (mode === 'document') { <br />
        for (let page = 1; page &lt;= totalPages; page++) { <br />
        console.log ('Печать страниц') <br />
        } <br />
        }
      </code>
      <h3>Драйвер печати: страницы в обратном порядке</h3>
      <p>Теперь выведем страницы в обратном порядке.</p>
      <p>
        Режим будет называться <span>'reverse'</span>, нужно добавить условие и
        отдельный цикл.
      </p>
      <p>
        Как писать циклы п подобным условиям: "Добавьте цикл, который уменьшает
        значение переменной i от 10 до 1 включительно. Уменьшайте значение i на
        единцу на каждой итерации"? Как обычно, будем разбираться постепенно.
      </p>
      <p>
        "... цикл, который уменьшает <b>значение переменной i от 10</b> до 1
        включительно". Счётчик здесь <span>i</span>, а его стартовое значение
        <span>10</span>. Записываем.
      </p>
      <code>
        for (<b>let i = 10;</b>) { <br />
        ... <br />
        }
      </code>
      <p>
        "... цикл, который уменьшает значение переменной i
        <b>от 10 до 1 включительно</b>". Это значит, что икл закончит свою
        работу, когда <span>i</span> станет равно <span>0</span>. При
        <span>i = 1</span> цикл совершит очередную итерацию. Так как стартовое
        значение счётчика <span>10</span> и оно будет уменьшаться до
        <span>1</span> включительно, нам подойдёт знак "больше или равно".
        Сравнивать будем с <span>1</span> так как это значение, после которого
        цикл должен остановится.
      </p>
      <code>
        for (let i = 10; <b>i &gt;= 1;</b>) { <br />
        ... <br />
        }
      </code>
      <p>
        Обратите внимание, что условие можно напистаь и немного по-другому. Если
        нам нужно учесть значение <span>1</span>, но при значении меньше
        <span>1</span> закончить работу цикла, то можно использовать знак
        "больше". Только сравнивать его с <span>0</span>. Тогда единица точно
        будет использоваться в качестве значения счётчика, а при
        <span>0</span> цикл закончит свою работу.
      </p>
      <code>
        for (let i =10; <b>i &gt; 0;</b>) { <br />
        ... <br />
        }
      </code>
      <p>
        Есть два варианта напистаь условие в таких случаях, и оба верные. Можете
        использовать любой.
      </p>
      <p>
        "Уменьшайте значение i на единицу на каждой итерации". Здесь привычное
        нам изменение значения на единицу. Только теперь мы не увеличиваем
        значение счётчика, а уменьшаем, поэтому используем декремент.
      </p>
      <code>
        for (let i = 10; i &gt;; <b>i--</b>) { <br />
        ... <br />
        }
      </code>
      <p>
        Вернёмся к принтеру. В эом режиме мы будем считать страницы в обратном
        порядке и ждать, кгда напечатается последняя страница, в нашем случае
        первая, так как счёт идёт с конца. Счётчик <span>page</span> у нас уже
        был, поэтому используем <span>reversePage</span> раз считаем страницы в
        обратном порядке.
      </p>
      <code>
        let mode = 'reverse'; <br />
        let totalPages = 6; <br />
        <br />
        if (mode === 'reverse') { <br />
        for (let reversePage = totalPages; reversePage &gt;= 1; reversePage--) {
        <br />
        console.log ('Печать страниц') <br />
        } <br />
        }
      </code>
      <h3>Драйвер печати: чётные и нечётные страницы</h3>
      <p>Теперь добавим вывод страниц через одну.</p>
      <p>
        Режим будет активироваться при значении
        <span>'alternate'</span> переменной <span>mode</span>.
      </p>
      <p>
        Для выбора между чётностью и нечётностью выводимых страниц будем
        использовать переменную <span>startPage</span>: если она равна
        <span>1</span> - выводятся нечётные страницы, если <span>2</span> -
        чётные.
      </p>
      <p>
        Так как у нас альтернативный вид печати, то и страницы печатаются в
        непривычном порядке. Счётчик можно назвать примерно так же, как режим
        печати <span>alternatePage</span>.
      </p>
      <p>
        Обратите внимание, что инкремент здесь не пригодится. Счётчик будет
        увелчиваться на двойку, поэтому исползуем запись вида
        <span>счётчик = счётчик + 2</span> или сокращённый вариант
        <span>счётчик += 2</span>.
      </p>
      <code>
        let mode = 'alternate'; <br />
        let totalPages = 6; <br />
        <br />
        if (mode === 'alternate') { <br />
        for (let alternatePage = startPage; alternatePage &lt;= totalPages;
        alternatePage = alternatePage + 2) {<br />
        console.log ('Печать страниц') <br />
        } <br />
        }
      </code>
      <h3>Накопление в цикле</h3>
      <p>
        Внутри циклов можно не только запускать печать страниц, но и
        использовать обычные математические операции. Например, сложение:
      </p>
      <code>
        for (let i = 1; i &lt;= 5; i++) { <br />
        console.log(2 + 2); <br />
        }
      </code>
      <p>Резуьтат программы будет таким:</p>
      <code>
        LOG: 4 (number) <br />
        LOG: 4 (number) <br />
        LOG: 4 (number) <br />
        LOG: 4 (number) <br />
        LOG: 4 (number) <br />
      </code>
      <p>
        Число 4 выведется в консоль 5 раз, ведт именно столько итераций в этом
        цикле. То есть на каждой итерации двойки будут складываться и выводиться
        в консоль. Но если на каждой итерации нам нужно получать новое,
        увеличенное число, надо действовать по-другому. Нужно завести
        <i>перед</i> циклом ещё одну переменную, которая и будет хранить сумму:
      </p>
      <code>
        let sum = 0; <br />
        <br />
        for (let i = 1; i &lt;= 5; i++) { sum += 2; <br />
        console.log(sum); }
      </code>
      <p>Программа выведет:</p>
      <code>
        LOG: 2 (number) <br />
        LOG: 4 (number) <br />
        LOG: 6 (number) <br />
        LOG: 8 (number) <br />
        LOG: 10 (number) <br />
      </code>
      <p>
        Теперь на каждой итерации мы добавляем 2 к переменной <span>sum</span>,
        накапливая её значение. Переменная <span>sum</span> объявлена снаружи
        цикла (а не внутри тела цикла, что важно), поэтому её значение не
        сбрасывается при попадании в тело цикла, а увеличивается на 2.
      </p>
      <p>Такая операция называется накполением значения в цикле.</p>
      <p>
        Давайте потренируемся накапливать значения и посчитаем сумму чисел от
        <span>1</span> до <span>10</span>. Будем выводить в консоль
        промежуточные результаты, чтобы следить за изменениями суммы:
      </p>
      <code>
        let sum = 0; <br />
        for (let i = 1; i &lt;= 10; i++) { <br />
        sum +=i; <br />
        console.log(sum); <br />
        }
      </code>
      <h3>Проверки в циклах</h3>
      <p>
        До этого мы писали циклы внутри условий, но можно и наоборот! Если
        добавить условие внутрь цикла, то оно будет проверяться на каждой
        итерации.
      </p>
      <p>
        Например, можно проверять значение счётчика, и если оно больше двух,
        прибавлять к сумме 3, а не 2:
      </p>
      <code>
        let sum = 0; <br />
        <br />
        for (let i = 1; i &lt;=5; i++) { <br />
        if (i &gt; 2) { <br />
        sum += 3; <br />
        } else { <br />
        sum += 2; <br />
        } <br />
        console.log(sum) <br />
        }
      </code>
      <p>Результат программы:</p>
      <code>
        LOG: 2 (number) <br />
        LOG: 4 (number) <br />
        LOG: 7 (number) <br />
        LOG: 10 (number) <br />
        LOG: 13 (number) <br />
      </code>
      <p>
        Потренируемся добавлять условия в циклы. Добавим проверку в наш цикл из
        предыдущего задания. Если значение счётчика больше <span>5</span> будем
        прибавлять к <span>sum</span> число <span>2</span>.
      </p>
      <h3>Поиск чётного числа</h3>
      <p>
        Проверка в циклах очень удобны. Они позволяют делать проверки на каждой
        итерации цикла.
      </p>
      <p>
        Например, в цикле из прошлых заданий будем проверять чётное ли сейчас
        число <span>i</span>. И если числ чётное, будем прибавлять к сумме
        <span>2</span>, а если число нечётное, будем прибавлять <span>1</span>.
      </p>
      <p>
        Как проверить, что число чётное? Здесь может помочь оператор
        <span>%</span>. Он называется <i>остаток от деления</i> и, как понятно
        из названия, возвращает остаток от деления:
      </p>
      <code>
        10 % 5; // Вернёт 0 <br />
        12 % 5; // Вернёт 2 <br />
        7 % 3; // Вернёт 1 <br />
        5.5 % 2; // Вернёт 1.5 <br />
      </code>
      <p>
        Как это поможет в определении чётного или нечётного числа? Чётное число
        делится на <span>2</span> без остатка. Поэтому, если деление
        <span>i % 2</span> возвращает <span>0</span> - число чётное, иначе число
        нечётное.
      </p>
      <p>Напишем проверку с использование <span>%</span> в нашем цикле</p>
      <h3>Сколько стоит печать?</h3>
      <p>
        Вернёмся к принтеру. Мы написали программу, которая умеет печатать
        страницы, но упустили из виду одну деталь - на печать каждой страницы
        тратится краска. В нашем принтере на одну страницу "уходит" 70 мг
        порошка с краской. Хорошо бы следить за расходом тонера и знать, сколько
        тратится на печать одного документа.
      </p>
      <p>
        Для решения этой будем использовать накопление значений в цикле. Заведём
        внешнюю переменную, куда будем добавлять 70 мг (расход на одну страницу)
        при печати каждой страницы документа. Но сначала эту переменную нужно
        назвать.
      </p>
      <p>
        Не нужно придумывать сложные имена для переменных, их назначение должно
        быть понятным из названия. Поэтому мы определяем, что должно храниться в
        переменной, например, общий расход краски на все страницы, и переводим
        это на английский язык. Мы могли бы назвать переменную
        <span>consumptionColorForAllPages</span> или
        <span>consumptionTonerForAllPages</span>, но это избыточно. Мы решаем
        задачу только про расход тонера, другого кода у нас нет, поэтому
        название можно сократить и убрать указание на то, расход чего мы
        считаем. Это и так понятно, другой задачи у нас нет. А
        <span>ForAllPages</span> - слишком длинно. Если отбросить подобрности,
        мы считаем общий расход краски. Для слова "общий" есть простое
        английское обозначение "total", поэтому назовём переменную
        <span>consumptionTotal</span> - это название краткое и при это оно
        объясняет значение перемменной.
      </p>
      <p>
        Аналогично поступаем с именем переменной, которая будет хранить расход
        краски на одну страницу (70 мг). Назовём её
        <span>consumptionPerPage</span>.
      </p>
      <p>
        Посчитаем расход тонера на печать всех страниц. Считать будем в режиме
        печати обычного документа:
      </p>
      <code>
        let totalPages = 6; <br />
        let consumptionPerPage = 70; <br />
        let consumptionTotal = 0; <br />
        <br />
        for (let i = 1; i &lt;= totalPages; i++) { <br />
        consumptionTotal += consumptionPerPage; <br />
        console.log(consumptionTotal); <br />
        }
      </code>
      <h3>Экономичная печать</h3>
      <p>
        Идея экономической печати такова: первые три страницы печатаем как
        обычно, а на оставшихся экономим тонер во все тяжкие (то есть используем
        в ДВА раза меньше тонера)!
      </p>
      <p>
        Теперь нам нужно не просто увеличивать значение
        <span>consumptionTotal</span> при каждой итерации на <span>70</span>, но
        и проверять в каком режиме печати мы находимся (экономичном или обычном)
        и какую по счёту страницу документа печатаем. Тут пригодятся условия.
      </p>
      <p>
        Используем условие в цикле, чтобы проверить режим печати. Если режим
        экономичный, будем отлавливать страницы с номер больше <span>3</span> и
        печатать их с меньшим расходом краски. Половину расхода будем записывать
        как <span>consumptionPerPage * 0.5</span>
      </p>
      <h3>Экономим краску</h3>
      <p>
        Подсчёт расхода тонера почти готов. Сейчас код в теле цикла выглядит
        так:
      </p>
      <code>
        if (ecnomyMode && page &gt; 3) { <br />
        consumptionTotal += consumptionPerPage * 0.5 <br />
        } <br />
        consumptionTotal += consumptionPerPage <br />
      </code>
      <p>
        Получается, если включен экономичный режим и номер страницы боьше трёх,
        мы тратим половину краски от обычного режима на одну страницу. А потом,
        неважно, сработает условие ил нет, мы обязательно увеличиваем расход ещё
        <span>consumptionTotal += consumptionPerPage;</span>. Получается не
        экономия, а сплошные расходы. Добавим ветку <span>else</span> к условию
        и перенесём туда строку
        <span>consumptionTotal += consumptionPerPage;</span>. Затем включим
        режим экономии тонера и проверим, что всё работает правильно:
      </p>
      <code>
        let totalPages = 6; <br />
        let consumptionPerPage = 70; <br />
        let consumptionTotal = 0; <br />
        let ecnomyMode = true; <br />
        <br />
        for (let page = 1; page &lt;= totalPages; page++) { <br />
        if (ecnomyMode && page > 3) { <br />
        consumptionTotal += consumptionPerPage * 0.5 <br />
        } else { <br />
        consumptionTotal += consumptionPerPage <br />
        } <br />
        console.log(consumptionTotal); <br />
        } <br />
      </code>
      <h3>Привет, "пока"!</h3>
      <p>
        Замечательно! Вы разобрались с циклом <span>for</span>. Его удобно
        использовать, когда число повторений известно заранее, ещё до запуска
        цикла. Например, когда известно количество страниц в документе или
        количество дней.
      </p>
      <p>
        Но встречаются ситуации, когда количество повторений заранее не
        известно. Например, биатлон: стреляй по мишеням, пока не закроешь все.
      </p>
      <p>
        В таких случаях, когда цикл повторяется снова и снова, пока не
        выполнится условие, удобнее использовать цикл <span>while</span>.
      </p>
      <code>
        while (условие) { <br />
        действие <br />
        }
      </code>
      <p>
        Дейтвия, указанные в цикле, будут выполняться снова и снова, пока
        условие не вернёт <span>false</span>.
      </p>
      <p>Потренируемся использовать цикл <span>while</span>.</p>
      <p>
        Представим, что мы играем в дартс. Мы пытаемся поставить рекорд: набрать
        максимальное количество очков в ерии бросков без промаха. Как только мы
        промахиваемся, серия заканчивается.
      </p>
      <p>
        Напишем программку, которая фиксирует эти рекорды. С помощью команды
        <span>Math.round(Math.random() * (21) - 1)</span> мы получаем резултат
        очередного броска. Если попадание, то возвращает число от
        <span>1</span> до <span>20</span>, если произошёл промах, то возвращает
        <span>-1</span>.
      </p>
      <code>
        let score = Math.floor(Math.random() * (21) - 1); <br />
        <br />
        while (score &gt; -1) { <br />
        console.log(score); <br />
        score = Math.floor(Math.random() * (21) - 1); <br />
        }
      </code>
      <h3>Цикл while, суммирование</h3>
      <p>
        На предыдущем шаге вы написали основной цикл. Самое главное, что этот
        цикл умеет останавливаться!
      </p>
      <p>Вспомните условие:</p>
      <code> while (<b>score &gt; -1</b>) { } </code>
      <p>
        Чтобы цикл остановился, уловие когда-нибудь должно стать ложным. Чтобы
        это случилось, переменная <span>score</span> должна изменяться внутри
        цикла. Что мы и обеспечили, когда начинали на каждой итерацци записывать
        в переменную результат очередного броска.
      </p>
      <p>
        Если условие выхода из икла не сработает, то цикл не может остановиться.
        Это бесконечный цикл, одна из любимых ошибок программистов. Кстати, цикл
        <span>for</span> тоже можно сделать бесконечным.
      </p>
      <p>
        Часть логики работы программы готова: мы получаем результат всех бросок
        и останавлиаем игру, когда происхдит промах. Осталось посчитать сумму
        очков.
      </p>
      <p>
        Для этого до цикла объявим переменную <span>total</span> и в каждой
        итерации будем прибавлять к ней очки, полученные за бросок.
      </p>
      <p>И, напоследок, выведем результат игры в консоль:</p>
      <code>
        let score = Math.floor(Math.random() * 21) - 1; <br />
        let total = 0; <br />
        <br />
        while (score &gt; -1) { <br />
        total += score; <br />
        score = Math.floor(Math.random() * (21) - 1); <br />
        } <br />
        <br />
        console.log('Счёт: ' + total)
      </code>
      <h3>Ещё один проект: дартс-машина</h3>
      <p>У нас новая задача: драйвер для игрового дартс-автомата.</p>
      <p>Правила работы автомата:</p>
      <ul>
        <li>Каждая игра начинается с <span>0</span> очков.</li>
        <li>Чтобы выыиграть, нужно набрать <span>100</span> и более очков.</li>
        <li>
          В процессе игры можно совершить не более трёх промахов, иначе
          проиграеш.
        </li>
      </ul>
      <p>
        В процессе написания программы мы разберём использования цикла
        <span>while</span>, а также операторов <span>break</span> и
        <span>continue</span>.
      </p>
      <p>
        Иногда программисты создают бесконечные циклы по ошибке, неправильно
        написав условие выхода. Такие циклы могут "подвесить" окно браузера, в
        котором они исполняются. Но если пользоваться бесконечными циклами
        осмысленно, они могут принести пользу.
      </p>
      <p>
        Мы создадим цикл, внутри которого будет происходить подсчёт очков,
        используя конструкцию <span>while</span>. Внутри условия выхода нам
        нужно каждый раз провеять, набрал ли игрок необходимое количество очков.
      </p>
      <p>
        На первом шаге мы изменим условие так, чтобы игра заканчивалась при
        достижении ста очков:
      </p>
      <code>
        let score = 0; <br />
        let total = 0; <br />
        let victoryPoints = 100; <br />
        <br />
        while (total &lt; victoryPoints) { <br />
        score = Math.floor(Math.random() * (21) - 1); <br />
        total += score; <br />
        <br />
        console.log(score) <br />
        } <br />
        <br />
        console.log('Счёт: ' + total)
      </code>
      <h3>Дартс-машина: накапливаем промахи</h3>
      <p>Наша программа работает! Но мы постоянно выигрываем.</p>
      <p>
        Давайте добавим немного интриги и будем прерыват цикл, как только мы
        промахнулись три раза.
      </p>
      <p>
        Для этого нам понадобится переменная, которая будет считать промахи,
        назовём её <span>misses</span>. Каждый раз, когда игрок промахивает, мы
        будем увеличивать эту переменную на единицу.
      </p>
      <p>
        Программа возвращает <span>-1</span>, если игрок промахнулся. Поэтому
        внури цикла нужно добавить проверку, что результат текущего броска
        меньше нуля. И если проверка срабатывает, то пишем в консоль про промах
        и увеличиваем на единицу счётчик промахов.
      </p>
      <p>Действия внутри цикла должны будут выглядеть так:</p>
      <ol>
        <li>Получаем результат броска.</li>
        <li>
          Проверяем, что результат броска менше нуля. Если это так, то переходим
          к шагу три, иначе к шагу четыре.
        </li>
        <li>
          Пишем в консоль про промах и увеличиваем счтчик промахов на единицу.
        </li>
        <li>
          Увеличиваем общий резултат <span>total</span> и выводим результат
          броска в консоль.
        </li>
      </ol>
      <p>Код выглядит следующим образом:</p>
      <code>
        let score = 0; <br />
        let total = 0;<br />
        let victoryPoints = 100;<br />
        let misses = 0; <br />
        <br />
        while (total &lt; victoryPoints) { <br />
        score = Math.floor(Math.random() * (21) - 1); <br />
        if (score &lt; 0) { <br />
        misses++; <br />
        console.log('Промах!') <br />
        } else { <br />
        total += score; <br />
        console.log('Результат броска: ' + score) <br />
        } <br />
        } <br />
        <br />
        console.log('Счёт: ' + total) <br />
      </code>
      <h3>Дартс-машина: поражение</h3>
      <p>Пора вырваться из бесконечной серии побед!</p>
      <p>
        Программа уже умеет накапливать промахи в переменной <span>misse</span>.
        Осталось научить её завершать цикл по достижению трёх промахов. Но в
        каком месте цикла проверять это условие? В начале, середине или конце?
      </p>
      <p>Вот текущйи порядок команд в цикле:</p>
      <ol>
        <li>Получаем результат броска.</li>
        <li>
          Проверяем, что результат броска менше нуля. Если это так, то переходим
          к шагу три, иначе к шагу четыре.
        </li>
        <li>
          Пишем в консоль про промах и увеличиваем счтчик промахов на единицу.
        </li>
        <li>
          Увеличиваем общий резултат <span>total</span> и выводим результат
          броска в консоль.
        </li>
      </ol>
      <p>
        Нам нужна проверка команд, которая будет прерывать выполнение цикла.
      </p>
      <p>
        Такой командой в JavaScript является оператор <span>break</span>.
        Добавим в начало цикла проверку количества промахов и, как только
        промахов станет три - выходим из цикла.
      </p>
      <p>
        Аналогично оператору прерывания цикла <span>break</span> существует
        оператор для быстрого перехода к следующей итерации цикла
        <span>continue</span>, но используют его крайне редко, так как он
        усложняет чтение кода и понимание работы цикла в целом. Использование
        <span>continue</span> без необходимости обычно является дурным тоном.
      </p>
      <ul>
        <li>
          Внутри <span>while</span> команда <span>continue</span> "перематывает"
          программу сразу к началу <i>следующей</i> итерации.
        </li>
        <li>
          Внутри <span>for</span> команда <span>continue</span> "перематывает"
          программу к дополнительной чати <i>текущей</i> итерации, после
          выполнения которой начинается <i>следующая</i> итерация цикла.
        </li>
      </ul>
      <code>
        let score = 0; <br />
        let total = 0;<br />
        let victoryPoints = 100;<br />
        let misses = 0; <br />
        <br />
        while (total &lt; victoryPoints) { <br />
        if ( misses >= 3) {<br />
        break<br />
        }<br />
        score = Math.floor(Math.random() * (21) - 1); <br />
        if (score &lt; 0) { <br />
        misses++; <br />
        console.log('Промах!') <br />
        } else { <br />
        total += score; <br />
        console.log('Результат броска: ' + score) <br />
        } <br />
        } <br />
        <br />
        console.log('Счёт: ' + total) <br />
      </code>
      <h3>Дартс-машина: итоговое табло</h3>
      <p>Подсчёт очко и проахов завершены. Самое время вывести результаты.</p>
      <p>
        Выведем в консоль результаты игры: победа и поражение. Также отобразим
        статистику, включающую количество набранных очков и количество промахов.
      </p>
      <p>
        Как опередилть победу или поражение? Если после цикла количество очков
        больше или равно ста, то это победа. Иначе это поражение.
      </p>
      <p>Вот и всё, программа готова!</p>
      <p>И помните: даже бесконечный цикл всегда должен заканчиваться!</p>
      <code>
        let score = 0; <br />
        let total = 0; <br />
        let victoryPoints = 100; <br />
        let misses = 0; <br />
        <br />
        while (total &lt; victoryPoints) { <br />
        if (misses >= 3) { <br />
        break; <br />
        } <br />
        score = Math.floor(Math.random() * 21 - 1); <br />
        if (score &lt; 0) { <br />
        misses++; <br />
        console.log("Промах!"); <br />
        } else { <br />
        total += score; <br />
        console.log("Результат броска: " + score); <br />
        } <br />
        } <br />
        <br />
        if (total &lt; 100) { <br />
        console.log("Счёт: " + total + ". Вы проиграли :("); <br />
        } else { <br />
        console.log("Счёт: " + total + ". Вы победили! :)"); <br />
        }
      </code>
  
    </main>
    <footer>
      <h3>Здесь могла быть ваша кувшинка</h3>
    </footer>
    <script src="Циклы/Дартс-машина.js"></script>
  </body>
</html>