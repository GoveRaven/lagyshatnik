<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>Объекты</title>
    <link rel="stylesheet" href="../../стили/Полигон.css" />
  </head>
  <body>
    <header>
      <img
        src="../../avatar/avatar1.jpg"
        width="90"
        height="90"
        alt="Лягушка"
      />
      <nav>
        <a href="../../Полигон.html">Назад</a>
      </nav>
    </header>
    <main>
      <h2>Объекты</h2>
      <h3>Сыграем?</h3>
      <p>
        У вас выдалось немного свободного времени между бесконечными
        поручениями. Почему бы не написать что-то для себя, например, игру в
        кости?
      </p>
      <p>
        Принцип такой - игроки по очерди бросают две игральные кости. Результат
        броска - очки учатника. Побеждает тот, кто набрал большее количество
        очков. Для интриги у каждого игрока будет три попытки.
      </p>
      <p>
        Будем писать программу постепенно и начнём с того, что создадим функцию
        <span>runGame</span>, где в будущем будет запускатьс игра (броски костей
        и накопление очков).
      </p>
      <p>
        Для броска игральных костей воспользуемся функцией
        <span>Math.random(min, max)</span>, котора генерирует случайные числа в
        заданном промежутке, включая минимальное и максимальное значение. Чтобы
        числа получались целыми, добавим <span>Math.round</span>.
      </p>
      <p>
        Если бросать одну кость, то можно выбросить число от <span>1</span> до
        <span>6</span>, ведь у кости шесть граней. А если бросать две кости, то
        получится число от <span>2</span> до <span>12</span>.
      </p>
      <p>
        Ясно, передаём в функцию аргументы <span>2</span> и <span>12</span>?
        Нет, сделаем лучше! Привяжем аргументы к количеству костей: если кость
        одна, то значения аргументов будут одни, если кости три, то другие.
      </p>
      <p>
        Худший результат в игре получается, когда на всех костях выпала единица,
        а лучший, если выпали все шестёрки. Получатеся, что минимальное
        значечние равно количеству костей, а максимальное -
        <span>6 * количество костей</span>.
      </p>
      <p>
        Осталось объявить переменную, которая будет хранть количество костей и
        использовать её для вычисления аргументов функции <span>runGame</span>.
      </p>
      <code>
        let diceNumber = 2; <br />
        let runGame = function (quantity) { <br />
        console.log(Math.round(Math.random() * quantity * 6)); <br />
        }; <br />
        <br />
        runGame(diceNumber);
      </code>
      <h3>Игроки, в студию!</h3>
      <p>
        Теперь, когда мы убедились, что бросок костей работает надо ввести
        игроков, которые будут бросать эти самые кости и получать игровые очки в
        результате броска.
      </p>
      <p>
        Пусть игроками будут Кекс и его приятель Рудольф. Добавим переменные для
        хранения очков и имени каждого игрока, чтобы в дальнейшем определять и
        выводить результаты победителя в консоль. Получаетсся, для каждого
        игрока будут созданы две переменные: имя и очки.
      </p>
      <p>
        А так как у нас есть функция, внутри которой будут начисляться и
        выводиться в консоль игровые очки, переменные с именами и очками игроков
        должны передаваться в эту функцию. Да, у функции
        <span>runGame</span> теперь будет пять параметром, но что поделать?
        Такова игра.
      </p>
      <p>
        Кстати, обратите внимание, что название переменных и параметров функции
        не совпадают. Переменная, хранящая количество костей, называется
        <span>diceNumber</span>, а имя соответствующего параметра
        <span>quantity</span>. Дело в том, что функция
        <span>runGame</span> абстрактная. Мы учитываем, что игра может
        измениться. Например, игроки захотят играть в карты. Именно поэтому и
        параметры, которые хранят данные игроков мы назовём абстрактно -
        <span>firstPlayerName</span>, <span>firstPlayerPoints</span>,
        <span>secondPlayerName</span>, <span>secondPlayerPoints</span>.
      </p>
      <code>
        let diceNumber = 2; <br />
        let firstCatName = 'Кекс'; <br />
        let firstCatPoints = 0; <br />
        let secondCatName = 'Рудольф'; <br />
        let secondCatPoints = 0; <br />
        <br />
        let runGame = function (quantity, firstPlayerName, firstPlayerPoints,
        secondPlayerName, secondPlayerPoints) { <br />
        console.log(Math.round(Math.random() * quantity * 6)); <br />
        }; <br />
        <br />
        runGame(diceNumber, firstCatName, firstCatPoints, secondCatName,
        secondCatPoints);
      </code>
      <h3>Моя попытка номер раз</h3>
      <p>
        У нас есть два игрока, гтовых бросать кости. Дадим им возможность
        совершить первый бросок!
      </p>
      <p>
        Мы уже передали переменные <span>firstCatName</span>,
        <span>firstCatPoints</span>, <span>secondCatName</span>,
        <span>secondCatPoints</span> в функцию <span>runGame</span>. Используем
        их, чтобы увеличивать игровые очки котов на результат броска и выводить
        новое значение в консоль, указывая, какому именно игроку принадлежит
        результат.
      </p>
      <h3>Привет, объект!</h3>
      <p>
        Каждый игрок бросает кости и получает игровые очки, всё работает, но
        обратите внимание на количество параметров в функции
        <span>runGame</span>. Что будет, если игроков станет три, четыре, пять,
        десять? А если характеристик каждого игрока станет больше? Ответ
        очевиден: функция с сорока двумя параметрами. Но этим путём мы не
        пойдём.
      </p>
      <p>
        У каждого игрока есть набор показателей: имя и очки. Есть ли более
        удобный способ хранения значений, относящихся к одной сущности? Есть,
        это <b>объекты</b>.
      </p>
      <p>
        Объект - тип данных, который хранит в себе информацию в виде пар
        "ключ-значение". Если массив - нумерованный список, где каждый элемент
        имеет свой порядковый номер, то объект - список, в котором каждый
        элемент сопоставлен со своим ключом и порядком совсем неважен.
        Рассмотрим объекты на примере. Опишем объект кота.
      </p>
      <p>
        <b>Создаём объект.</b> В первую очередь объект надо создать. Для этого
        использую уже знакомые вам фигурные скобки <span>{ }</span>. Дадим
        объекту имя, оно задаётся точно так же, как и имя любой переменной.
      </p>
      <code>
        let cat = {}; <br />
        // Так создаётся объект с именем cat
      </code>
      <p>
        <b>Добавляем свойства.</b> Пары "ключ-значение", которые содержит в себе
        объект, называются свойствами или атрибутами. Выглядят они так:
      </p>
      <code>
        let cat = { <br />
        name: 'Кекс', <br />
        // Добавили новое свойство, где name - ключ, 'Кекс' - значение <br />
        age: 5 <br />
        // Новое свойство. Ключ - age, значение - 5 <br />
        };
      </code>
      <p>
        Свойсвта называются по имени ключа, то есть можно сказать, что у объекта
        кота есть свойствао для хранения имени, где ключ <span>name</span>, а
        значение <span>'Кекс'</span> или, что у объекта кота есть свойство
        <span>name</span> со значением <span>'Кекс'</span>.
      </p>
      <p>Несколько правил синтаксиса:</p>
      <ul>
        <li>Ключ обособляется от значения двоеточием.</li>
        <li>Пары 'ключ-значение' отделяются друг от друга запятыми.</li>
        <li>
          Значениями могут быть данные любого типа (число, строка, массив и так
          далее).
        </li>
      </ul>
      <p>
        Давайте вместо набора переменных создадим объекты игроков. У каждого
        игрока будет свойство с именем и игровыми очками
      </p>
      <code>
        let firstCat = { <br />
        name: 'Кекс', <br />
        points: 0 <br />
        } <br />
        <br />
        let secondCat = { <br />
        name: 'Рудольф', <br />
        points: 0 <br />
        }
      </code>
      <h3>Читаем из объекта</h3>
      <p>
        Мы создали объекты игроков, а что с ними делать дальше? Конечно, их надо
        передать в функцию <span>runGame</span> вместо переменных, которые
        содержали имена и очки. Но как их использовать внутри функции?
      </p>
      <p>
        К свойствам объекта можно обращаться и получать их значения. Для доступа
        к отдельному свойству есть два способа, один мы рассмотрим сейчас, а со
        вторым познакомимся чуть позже.
      </p>
      <p>
        Чтобы получить значение свойства, к нему надо обратиться через точку
        <span>объект.ключ</span>. Такая запись называется
        <i>точечной нотацией</i> и возвращает значение свойства объекта, если
        такое свойство есть. В противном случае вы получите
        <span>underfined</span>, то есть ничего. На практике это выглядит так:
      </p>
      <code>
        let cat = { <br />
        name: 'Кекс',<br />
        age: 5<br />
        }<br />
        console.log(cat.name); // Выведет в консоль: Кекс <br />
        console.log(cat.age); // Выведет в консоль: 5 <br />
        console.log(cat.color); // Выведет в консоль: underfined. Такого ключа в
        объекте нет <br />
      </code>
      <p>
        Заменим в параметрах функции <span>runGame</span> переменные на объекты
        игроков, с учётом этого заменим обращение к параметрам в теле функции.
      </p>
      <code>
        let runGame = function (quantity, firstPlayer, secondPlayer) { <br />
        console.log(firstPlayer.points += Math.floor(Math.random() * quantity *
        6 + 1)); <br />
        console.log(secondPlayer.points += Math.floor(Math.random() * quantity *
        6 + 1)); <br />
        console.log(firstPlayer.name + ' выбросил: ' + firstPlayer.points);
        <br />
        console.log(secondPlayer.name + ' выбросил: ' + secondPlayer.points)
        <br />
        }; <br />
        <br />
        runGame(diceNumber, firstCat, secondCat);
      </code>
      <h3>По порядку рассчитайсь!</h3>
      <p>
        С помощью объектов мы удобно описали игроков и теперь используем эти
        данные в функции. Параметров стало меньше, но снова возникает вопрос о
        росте количества участников игры. Что делать, если их станет десять?
        Создавать ещё объект? Да! Но есть два минуса:
      </p>
      <ul>
        <li>Число параметров будет расти вместе с числом игроков.</li>
        <li>
          Код в теле функции будет раздуваться, ведь для каждого игрока есть
          строчка с увеличением очков и выводом результатов в консоль. Чем
          больше игроков, тем больше кода будет в функции.
        </li>
      </ul>
      <p>
        Было бы здорово написать код функции так, чтобы она работала для любого
        количества игроков. Есть ли такая структура, которая может хранить в
        себе много данных и которую удобно обрабатывать? Да! Массивы! И вы с
        ними уже знакомы!
      </p>
      <p>
        Вот краткое напоминание на всякий случай: массив - список элементов. У
        каждого из них есть порядкой номер. Массивы и чтение из них выглядят
        так:
      </p>
      <code>
        // Массив чисел <br />
        let array = [10, 20, 30, 40, 50]; <br />
        <br />
        // Читаем элементы из массива по индексу (порядковому номеру) <br />
        console.log(array[0]); // Выведет: 10
      </code>
      <p>
        Вернёмся к нашей задаче и введём массив с объектами игроков. Будем
        передавать в функцию именно его. Тогда мы сможем перебирать массив в
        цикле и для каждого игрока делать одно и то же: бросать кубики,
        записывать результат и показывать его
      </p>
      <code>
        let runGame = function (quantity, players) { <br />
        for (i = 0; i &lt; players.length; i++) { <br />
        console.log(players[i]) <br />
        } <br />
        };
      </code>
      <h3>Переопределяем свойства объекта</h3>
      <p>
        Мы убедились, что цикл внутри функции работает и в консоль выводится
        текущий элемент массива игроков. Что дальше?
      </p>
      <p>
        После каждого броска мы должны увеличивать игровые очки на результат
        этого броска. Получается запись вида
        <span>player.points += результат броска</span>. Как это работает?
      </p>
      <p><b>Переопределение свойств.</b></p>
      <p>
        Свойства объектов можно не только читать, но и переопределять, как и
        обычные переменные. Вернёмся к объекту кота.
      </p>
      <code>
        let cat = { <br />
        name: 'Кекс',<br />
        age: 5<br />
        }<br />
        <br />
        cat.age++; // Увеличили возраст кота на 1<br />
        console.log(cat.age) // Выведет в консоль: 6 <br />
        <br />
        cat.name = 'Рокки' // Заменили снаружи значение свойства name <br />
        console.log(cat.name); // Выведет в консоль: Рокки
      </code>
      <p>
        Внутри цикла будет вызывать функцию броска <span>throwDice</span>,
        записывать результат в переменную и увеличивать на это значение игровые
        очки текущего игрока. Чтобы удобней было отследить событи в игре, будем
        выводить результат броска каждого игрока в консоль.
      </p>
      <p>
        Как вы уже знаете, при обращении <span>массив[индекс]</span> мы получаем
        элемент массива. В нашем случае это объект игрока, из которого можно
        читать, как из любого другого объекта через точку. Поэтому запись в теле
        нашего цикла <span>массив[индекс].ключ</span> то же самое, что запись
        <span>объект.ключ</span> при работе с объектами напрямую.
      </p>
      <code>
        let runGame = function (quantity, players) { <br />
        for (i = 0; i &lt; players.length; i++) { <br />
        let throwResult = Math.floor(Math.random() * quantity * 6 + 1); <br />
        players[i].points += throwResult; <br />
        console.log(players[i].name + ' выбросил: ' + players[i].points); <br />
        } <br />
        };
      </code>
      <h3>Передаём объект по ссылке</h3>
      <p>
        Перед тем, как мы продолжим писать игру в кости, рассмотрим одну важную
        особенность объектов на практике.
      </p>
      <code>
        let cat = { <br />
        name: 'Кекс',<br />
        age: 5<br />
        }<br />
        <br />
        let secondCat = firstCat; <br />
        console.log(secondCat); // Выведет: {name:'Кекс', age:5} <br />
        <br />
        firstCat.name = 'Снежок'; <br />
        console.log(secondCat);<br />
        // Выведет: {name:'Снежок', age:5}
      </code>
      <p>
        Мы же не трогали второй объект <span>secondCat</span>, но он изменился
        вместе с первым обектом <span>firstCat</span>. Почему так?
      </p>
      <p>
        Объект здесь всегда один, в памяти не создаётся новое место под копию
        объекта. Каждая переменная содержит не новую отдельную сущность, а
        ссылку на один-единственный объект. Поэтому когда мы меняем что-то в
        объекте через одну из переменных, в которой содержится ссылка на него,
        изменения видны во всех других переменных, будь их хоть двадцать или
        сорок. Это важная особенность объектов, которую надо запомнить. Она так
        и называется - <i>передача объектов по ссылке</i>.
      </p>
      <p>
        В нашей программе происходит то же самое. Мы создаём массив
        <span>cats</span> с объектами игроков и передаём его в функцию
        <span>runGame</span>. Внутри функции мы используем этот массив под
        другим именем, <span>players</span>, и меняем хранящиеся в нём объекты.
        Если после окончания рботы функции вывести <span>cats</span> в консоль,
        то окажется, что его содержимое поменялось, хотя мы ничего не возвращали
        из функции и вроде бы работали с совсем другим массивом.
      </p>
      <p>
        Несмотря на то, что такое поведение объектов - известный факт, работа
        программы может стать неоччевидной, если мы захотим передать изменённый
        массив ещё куда-то, ведь мы меняем массив неявно по ходу работы цикла.
        Код нужно писать максимально просто и понятно для себя и других
        разработчиков. Поэтому мы будем возвращать изменённый массив
        <span>players</span> из функции и записывать его в массив
        <span>cats</span>, явно обновляя его.
      </p>
      <code>
        let runGame = function (quantity, players) { <br />
        for (let i = 0; i &lt; players.length; i++) { <br />
        let throwResult = Math.floor(Math.random() * quantity * 6 + 1); <br />
        players[i].points += throwResult; <br />
        console.log(players[i].name + " выбросил: " + players[i].points); <br />
        } <br />
        return players <br />
        }; <br />
        <br />
        cats = runGame(diceNumber, cats);
      </code>
      <h3>Моя игра</h3>
      <p>
        Наши игроки бросают кости, получают игровые очки, вроде всё здорово, но
        чего-то внутри игрового цикла не хватает. Чего же?
      </p>
      <p>
        Сейчас каждый игрок бросает кости один раз, а в нашей игре игрок имеет
        три попытки для броска. Пора записать это рпавило в виде кода.
      </p>
      <p>
        Для начала нам нужно добавить переменную, которая будет содержать
        количество попыток игроков. Или не переменную?
      </p>
      <p>
        В игре уже есть переменная, которая хранит количество игральных костей.
        Вместе с переменной количества попыток они образуют игрвые правила.
        Поэтому создадим единную сущность с правилами, объект
        <span>gameRules</span>.
      </p>
      <p>
        Перед дополнением игрвоого цикла придётся поправить параметры, аргументы
        и код в теле функции <span>runGame</span> с учётом нового объекта с
        правилами игры.
      </p>
      <code>
        let gameRules = { <br />
        diceNumber: 2, <br />
        maxAttempts: 3 <br />
        } <br />
        <br />
        let runGame = function (rules, players) { <br />
        for (let i = 0; i &lt; players.length; i++) { <br />
        let throwResult = Math.floor(Math.random() * rules.diceNumber * 6 + 1);
        <br />
        players[i].points += throwResult; <br />
        console.log(players[i].name + " выбросил: " + players[i].points); <br />
        } <br />
        return players; <br />
        }; <br />
        <br />
        runGame(gameRules, cats);
      </code>
      <h3>Раздаём попытки</h3>
      <p>
        Мы создали объект с правилами игры и теперь можем добавить каждому
        игроку по три попытки броска. В этом нам поможет цикл.
      </p>
      <p>
        Введём счётчик, чтобы следить за количеством попыток и выходить из
        цикла, когда число будет равно <span>3</span>. Назовём счётчик
        <span>currentAttemt</span> и начнём отсчёт с <span>1</span>, ведь в игре
        в кости нет нулевой попытки.
      </p>
      <p>
        Обернём в ноывй цикл всю логику из тела функции <span>runGame</span> и
        игроки начнут бросать кости по три раза. Получится цикл в цикле. Если
        поменять число в <span>gameRules.maxAttempts</span>, программа всё равно
        будет работать корректно, бросков будет столько, сколько вы укажите.
      </p>
      <code>
        let runGame = function (rules, players) { <br />
        for ( <br />
        let currentAttempt = 1; <br />
        currentAttempt &lt;= rules.maxAttempts; <br />
        currentAttempt++ <br />
        ) { <br />
        for (let i = 0; i &lt; players.length; i++) { <br />
        let throwResult = Math.floor(Math.random() * rules.diceNumber * 6 + 1);
        <br />
        players[i].points += throwResult; <br />
        console.log(players[i].name + " выбросил: " + throwResult + '. Общее
        количество очков: ' + players[i].points); <br />
        } <br />
        } <br />
        return players; <br />
        };
      </code>
      <h3>Кому отдать победу?</h3>
      <p>
        Мы сделали самое сложное - разложили игу на составляющие и написали
        игровой цикл.
      </p>
      <p>
        Пока мы можем определить победителя игры, посмотрев на список игровых
        очков в консоли. Сделаем так, чтобы программа сама выявляла чемпиона.
        Будем писать код в несколько этапов, проверяя работу программы на каждом
        шану.
      </p>
      <p>
        Создадим функцию <span>getWinners</span>, которая будет получать массив
        игроков, обрабатывать его и определять победителей.
      </p>
      <p>
        Задача нахождения чемпиона похожа на поиск максимального элемента в
        массиве: нам нужно пройтись по массиву игроков и найти того, кто набрал
        наибольшее кличество очков. Тут есть сложность: победителей может
        оказаться больше одного, ведь по ходу игры несколько игроков могут
        набрать одинаковое количесто очков. Как быть в этом случае?
      </p>
      <p>
        Оптимизируем алгоритм поска максимального элемента в массие так, чтобы
        учитывались все игроки с наибольшим количеством очков. Для этого мы
        заведём массив победителей. Чаще всего этот массив будет состоять из
        одного элемента, но если в игре окажется несколько чемпионов, мы никого
        не обидим и запишем всех в ряды победителей.
      </p>
      <p>
        Для начала введём пустой массив, врнём его из <span>getWinners</span> и
        проверим, что всё работает.
      </p>
      <code>
        let getWinners = function (players) { <br />
        let winners = []; <br />
        return winners <br />
        } <br />
        <br />
        let tops = getWinners(cats) <br />
        console.log(tops)
      </code>
      <h3>Огласить весь список, пожалуйста</h3>
      <p>
        Новая функция работает. Начнём описывать логику выявления победителя.
      </p>
      <p>
        В функцию <span>getWinners</span> мы передаём массив игроков, которые
        уже использовали попытки для бросков и имеют какое-то количество игровых
        очков. В первую очередь мы будет перебирать этот массив и выводить в
        онскол текущий элемент. Снова проверим, что всё работает и только потом
        будем писать код дальше. Программа становится всё больше и сложнее,
        поэтому проверять работоспособность кода на каждом шаге очень полезно,
        так мы минимизируем ошибки в игре.
      </p>
      <code>
        let getWinners = function (players) { <br />
        let winners = []; <br />
        for (let i = 0; i &lt; players.length; i++) { <br />
        let currentPlayer = players[i]; <br />
        console.log(currentPlayer); <br />
        } <br />
        return winners; <br />
        };
      </code>
      <h3>Ищм результативного кота</h3>
      <p>
        Теперь, когда мы убедились, что цикл работаает корректно, начнём искать
        победителя, то есть игрока с максимальным количеством очков.
      </p>
      <p>
        В первую очередь нужно выбрать игрова, с которым мы будем сравнивать
        резульатты остальных игроков. Так как мы храним игроков в массиве,
        логично и удобно для начала назначить первого участника, как самого
        результативного.
      </p>
      <p>
        Будем перебирать элементы массива в цике и сравнивать количество очков с
        первым игроком. Если у како-то игрока результат лучше, назначим его
        чемпионов и продолжим сравнение уже с этим игроком. Чтобы отслеживать
        изменения победителей, будем выводить максимальный результат в консоль.
      </p>
      <code>
        let getWinners = function (players) {<br />
        let winners = [];<br />
        let max = players[0]<br />
        for (let i = 0; i &lt; players.length; i++) {<br />
        let currentPlayer = players[i];<br />
        if (max.points &lt; currentPlayer.points) {<br />
        max = currentPlayer<br />
        console.log('Новый рекордсмен: ' + currentPlayer.points)<br />
        }<br />
        }<br />
        return winners;<br />
        };
      </code>
      <h3>Никому не спрятаться</h3>
      <p>
        Мы научились находить победителей, а теперь начнём записывать их в
        массив <span>winners</span>. При переборе массива игроков возможны две
        интересные ситуации.
      </p>
      <p>
        В первой мы встречаем игрока, у которого очков больше, чем у текущего
        чемпиона. Такой случай мы уже умеем обрабатывать. Осталось правильно
        внести данные в массив победителей.
      </p>
      <p>
        Рекордсменов мы находим по одному, поэтому и в массиве победителей игрок
        должен оказаться гордом одиночестве. Удаляем бывших рекордсменов из
        массива и записываем туда нового потенциального чемпиона. Легче всего
        это сделать, полностью перезаписав массив:
      </p>
      <code>
        // Записываем в winners массив из дного элемента, max <br />
        winners = [max];
      </code>
      <p>
        Во втором ситуации мы встречаем игрока с таким же количеством очков, как
        у текущего претендента на победу. Этот случай мы пока не описали. Как
        понять, что мы встретили равного сильнейшему? Например, вот так:
      </p>
      <code>
        <i>Если</i> у текущего игрока очков больше, чем у чемпиона, <br />
        то делаем его новым победителем. <br />
        <i>ИначеЕсли</i> у текущего игрока очков столько же, сколко у чемпиона,
        <br />
        то добавляем его в массим победителей.
      </code>
      <p>
        То есть мы можем использовать вложенное условие внутри альтернативной
        ветки проверки на чемпионство.
      </p>
      <p>
        Чтобы добавить несколько победителей в массив, удобнее использовать
        метод <span>push</span>. Этот метод добавляет переданные ему элементы в
        конец указанного массива. Например:
      </p>
      <code>
        let purchases = ['молоко', 'кефир']; <br />
        <br />
        purchases.push('колбаса', 'конфеты', 'мармелад');
        console.log(purchases); // Выведет: ['молоко', 'кефир', 'колбаса',
        'конфеты', 'мармелад']
      </code>
      <p>А теперь попробуем это реализовать в наш код.</p>
      <code>
        let getWinners = function (players) { <br />
        let winners = []; <br />
        let max = players[0]; <br />
        <br />
        for (let i = 0; i &lt; players.length; i++) { <br />
        let currentPlayer = players[i]; <br />
        if (max.points &lt; currentPlayer.points) { <br />
        max = currentPlayer; <br />
        winners = [max]; <br />
        } else { <br />
        if (max.points === currentPlayer.points) { <br />
        winners.push(currentPlayer); <br />
        } <br />
        } <br />
        } <br />
        return winners; <br />
        };
      </code>
      <h3>Новые условия</h3>
      <p>
        Мы использовали вложенные условия, чтобы добавить поверку на несколько
        победителей с одинаковыми результатами. Такие улови работают, но делают
        код трудночитаемым.
      </p>
      <p>
        Есть более удобный способ записи - цепочка условных конструкций. Она
        подходит, когда необходимо проверить больше двух условий и закончить
        проверку, если какое-то из условий срабатывает.
      </p>
      <p>
        Синтаксис вам знаком, тольков во второй и последующих ветках
        <span>if</span> можно писать через пробел сразу после <span>else</span>,
        а затем добавить новое условие. Тогда, если первая проверка не
        выполнитсяя, программа проверит условие в следующей ветке. Если и там
        условие неверно, код будет проверять дальше. В конце конструкции можно
        добавить ветку с обычным <span>else</span> на случай, если ни одно из
        предыдущих условий н будет выполнено.
      </p>
      <code>
        if (max.points &lt; currentPlayer.points) { <br />
        max = currentPlayer;<br />
        winners = [max];<br />
        } else if (max.points === currentPlayer.points) {<br />
        winners.push(currentPlayer);<br />
        }
      </code>
      <h3>Большая редкость</h3>
      <p>
        Мы написали ещё одну функцию и теперь программа умеет определять
        победителей игры, но пока никуда их не выводить. Напишем ещё немного
        кода, чтобы имена победителей и их игровые очки выводились в консоль.
      </p>
      <p>
        Начнём с того, что создадим функцию <span>printWinners</span> и
        обработаем редку ситуацию, когда все игроки выбросили одинаковое
        количество очков. Чем игроков больше, тем меньше вероятность ничейного
        результата, но такое может случиться, и мы должны учесть такой поворот
        событий.
      </p>
      <p>
        Как определить, что все игроки набрали одинаковое количество очков?
        Достаточно передать в функцию <span>printWinners</span> массив игроков и
        массив победителей, првоерить длины этих массивом и, если они совпадают,
        значит у нас коллективная ничься. Ведь победителей не может быть больше,
        чем игроков, а если их меньше, значит, выиграли не все.
      </p>
      <code>
        let printWinners = function (players, winners) {<br />
        if ((players.length === winners.length)) {<br />
        console.log("Все игроки как на подбор!");<br />
        }<br />
        };
      </code>
      <h3>Выводим на чистую воду</h3>
      <p>
        Мы обработали ситуацию с одинаковым результатом у всех игроков. При
        встрече этого редкого события можно вывести сообщение в консоль и сразу
        же завершить работу функции. Этот приём позволяет упростить дальнешие
        проверки, ведь мы точно знаем, что одно условие уже обрабатывать не
        нужно.
      </p>
      <p>
        Теперь опишем случаи, когда победителей несколько (но не все) или один.
        Что для этого нужно?
      </p>
      <ul>
        <li>
          Если победили не все участники, сообщение будет начинаться одинаково,
          со слова "Победил". Поэтому создадим переменную, которая будет хранить
          начало сообщения. И не забудем про пробел после слова.
        </li>
        <li>
          Так как объекты победителей находятся в массиве, мы будем перебирать
          массив, получать имена игроков и добавлять их с помощью конкатенации
          строк в сообщение.
        </li>
        <li>
          Добавим в сообщение информацию о количестве игровых очков у
          победителей. Для этого не нужно перебирать массив, ведь результат у
          победителей одинаковый. Для простоты возьмём игровые очки первого
          игрока и добавим их в сообщениие.
        </li>
        <li>Выведем сообщение в консоль и поссмотрим, что получилось</li>
      </ul>
      <code>
        let printWinners = function (players, winners) { <br />
        if ((players.length === winners.length)) { <br />
        console.log("Все игроки как на подбор!"); <br />
        return <br />
        } <br />
        message = 'Победил '; <br />
        for (let i = 0; i &lt; winners.length; i++) { <br />
        message += winners[i].name <br />
        } <br />
        message += ' с количеством очков: ' + winners[0].points; <br />
        console.log(message); <br />
        };
      </code>
      <h3>Бросайте кости!</h3>
      <p>
        Наша игра полностью написана! Игроки бросают кости, победитель
        определяется программно, его имя и победные очки выводятся в консоль.
      </p>
      <p>
        Мы переживали, что же случится, если участников станет больше. Давайте
        проверим! Введём ещё одного игрока в игру, вдвоём скучно бросать кости,
        а втроём уже интересей.
      </p>
      <p>
        А потом попробуем поменять правила игры, чтобы првоерить, как программа
        рабоатет в разных условиях.
      </p>
      <code>
        let thirdCat = { <br />
        name: "Рокки", <br />
        points: 0, <br />
        }; <br />
        <br />
        let cats = [firstCat, secondCat, thirdCat];
      </code>
      <h3>Внесём корректировки</h3>
      <p>Кажется, программа работает как надо. Почти.</p>
      <p>
        Если побеждает один игрков, то мы получаем отличное сообщение вида
        "Победил Игрок с количеством очков: число".
      </p>
      <p>
        Если победителей несколько (и есть проигравшие), то сообщение выглядит
        хуже: "Победил ИгрокИгрокИгрок с количеством очков: число". Кажется,
        что-то пошло не так.
      </p>
      <p>
        Имена игроков в этом сообщении нужно отделить запятыми и пробелами. И
        конечно, если победителй несколько, они не "победил", а "победили".
        Программы программами, но грамотный русский язык никто не отменял.
      </p>
      <p>
        Чтобы привести сообщение с победителями в приемлемый вид, придётся
        добавить пару небольших проверок в функцию <span>printWinners</span>.
      </p>
      <code>
        message = "Победил "; <br />
        if (winners.length > 1) { <br />
        message = 'Победили ' <br />
        } <br />
        for (let i = 0; i &lt; winners.length; i++) { <br />
        if (i > 0) { <br />
        message += ' , ' <br />
        } <br />
        message += winners[i].name; <br />
        }
      </code>
      <h3>Собери сам!</h3>
      <p><i>Хватит бездельничать, пора за работу!</i></p>
      <p>
        <i
          >У нас новый проект, надо написать компьютерный магазин. Заказчик
          серьёзный, поэтому всё должно быть по уму. Вот небольшой ТЗ:</i
        >
      </p>
      <ul>
        <li>
          <i
            >Пользователь выбирает компьютер, а программа выводит результат
            заказа.</i
          >
        </li>
        <li>
          <i
            >В сообщении должны быть технические характеристики и итоговая цена
            товара.</i
          >
        </li>
        <li>
          <i
            >Есть базовая цена любого комьютера, а конечная сумма зависит от
            каждого технического показателя устройства.</i
          >
        </li>
      </ul>
      <p><i>Жду результата! Не подведи!</i></p>
      <p>
        Как и прежде, разберём задачу, чтобы понять, из чего будет состоять
        программа.
      </p>
      <p>
        Очевидно, что без функции тут не обойдётся. Будем передавать ей
        выбранный комьютер и получать итоговую сумму. При расчётах необходимо
        учесть базовую цену устройства и стоимость каждой характеристики.
        Например, цены компьютеров с экраном 13 и 15 дюймов будут отличаться.
        Полуается, у каждого устройства есть показатели: базовая цена и
        технические характеристики (оперативная память, процессов и размер
        дисплея). Иными словами, несколько свойств, относящихся к одной
        сущности, компьютеру. Вы уже догадались, где мы будем это хранит?
        Правилно, в объекте.
      </p>
      <p>
        В итоге у нас получится конфигуратор компьютера. В объекте будем хранит
        комьюте и его характеристики, а сам объект будет хранить в теле функции.
        Выбирая какое-то устройство, будем вызывать функцию-конфигуратор,
        которая будет записывать в объект комьютера его характеристики, считать
        цену и возвращать её наружу.
      </p>
      <p>
        Для начала создадим функцию <span>buildComputer</span>, заведём внутри
        объект <span>computer</span> и проверим, что функция возвращает.
      </p>
      <code>
        let buildComputer = function (memory, display, processor) { <br />
        let computer = { <br />
        basicPrice: 5000, <br />
        processor: processor, <br />
        display: display, <br />
        memory: memory, <br />
        }; <br />
        return computer; <br />
        }; <br />
        <br />
        let myComputer = buildComputer(8, 13, "i7"); <br />
        console.log(myComputer);
      </code>
      <h3>Мой первй метод</h3>
      <p>Функция и объект созданы. Идём дальше.</p>
      <p>
        Нам надо посчитать цену компьютера и вывести итоговое сообщение. Для
        этого нужно написать функции, и запишем мы их прямо в объект! Так можно!
      </p>
      <p>
        В объектах могут храниться любые типы данных, в том числе и функции.
        Такие свойства-функции называются <i>методом</i> объектов. Они
        вызываются так же, как и любые другие функции, через круглые скобки, а
        обращаемся мы к методоам, как и к свойства объекта. В итоге вызов метода
        записывается так: <span>объект.метод()</span>.
      </p>
      <p>
        Главное в создании метода - придумать подходящее название, описывающее,
        что делает этот метод. В мире программирования есть устоявшиеся традиции
        именования. Например, функции, которые что-то возвращают, называются
        геттерами и начинаются со слова <span>get</span>. Это выглядит так:
      </p>
      <code>
        let cat = { <br />
        name: 'Кекс', <br />
        color: 'рыжий', <br />
        age: 5, <br />
        <br />
        getGreeting: function() { <br />
        return 'Мяу, привет!'; <br />
        } <br />
        }; <br />
        <br />
        console.log(cat.getGreeting()); // Выведет: Мяу, привет!
      </code>
      <p>
        Раз методы это те же функции, почему мы вообще записываем их в объект, а
        не используем привычные внешние функции?
      </p>
      <p>
        Методы используются для работы с объектами. Они читают свойства,
        переписывают их и возвращают. Да, можно создать внешнюю функцию,
        передавать ей объект и обрабатывать внутри этой функции. Но намного
        удобнее держать в объекте всё, что относится именно к этому объекту.
        Например, мы храним технические характеристики внутри объекта
        компьютера, нам нужно возвращать строку с данными и высчитывать цену.
        Эти две задачи связаны именно с объектом компьютера, поэтому мы будем
        записывать эти функции в объект.
      </p>
      <p>
        Создадим простой геттер для объекта компьютера и проверим, всё ли
        работает, как надо.
      </p>
      <code>
        let computer = { <br />
        ...<br />
        getDescription: function (){<br />
        return 'компьютер';<br />
        }<br />
        <br />
        console.log('В корзине ' + myComputer.getDescription());
      </code>
      <h3>Реализуем методы</h3>
      <p>Мы убедились, что метод работает в объекте компьютера. Что дальше?</p>
      <p>
        Мейчас мы возвращаем просто слово "компьютер". Но метод
        <span>getDescription</span> должен возвращать описание устройства со
        всеми его характеристиками, которые храняться в свойствах объекта
        <span>computer</span>. Как это сделать? Можно ли изнутри методов объекта
        обращатся к его свойствам? Можно! Здесь нет никаких сложностей
        синтаксиса, пишем, как всегда <span>объект.свойство</span>.
      </p>
      <p>
        Переопределим метод <span>getDescription</span>. Пусть он возвращает
        строку с описанием выбранного компьютера. К свойствам, которые хранять
        технические характеристики устройства будем образаться через точку
        изнутри метода.
      </p>
      <p>
        Кстати, в объекте может быть много методов, а не один. Поэтому мы
        заведём ещё один и назовём его <span>getPrice</span>. Как понятно из
        названия, он будет возвращать цену компьютера.
      </p>
      <code>
        getDescription: function () { <br />
        return ("компьютер с процессором " + computer.processor + ", диагональю
        " + computer.display + ", оперативной памятью " + computer.memory);
        <br />
        }, <br />
        <br />
        getPrice: function () { <br />
        return computer.basicPrice; <br />
        }
      </code>
      <h3>Объкт как словарь</h3>
      <p>
        Теперь посчитаем цену компьютера. Она состоит из нескольких слагаемых:
        стартовой цены и стоимости каждой технической характеристики.
      </p>
      <p>
        Выходит, нам нужно проверять значения свойств в объекте компьютера и, в
        зависимост от результата, прибавлять к базовой цене ту или иную сумму. В
        итоге мы получим цену устройства. Для проверки каждой характеристики
        отдельно можно использовать конструкцию <span>else if</span>. Код
        получится рабочим, но получится слишком большим.Сейчас у нас только три
        характеристики, из которых складывается цена устройства, а что, если их
        станет больше?
      </p>
      <p>
        В некотрых ситуациях блоки с условиеями можно сократить с помощью
        объектов. Давайте разбираться, как это сделать. Рассмотрим пример.
      </p>
      <code>
        let printFavoriteFood = function (name) { <br />
        let message = 'Моя любимая еда - '; <br />
        <br />
        if (name === 'Кекс') { <br />
        message += 'рыба'; <br />
        } else if (name === 'Рудольф') { <br />
        message += 'котлета'; <br />
        } else if (name === 'Снежок') { <br />
        message += 'сметана'; <br />
        } <br />
        return message <br />
        }; <br />
        console.log(printFavoriteFood('Снежок')); // Выведет: Моя любимая еда -
        сметана
      </code>
      <p>
        Обратите внимание, что каждому коу, а точнее его имени, соответствует
        определённая еда. При этом порядок которов совсем неважен. Можно ли
        записать вкуовые предпочтения котов в объект? Давайте попробуем.
      </p>
      <code>
        let catsFavoriteFood = { <br />
        Кекс: 'рыба',<br />
        Рудольф: 'котлета',<br />
        Снежок: 'сметана'<br />
        };
      </code>
      <p>
        Можно ли теперь использовать данные в объекте
        <span>catsFavoriteFood</span> так, чтобы совсем избавиться от условий в
        теле функции <span>printFavoriteFood</span>? Можно! Перед нами обычный
        объекст со свойствами и их значениями. Значит, мы можем обратиться к
        свойству объекта и подставить в выражение строку, которая в нём
        содержится.
      </p>
      <code>
        let catsFavoriteFood = { <br />
        Кекс: 'рыба',<br />
        Рудольф: 'котлета',<br />
        Снежок: 'сметана'<br />
        }; <br />
        <br />
        let printFavoriteFood = function(name) { return 'моя любимая еда - ' +
        catsFavoriteFood[name] } console.log(printFavoriteFood('Снежок')); //
        Выведет: Моя любимая еда - сметана
      </code>
      <p>
        Код работет, как и прежде, зато насколько сократилась наша программа.
      </p>
      <p>
        Мы записали в объект не характерисику вида <span>name: 'Кекс'</span>, а
        соотношение имени кота и лакомства, которое по вкусу именно ему. Такие
        объекты называются <i>словарями, мапами</i> или
        <i>ассоциативными массивами</i>. Они очень удобны в использовании и
        позволяют писать код чище и проще.
      </p>
      <p>
        В нашей прграмме для каждого показателя подходит своя цена, например,
        для процессора 'i7' это <span>10000</span>, для дисплеера 13 дюймов это
        <span>5000</span>. Значит, мы можем сделать словари, которые будут
        хранить стоимость каждой характеристики, а затем обращаться к свойствам
        этих объектов, чтобы получить цену.
      </p>
      <code>
        let processorPrice = { <br />
        'i5': 5000,<br />
        'i7': 10000,<br />
        }<br />
        <br />
        let displayPrice = {<br />
        13: 5000,<br />
        15: 10000<br />
        }<br />
        <br />
        let memoryPrice = {<br />
        8: 3000,<br />
        16: 4000<br />
        }
      </code>
      <h3>Скобочная нотация</h3>
      <p>
        Раньше мы обращались к свойствам объекта с помощью точки, а в примере
        выше работаем с объектом как с массивом - читаем свойство с помощью
        квадратных скобок: <span>catsFavoriteFood[name]</span>. Да, так тоже
        можно. Способ со скобками называется <i>скобочной нотацией</i>, способ с
        точкой - <i>точечной нотацией</i>.
      </p>
      <p>
        Скобочная нотация намного гибче точечной. Например, вы можете прочитать
        из объекта свойство, название которого записано в переменную:
      </p>
      <code>
        let name = 'Кекс'; let catsFavoriteFood = { 'Кекс': 'рыба'};
        console.log(catsFavoriteFood.name); // Выведет в консоль: underfined
        console.log(catsFavoriteFood[name]); // Выведет в консоль: рыба
      </code>
      <p>
        Первое сообщение содержит <span>underfined</span>, потому что у объекта
        нет свойства <span>name</span>. Второе сообщение содержит искомое
        значение, потому что программа понимает, что в квадратных скобках
        переменная. Значение переменной подставится в скобки, а затем будет
        найдено нужное свойство объекта.
      </p>
      <code>
        console.log(catsFavoriteFood[name]); <br />
        // Незаметно внутри программа превращается в: <br />
        console.log(catsFavoriteFood['Кекс']); <br />
      </code>
      <p>
        И ещё один сюрприз. В качестве ключей в объекте можно использовать любые
        строки, даже строки с пробелами. С точечной нотациеей такие свойства
        прочитать не получится, а со скобочной - без проблем.
      </p>
      <code>
        let cat = { 'favorite food': 'Сметана'}; <br />
        console.log(cat.favorite food);<br />
        // Вызовет ошибку<br />
        console.log(cat['favorite food']);<br />
        //Отработет нормально
      </code>
      <p>
        Кстати, почему мы вынесли словари из функции в самое начало программы?
        Значения, которые храняться в этих объектах, не зависят от параметров
        функции или объекта компьютера. Это правило, относящиеся ко всей
        программе. Их можно использовать в других функциях и операциях, если это
        понадобится. Если бы словари находились в теле функции, они бы
        создавались только в момент вызова этой функции.
      </p>
      <p>
        Почему это вообще работает? Объект внутри функции видит объекты, которые
        объявлены в самом начале программы. Так работают области видимости. Мы
        разберём эту особенность языка позже.
      </p>
      <p>
        Теперь когда словари созданы, и мы научились с ними работать, можно
        посчитать цену компьютера одной строкой. Будем использовать метод
        <span>getPrice</span>. Переопределим его, добавив новые значения.
      </p>
      <code>
        getPrice: function () { <br />
        return ( <br />
        computer.basicPrice + <br />
        processorPrice[computer.processor] + <br />
        displayPrice[computer.display] + <br />
        memoryPrice[computer.memory] <br />
        );
      </code>
      <h3>Не будем вырывать из контекста</h3>
      <p>
        Наша программа! Вся необходимая функциональность написана! Осталось
        обсудить ещё один вопрос.
      </p>
      <p>
        Внутри методов мы обращались к свойствам объекта компьютера
        <span>computer.свойство</span>. А что, еси в будущем названи объекта
        изменится и количество свойств увеличится? Придётся везде исправлять
        <span>computer</span> на что-то новое. Лень - одно из гланвых качеств
        разработчика, переписывать название совсем не хочется. Хорошо, что есть
        ключевое слово <b>this</b>. Им-то мы и воспользуемся.
      </p>
      <p>
        <span>this</span> недаром называется именно так. Если в речи такое
        местоимение указывает на определённый предмет, то в JavaScript ключевое
        слово <span>this</span> указывает на конкретный объект, а именно на тот
        объект, на котором была вызвана функция (метод).
      </p>
      <p>
        Использовать <span>this</span> просто, достаточно заменить название
        объекта на ключевое слово в обращении к свойству. Вместо
        <span>объект.свойство</span> используем <span>this.свойство</span>.
      </p>
      <p>
        Объект, на который указывает <span>this</span> называется
        <i>контекстом вызова</i>.
      </p>
      <p>
        Важная деталь: пока функция не вызвана, <span>this</span> не содержит
        никакого значения, контекст появляется только в момент вызова функции.
      </p>
      <p>
        Ключевое слово <span>this</span> приносит много пользы разработчикам. О
        других преимуществах и особенностях <span>this</span> узнаем позже, а
        пока заменим обращение к свойствам внутри объекта <span>computer</span>.
      </p>
      <code>
        getDescription: function () { <br />
        return ( <br />
        "компьютер с процессором " + <br />
        this.processor + <br />
        ", диагональю " + <br />
        this.display + <br />
        ", оперативной памятью " + <br />
        this.memory <br />
        ); <br />
        }, <br />
        <br />
        getPrice: function () { <br />
        return ( <br />
        this.basicPrice + <br />
        processorPrice[this.processor] + <br />
        displayPrice[this.display] + <br />
        memoryPrice[this.memory] <br />
        ); <br />
        },
      </code>
      <h3>Проверка магазина</h3>
      <p>
        Интернет магазин готов! Осталось проверить, как будет работать программа
        с другими комьютерами. Надо убедиться, что независимо от показателей
        устройства, сообщение с техническими характеристиками будет выводиться
        корректно, а цена будет высчитываться верно.
      </p>
      <p>
        Создадим ещё один компьютер с оперативной памятью 16 Гб, диагональю 15
        дюймов, и процессором 'i5', узнаем его цену и выведем список
        характеристик.
      </p>
      <code>
        let anotherComputer = buildComputer(16, 15, "i5"); <br />
        console.log( "В корзине " + anotherComputer.getDescription() + "
        стоимостью " + anotherComputer.getPrice() );
      </code>
    </main>
    <footer>
      <h3>Здесь могла быть ваша кувшинка</h3>
    </footer>
  </body>
  <script src="Объекты/Кости.js"></script>
  <script src="Объекты/Билд комьютера.js"></script>
</html>
