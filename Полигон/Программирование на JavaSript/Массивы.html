<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>Массивы</title>
    <link rel="stylesheet" href="../../стили/Полигон.css" />
  </head>
  <body>
    <header>
      <img
        src="../../avatar/avatar1.jpg"
        width="90"
        height="90"
        alt="Лягушка"
      />
      <nav>
        <a href="../../Полигон.html">Назад</a>
      </nav>
    </header>
    <main>
      <h2>Массивы</h2>
      <h3>Маленький Кекс и Большие Данные</h3>
      <p>
        Кекс начал вести свой видеоблог с хайповым названием "Видеоблох". Он
        рассказывает про еду для котов, технику внезапных прыжков от стены, про
        хитрые приёмы ловли мух и охоты на птиц с подоконика.
      </p>
      <p>
        Кексу нужно понять, находит ли его контент отклик у других котов, ведь
        видеоблогинг отнимает много сил. Поэтому он звёл счётчик посетителей.
      </p>
      <p>
        Вам нужно написать программу, которая поможет Кексу оценить
        посещяемость. В разные дни в блог может заходить разное количество
        людей, но главное,чтобы среднее количетво посещений первое время не
        опускалось ниже 1000. Если посещаемость упадёт, нужно будет отправить
        Кексу уведомление.
      </p>
      <p>
        Данные о посещаемости за первые три дня Кекс уже прислал, и они записаны
        в переменные. Рекомндуемое среднее значение посещаемости хранится в
        переменной <span>expectedUsers</span>:
      </p>
      <code>
        let expectedUsers = 1000; <br />
        <br />
        let firstDayUsers = 812;<br />
        let secondDayUsers = 1360;<br />
        let thirdDayUsers = 657;<br />
      </code>
      <h3>Среднее значение</h3>
      <p>
        Теперь вам нужно добавить в программу расчёт среднего количества
        посещений за наблюдаемый период. Если это значение окажется ниже
        рекомендуемого, Кексу придётся задуматься о повышении посещаемости.
      </p>
      <p>
        Среднее значение считается по формуле: сумма всех значений, поделённая
        на их количество. Посчитаем среднее количество посещений за день и
        выведем это значение в консоль:
      </p>
      <code>
        let avarageUsers = (firstDayUsers + secondDayUsers + thirdDayUsers) / 3;
      </code>
      <h3>Завершаем анализатор посещаемости</h3>
      <p>
        Программа работает, осталость сделать интерфейс более дружелюбным и
        добавит рекомендации для Кекса.
      </p>
      <p>
        Но сначала подпишите значене, которое выводится в консоль. Кекс должен
        видеть, что это <i>среднее значение</i>, а не что-то другое.
      </p>
      <p>
        Потом нужно сравнить среднее значение с ожидаемым и показать Кексу
        рекомендацию. Если посещаемость хорошоая (среднее значение больше
        ожидаемого), то подбродрите его, если нет - попросите напрячься и начать
        готовить более качественный контент:
      </p>
      <code>
        if (avarageUsers > expectedUsers) { <br />
        console.log('Посещаемость великолепна! Продолжай в том же духе!') <br />
        } else { <br />
        console.log('Посещаемость так себе! Надо поднапрячься!') <br />
        }
      </code>
      <h3>Новые данные</h3>
      <p>
        К нам пришли новые данные и появилась срочная задача - внести их в
        программу. Для этого нужно не только добавить переменную с посещаеомстью
        за четвёртый день, но и обновить формулу расчёта среднего.
      </p>
      <code>
        let fourthDayUsers = 1247; <br />
        <br />
        let avarageUsers = (firstDayUsers + secondDayUsers + thirdDayUsers +
        fourthDayUsers) / 4; <br />
      </code>
      <h3>Масса данных? Массив!</h3>
      <p>
        Удивительно, но видеоблог смог просуществовать достаточно долго, ии
        сегодня Кекс прислал данные за последний месяц:
      </p>
      <code>
        817, 1370, 752, 1247, 681, 1120, 915, 1281, 875, 1341, 757, 610, 812,
        1170, 769, 1261, 845, 1289, 515, 1247, 845, 1311, 741, 1237, 812, 638,
        877, 1242, 1159, 1372
      </code>
      <p>
        Чтобы проанализировать эти данные, придётся добавить в текущую программу
        ещё 26 переменных. Много писанины? А скоро данные и за год подоспеют.
      </p>
      <p>
        Ваша программа рабоатет правильно, но дополнять её новыми данными крайне
        трудоёмко. Поэтому пришло время рефакторинга. Рефакторинг - это
        переписывание программы, после которого она должна работать так же, но
        быть более гибкой. Цель нашего рефакторинга - снизить трудоёмкость
        добавления и изменения массивного количества данных.
      </p>
      <p>
        Благо, существует способ хранить <i>массивные</i> данные. Это способ так
        и называется - массив. Массив - это тип данных, который представляет
        собой список элементов, у каждого из которых есть свой порядковый номер.
      </p>
      <p>
        Массивы создаются с помощью так называемого <i>литерала массива</i> -
        квадратных скобок. Внутри скобо через запятую перечисляются все
        значения, которые должен содержать массив. При создании массив, как
        любое значение, можно записать в переменную:
      </p>
      <code> let numbers = [1, 2, 3, 4, 5]; </code>
      <p>
        Вообще, в массив можно хранить любые данные: строки, булевые значения,
        числа и даже другие массивы.
      </p>
      <p>
        Рефакторинг мы будем делать плавно, не удаляя всю программу, а
        переписывая кусками. На первом этапе избавимся от отдельных переменных
        для данных:
      </p>
      <ol>
        <li>Временно присвоим среднеу значению нулевое значение.</li>
        <li>Создадим массив, в который перенесём значения из переменных.</li>
        <li>И теперь, когда переменные для данных в программе.</li>
      </ol>
      <code> let usersByDay = [812, 1360, 657, 1247] </code>
      <h3>Чтение из массива по индексу</h3>
      <p>
        Мы продолжаим рефакторинг чуть позже. А сейчас поучимся работать с
        массивами.
      </p>
      <p>
        Массив - это цельный список, поэтому его можно записать в одну
        переменную и эт переменную передать в какую-нибудь команду. Согласитесь,
        что это удобнее, чемм передавать в команду множество отдельных
        переменных.
      </p>
      <p>
        При обработке массивов почти всегд нужно получать его отдельные
        значения. Чтобы получить элемент массива, нужно в уже знакомых
        квадратных скобках указать порядковый номер или <i>индекс</i> этого
        элемента.
      </p>
      <code>
        let numbers = [1, 2, 3, 4, 5]; <br />
        <br />
        // Выведет в консоль: 2 <br />
        console.log(numbers[1]);
      </code>
      <p>
        Но почему вывелась двойка, а не единица? Нумерация элементов в массиве
        начинается с нуля: первый элемент массива идёт под номером ноль, второй
        - под номером один, третий - два и так далее.
      </p>
      <p>На примере нашего кода это будет выглядеть так:</p>
      <code>
        let usersByDay = [812, 1360, 657, 1247]; <br />
        <br />
        let firstDayUsers = usersByDay[0]; <br />
        console.log(firstDayUsers); // Выведет: 812<br />
        <br />
        let fourthDayUsers = usersByDay[3]; <br />
        console.log(fourthDayUsers); // Выведет: 1247 <br />
      </code>
      <h3>Переменная как индекс</h3>
      <p>
        В квадратные скобки можно передавать не только числа. Туда можно
        передать любое выражение. Это выражение в итоге будет преобразованно в
        число.
      </p>
      <p>
        Давайте попрактикуемся с таким способом обращения к элементам массива и
        поочерёдно переберём их с помощью одной и той же переменной. Для этого
        нужно завести переменную для хранения текущего индекса элемента массива.
        Назовём её <span>index</span> и запишем в неёё начальное значение ноль.
      </p>
      <p>
        Если теперь вывести в консоль выражение <span>usersByDay[index]</span>,
        то мы увидим первое значение массива. Ведь сейчас в переменной хранится
        ноль, и выражение <span>usersByDay[index]</span> равнозначно
        <span>usersByDay[0]</span>.
      </p>
      <p>
        Если изменить значение переменной <span>index</span> с нуля на единицу и
        нова обратиться к <span>usersByDay[index]</span>, то мы получим элемент
        с индексом <span>1</span>, то есть второй элемент.
      </p>
      <p>
        Смотрите, выражение в скобках в обоих случаяъ одинаковое:
        <span>usersByDay[index]</span>. Но в разных условиях оно возвращает
        разные значения.
      </p>
      <p>
        Если мы продолжм увеличивать <span>index</span> и читать элементы
        массива <span>usersByDay</span>, то рано или поздно мы пройдём по всем
        элементам.
      </p>
      <code>
        let usersByDay = [812, 1360, 657, 1247]; <br />
        let index = 0; <br />
        console.log(usersByDay[index]); // Выведет: 812 <br />
        <br />
        index = 3; <br />
        console.log(usersByDay[index]); // Выведет: 1247 <br />
      </code>
      <h3>Длина массива</h3>
      <p>Уже догодались, к чему всё идут? К перебору массивов в цике!</p>
      <p>
        Начальный индекс у массива мы знаем. Он равен нулю. Индексы в массиве
        возрастают на единицу. Использовать переменную в качестве индекса можно.
      </p>
      <p>
        Получается, что мы можем задать переменной нулевое значение, а затем
        использовать её в цикле для доступа к элементам массива, наращивая в
        каждой итерации на единицу.
      </p>
      <p>
        Остался один вопрос: когда остановить цикл? Для этого надо знать длину
        массива.
      </p>
      <p>
        И здесь тоже всё отлично. Массивы умеют рассказывать о своей длине. Для
        этого используется команда <span>[].length</span>, которое знает о
        количестве элементов в массиве:
      </p>
      <code>
        let numbers = [1, 2, 3, 4]; <br />
        <br />
        console.log(numbers.length); <br />
        // Выведет в консоль: 4
      </code>
      <p>
        С помощью обращения к <span>length</span> можно получить последний
        элемент массива, даже если вы не знаете, сколько элементов в нём
        хранится:
      </p>
      <code> someBigArray[someBigArray.length - 1]; </code>
      <p>
        Разберём это выражение. Допустим, в этом большом массиве 100 элементов.
        Его длина будет равна 100. Индекс последнего, стого элемента будет равен
        99, потому что нумерация в массивах начинается с нуля. Поэтому индекс
        последнего элемента вычисляется вычитанием единицы из длины.
      </p>
      <p>
        С помощью команды <span>[].length</span> вы можете
        <i>единообразно</i> работать с любыми массивами. То ест можно
        использовать один и тот же код для вычисления на массивах произвольной
        длины.
      </p>
      <h3>Ударим циклами по массивам!</h3>
      <p>
        Циклы и массивы тесно связаны между собой. Для многих операций на
        массивах, например, подсчёт суммы элементов, используются циклы. Теперь
        и вы готовы использовать цикл для обхода массива.
      </p>
      <p>
        Для этой задачи лучше всего подойдёт цикл <span>for</span>. Переменная
        цикла будет использоваться как индекс элемментов массива. Поэтому
        зададим ей нулевое значение и будем увеличивать в каждой итерации на
        единицу, пока её значение не станет равным индексу последнего элемента.
      </p>
      <p>
        Ещё один стилистический момент. Как лучше писать условие выхода из
        цикла? Есть два варианта. Рассмотрим их на примере массива из трёх
        элементов:
      </p>
      <code>
        // Первый вариант: i &lt; usersByDay.length <br />
        // usersByDay.length == 3 <br />
        Подготовка: i = 0 <br />
        1 итерация: i = 0; 0 &lt; 3? Да! Действия первой итерации; i = 1 <br />
        2 итерация: i = 1; 1 &lt; 3? Да! Действия второй итерации; i = 2 <br />
        3 итерация: i = 2; 2 &lt; 3? Да! Действия третьей итерации; i = 3 <br />
        4 итерация: i = 3; 3 &lt; 3? Нет! Завершаем цикл! <br />
        <br />
        // Второй вариант: i &lt;= usersByDay.length - 1 <br />
        // usersByDay.length -1 == 2 <br />
        Подготовка: i = 0 <br />
        1 итерация: i = 0; 0 &lt;= 2? Да! Действия первой итерации; i = 1 <br />
        2 итерация: i = 1; 1 &lt;= 2? Да! Действия второй итерации; i = 2 <br />
        3 итерация: i = 2; 2 &lt;= 2? Да! Действия третьей итерации; i = 3
        <br />
        4 итерация: i = 3; 3 &lt;= 2? Нет! Завершаем цикл! <br />
      </code>
      <p>
        Оба вариант условия выхода, <span>i &lt; usersByDay.length</span> и
        <span>i &lt;= usersByDay.length - 1</span>, работают одинаково. Но пока
        мы будем использовать второй вариант, с вычитанием единицы. Он будет
        напоминать нам про непривычную нумерацию элементов массива, которая
        начинается с нуля:
      </p>
      <code>
        for (let i = 0; i &lt;= usersByDay.length - 1; i++) { <br />
        console.log(usersByDay[i]); <br />
        }
      </code>
      <h3>Суммирование в цикле</h3>
      <p>
        В цикле можно не только выводить элементы массива в консоль, но и
        проводить с ними какие-то операции. Например, суммировать.
      </p>
      <p>
        Для этого нужно перед циклом завести переменную с нулевым значение.
        Затем на каждой итерации прибавлять к ней значение очередного элемента
        массива. В итоге после цикла в переменной окажется сумма всех элементов.
      </p>
      <p>
        Наша задача - анйти среднее значение. А для этого сначала нужно узнать
        сумму всех элементов.
      </p>
      <p>
        Давайте перепишем цикл так, чтобы он не выводил значения элементов в
        консоль, а последовательно складывал их между собой и записал в одну
        переменную.
      </p>
      <code>
        let totalUsers = 0 <br />
        <br />
        for (let i = 0; i &lt;= usersByDay.length - 1; i++) { <br />
        totalUsers +=usersByDay[i] <br />
        } <br />
        <br />
        console.log(totalUsers)
      </code>
      <h3>Завершаем рефакторинг</h3>
      <p>
        На первом шаге рефакторинга мы избавлялись от отдельных переменных и
        намеренно отключили расчёт среднего значения, записав ноль в переменную
        <span>avarageUsers</span>. Пришло время "починить" это механизм, но уже
        с использованием массива.
      </p>
      <p>
        Вспоминаем, что среднее - это сумма всех элементов, делённая на их
        количество. Сумму в цикле мы уже посчитали, а количество элементов можем
        получить, используя <span>[].length</span>.
      </p>
      <p>
        Рефакторинг завершён, а вот и вишенка на торте! Теперь программа стала
        намного гибче и позволяет легко анализировать любые объёмы данных. Для
        этого нужно просто менять значения внутри массива
        <span>usersByDay</span>.
      </p>
      <p>
        Выполните, наконец, задау Кекса. Проанализируйте посещаемость за
        последний месяц. Для этого нужно поместить эти данные внутрь массива:
      </p>
      <code>
        817, 1370, 752, 1247, 681, 1120, 915, 1281, 875, 1341, 757, 610, 812,
        1170, 769, 1261, 845, 1289, 515, 1247, 845, 1311, 741, 1237, 812, 638,
        877, 1242, 1159, 1372
      </code>
      <h3>Одно маленькое аналитическое расследование</h3>
      <p>
        А что если выделить дни с самыми большими провалами посещяемости?
        Например те дни, в которых посещаемость на 100 или даже на 200 человек
        меньше, чем ожидаемая.
      </p>
      <p>Да, точно. Сделаем величину провала настраиваемой.</p>
      <p>
        Сейчас проверим гипотезу. Вводим переменную с минимальной допустимой
        посещаемостью. Потом в цикл проверяем посещаемость за текущий день, и ,
        если она не дотягивается до минимальной, выводим её в консоль:
      </p>
      <code>
        let minUsers = expectedUsers - 100; <br />
        <br />
        for (let i = 0; i &lt;= usersByDay.length - 1; i++) { <br />
        if (usersByDay[i] &lt; minUsers) { <br />
        console.log(usersByDay[i]) <br />
        } <br />
        totalUsers +=usersByDay[i] <br />
        }
      </code>
      <h3>Запись в массив по индексу</h3>
      <p>
        Теперь соберём данные о провалах в новый массив. Запись в массив
        происходит так же, как и чтение - через обращение к элементу с помощью
        квадратных скобок:
      </p>
      <code>
        let numbers = []; <br />
        let index = 1; <br />
        <br />
        numbers[0] = 1;<br />
        numbers[index] = 2; <br />
        <br />
        // Выведет: [1, 2] <br />
        console.log(numbers);
      </code>
      <p>
        Обратите внимание, что если в массиве нет элемента под тем номером, под
        которым мы записываем, то этот элемент будет создан. До выполнения кода
        в массиве не было ни нулевого, ни первого элемента, но после того, как
        мы записали значения в эти позиции, элементы добавились в массив.
      </p>
      <code>
        for (let i = 0; i &lt;= usersByDay.length - 1; i++) { <br />
        if (usersByDay[i] &lt; minUsers) { <br />
        badDays[i] = usersByDay[i]; <br />
        } else { <br />
        badDays[i] = 0; <br />
        } <br />
        totalUsers +=usersByDay[i] <br />
        }
      </code>
      <h3>Убийца - дворецкий!</h3>
      <p>Картинка начала складываться.</p>
      <p>
        Теперь поэкспериментируем с порогом фильтрации плохих дней. Возможно,
        получится выявить какую-то закономерность.
      </p>
      <p>
        За порог чувствительности фильтра плохих дней отвечает переменная
        <span>minUsers</span>. Сейчас плохими считаются дни с посещаемостью на
        100 человек ниже ожидаемой. Меняя размеры вычитаемого значения, можно
        настраивать чувствительность.
      </p>
      <code>
        // Чувствительность ниже, плохих дней в массиве больше <br />
        let minUsers = expectedUsers - 100; <br />
        <br />
        // Чувствительность выше, плохих дней в массиве меньше <br />
        let minUsers = expectedUsers - 200
      </code>
      <h3>Смутные подозрения</h3>
      <p>
        Кекс заподозрил неладное и попросил снова проанализировать данные за
        последний месяц. Вот они:
      </p>
      <code>
        812, 581, 1370, 752, 1247, 681, 1120, 915, 875, 1341, 757, 610, 812,
        741, 1139, 812, 638, 877, 1242, 1159, 1372, 1170, 845, 1289, 515, 1247,
        769, 1261, 2805, 1201
      </code>
      <h3>Меняем элементы местами</h3>
      <p>
        Опасения подтверждаются: в посещаемости стало даже больше сильных
        провалов, чем раньше. Но почему тогда средняя посещаемость хорошая?
        Посмотрите на всплеск посещаемост в конце месяца. Этот пик влияет на
        среднюю посещаемость, и она оказывается хорошей.
      </p>
      <p>
        Придётся улучшить программу и, помимо средней посещаемости, считать
        медианную посещаемость, которая менее чувствительна к подобным
        всплескам. Медиана - это срединное значение массива. Чтобы его получить,
        вначале нужно отсортировать массив. Поэтому сейчас будем учиться делать
        сортировку.
      </p>
      <p>
        При сортировке элементы массива меняются местами. Обычно это делается
        через промежуточную переменную, в которую сохарняется один из
        переставляемых элементов:
      </p>
      <code>
        let usersByDay = [4, 1, 2, 3]; <br />
        console.log(usersByDay); // Выведет [4, 1, 2, 3]<br />
        <br />
        let swap = usersByDay[0]; <br />
        <br />
        usersByDay[0] = usersByDay[1] <br />
        console.log(usersByDay); // Выведет [1, 1, 2, 3]<br />
        <br />
        usersByDay[1] = swap <br />
        console.log(usersByDay); // Выведет [1, 4, 2, 3]<br />
      </code>
      <h3>Ищем минимальный элемент</h3>
      <p>
        Подытожим, зачем нудна вспомогательная переменная. Допустим, есть
        массив, в котором мы меняем местами первый и второй элементы без
        вспомогательной переменной:
      </p>
      <code>
        let numbers = [1, 2, 3]; <br />
        <br />
        // Теперь numbers такой [2, 2, 3] <br />
        numbers[0] = numbers[1];
      </code>
      <p>
        Если сразу записать на первое место значение второго элемента, то мы
        потеряем значение первого элемента. Поэтому сначала нужно значение
        первого элемента сохранить в переменную:
      </p>
      <code>
        let numbers = [1, 2, 3]; <br />
        <br />
        // Теперь в swap хранится 1 <br />
        let swap = numbers[0]; <br />
        <br />
        // Теперь numbers такой [2, 2, 3] <br />
        numbers[0] = numbers[1]; <br />
        <br />
        // Теперь numbers такой [2, 1, 3] <br />
        numbers[1] = swap
      </code>
      <p>
        Следующий шаг на пути к сортировке - поиск минимального элемента. И этот
        элемент мы будем искать не во всём массиве, а в указанной его части.
      </p>
      <p>
        Для этого заведём переменную <span>currentIndex</span>. Она будет
        управлят начальным значением переменной цикла. Обратите внимание, что
        переменная цикла в этот раз будет называться <span>j</span> (это ещё
        одно типовое название).
      </p>
      <code>
        let usersByDay = [4, 2, 1, 3]; <br />
        console.log(usersByDay); <br />
        <br />
        let currentIndex = 0; <br />
        for (let j = currentIndex + 1; j &lt;= usersByDay.length - 1; j++ ) {
        <br />
        console.log(usersByDay[j]) <br />
      </code>
      <h3>Минимальный элемент найден!</h3>
      <p>
        Почему начальное значение переменной цикла задано как
        <span>currentIndex + 1</span>? Это нужно, чтобы искат минимальное
        значение <i>после</i> элемента с позицией <span>currentIndex</span>.
      </p>
      <code>
        let currentIndex = 0; <br />
        // Минимальный элемент ищем начиная со второй позиции <br />
        <br />
        let currentIndex = 1; <br />
        // Минимальный элемент ищем начиная с третьей позиции
      </code>
      <p>Как найти минимальный элемент, расположенный после первого?</p>
      <ol>
        <li>
          Добавим переменную <span>minValue</span> для хранения минимального
          значения.
        </li>
        <li>
          Предположим, что первый элемент и есть минимальный. Поэтому до цикла
          сохраним в <span>minValue</span> значение первого элемента.
        </li>
        <li>
          На каждой итерации цикла сравниваем текущий элемент со значением
          <span>minValue</span>.
        </li>
        <li>
          Если текущий элемент меньше <span>minValue</span>, то записываем его в
          <span>minValue</span>.
        </li>
      </ol>
      <p>
        Если первый элемент и был минимальный, то в цикле значение
        <span>minValue</span> не изменится, если же после первого элемента были
        элементы с меньшим значением, то это значение запишется в
        <span>minValue</span> в цикле.
      </p>
      <p>В любом случае минимальный элемент будет найден.</p>
      <code>
        let usersByDay = [4, 2, 1, 3]; <br />
        console.log(usersByDay); <br />
        <br />
        let currentIndex = 0; <br />
        let minValue = usersByDay[currentIndex] <br />
        for (let j = currentIndex + 1; j &lt;= usersByDay.length - 1; j++ ) {
        <br />
        if (minValue &gt; usersByDay[j]) { <br />
        minValue = usersByDay[j] <br />
        console.log('Новый минимальный элемент: ' + minValue) <br />
        } <br />
        } <br />
        <br />
        console.log('Минимальный элемент:' + minValue)
      </code>
      <h3>Начинаем сортировку</h3>
      <p>
        Мы научились находить минимальное значение. Почему бы не сделать ещё
        шаг.
      </p>
      <p>
        Теперь давайте не просто находить минимальное значение после первого
        элемента, а записывать это значение на место первого элемнта. Для этого
        немного дополним алгоритм:
      </p>
      <ol>
        <li>
          Добавим переменную <span>minValue</span> для хранения минимального
          значения.
        </li>
        <li>
          Предположим, что первый элемент и есть минимальный. Поэтому до цикла
          сохраним в <span>minValue</span> значение первоого элемента.
        </li>
        <li>
          На каждойитерации цикла сравниваем текущий элемент со значением
          <span>minValue</span>.
        </li>
        <li>
          Если текущий элемент меньше <span>minValue</span>, то записываем его в
          <span>minValue</span>, а затем меняем местами значени первого элемента
          и текущего.
        </li>
      </ol>
      <p>
        ППосле завершения работы цикла на первой позиции массива окажется
        элемент с минимальным значением. Все остальные элементы будут больше.
      </p>
      <h3>Продолжаем сортировку</h3>
      <p>
        Вы прошлись по всему массиву, нашли минимальный элемент и поместили его
        на первое место.
      </p>
      <p>
        Как продолжить сортировку? Очень просто. Теперь нужно повторить всё то
        же самое со вторым элементом массива: ище минимальные элементы в
        оставшейся части массива и помещаем их на второе место.
      </p>
      <p>
        После этого шага на первой позиции массива окажется самый маленький
        элемент, на второй позиции - следующий по величине. А на остальных
        позициях - элементы с более крупными значениями.
      </p>
      <p>Затем нужно будет повторить эти же действия с третьим элемемнтом.</p>
      <p>
        После этого массив будет отсортирован полностью, так как на перывых трёх
        позициях по возрастанию будут размещены минимальные элемнты, а на
        четвёртой позиции автоматически останется максимальный элемент.
      </p>
      <p>
        Реализуем эти шаги через вставку и копирование кода. Единственное, что
        будет отличаться в разных кусках - это значение переменной
        <span>currentIndex</span>.
      </p>
      <code>
        currentIndex = 1; <br />
        minValue = usersByDay[currentIndex]; <br />
        for (let j = currentIndex + 1; j &lt;= usersByDay.length - 1; j++) {
        <br />
        if (minValue &gt; usersByDay[j]) { <br />
        minValue = usersByDay[j]; <br />
        let swap = usersByDay[currentIndex]; <br />
        usersByDay[currentIndex] = minValue; <br />
        usersByDay[j] = swap; <br />
        console.log("Меняю местами " + swap + " и " + minValue); <br />
        console.log("Массив сейчас: " + usersByDay); <br />
        } <br />
        } <br />
        <br />
        currentIndex = 2; <br />
        minValue = usersByDay[currentIndex]; <br />
        for (let j = currentIndex + 1; j &lt;= usersByDay.length - 1; j++) {
        <br />
        if (minValue &gt; usersByDay[j]) { <br />
        minValue = usersByDay[j]; <br />
        let swap = usersByDay[currentIndex]; <br />
        usersByDay[currentIndex] = minValue; <br />
        usersByDay[j] = swap; <br />
        console.log("Меняю местами " + swap + " и " + minValue); <br />
        console.log("Массив сейчас: " + usersByDay); <br />
        } <br />
      </code>
      <h3>Завершаем сортировку</h3>
      <p>
        Программа для сортировки массива из <i>четырёх</i> элементов готова. Да,
        она негибкая, и её придётся переписывать для массива с другим
        количеством элементов. Но это нестрашно, ведь вы уже умеете делать
        рефакторинг.
      </p>
      <p>
        В текущей реализации много повторяющегося кода, в котором меняется
        только значение <span>currentIndex</span>. Как сделать структуру
        программы лучше?
      </p>
      <p>
        Можно взять кусок кода с циклом, который ищет и подставляет на указанное
        место минимальное значение, и обернуть его в другой цикл. В и это
        верхнем, "родительском", цикле наращивать переменную
        <span>currentIndex</span>.
      </p>
      <p>Да. Циклы можно вкладывать друг в друга.</p>
      <p>
        Учтите, что <span>currentIndex</span> должна изменяться не от нуля до
        длины массива, а от нуля до длны массива, уменьшенной на единицу.
        Вспомните прошлое задание, в котором мы завершили сортировку для
        массива, дойдя до предпоследнего элемента (ведь последний элемент
        автоматически оказался максимальным).
      </p>
      <p>
        Условие выхода из верхнего цикла давайте писать по аналогии с условием
        выхода из вложенного цикла:
      </p>
      <code>
        // Цикл до предпоследнего элемента <br />
        currentIndex &lt;= usersByDay.lengt - 2 <br />
        <br />
        // Цикл до последнего элемента <br />
        j &lt;= usersByDay.lengt - 1
      </code>
      <h3>Медиана на нечётном количестве элементов</h3>
      <p>
        Программа сортировки готова и оттестирована. Теперь переходим к подсчёту
        медианы. Медиана - это срединное значение, то есть это буквально
        элемент, расположенный посередине массива.
      </p>
      <p>Медиана отличается от среднего значения устойчивостью к отклонению:</p>
      <code>
        // Среднее и медиана: 3 <br />
        [1, 2, 3, 4, 5] <br />
        <br />
        // Среднее: 12. Медиана: 3 <br />
        [1,2, 3, 4, 50]
      </code>
      <p>
        Медиану легко получить у массива с нечётным количеством элементов. Для
        этого нужно правильно посчитать индекс среднего элемента. Попробуем
        вывести формулу:
      </p>
      <code>
        // Длина массива 3, индекс среднего элемента 1 <br />
        [1, 2, 3] <br />
        <br />
        //Длина массива 5, индекс среднего элемента 2 <br />
        [1, 2, 3, 4, 5] <br />
        <br />
        // Длина массива 7, индекс среднего элемента 3 <br />
        [1, 2, 3, 4, 5, 6, 7]
      </code>
      <p>Вычитаем из длины массива единицу и делим на два, и индекс найден.</p>
      <p>
        Кекс может присылать массивы данных разной длины, поэтому придётся
        проверять количество элементов на чётность и в зависимости от этого
        находить медиану. Для проверки на чётность используем уже знакомый
        оператор <span>%</span>.
      </p>
      <code>
        if (usersByDay.length % 2 !== 0) { <br />
        let medianaIndex = (usersByDay.length - 1)/2; <br />
        console.log('Индекс медианы: ' + medianaIndex) <br />
        let mediana = usersByDay[medianaIndex] <br />
        console.log('Медиана: ' + mediana) <br />
        }
      </code>
      <h3>Медиана на чётном количестве элементов</h3>
      <p>
        Примерно та же ситуация происхоит с подсчётом медианы, когда в массиве
        хранится чётное количетво элементов. Но в отличие от пирожков, для
        медианы решение нашли. Если количество элементов чётное, то медиана
        считается как среднее значение двух элемемнтов: левого и правого от
        середины.
      </p>
      <code>
        // Медиана: 3 <br />
        [0, 1, 2, 4, 50, 100]
      </code>
      <p>
        Снова выводим формулы индексов двух элементо: левого и правого от
        середины.
      </p>
      <code>
        // Длина 4, индекс евого 1, правого 2 <br />
        [1, 2, 3, 4] <br />
        <br />
        // Длина 6, индекс левого 2, правого 3 <br />
        [1, 2, 3, 4, 5, 6] <br />
        <br />
        // Длина 8, индекс левого 3, правого 4 <br />
        [1, 2, 3, 4, 5, 6 7, 8]
      </code>
      <p>
        Делим длину массива на два и вычитаем единицу - левый индекс найден.
        Делим длину на два - правый индекс найден.
      </p>
      <p>
        Расчёт медианы для чётного количества элементов в массиве добавляем в
        альтернативной ветке условий.
      </p>
      <code>
        if (usersByDay.length % 2 !== 0) { <br />
        let medianaIndex = (usersByDay.length - 1)/2;<br />
        console.log('Индекс медианы: ' + medianaIndex)<br />
        let mediana = usersByDay[medianaIndex]<br />
        console.log('Медиана: ' + mediana)<br />
        } else {<br />
        let leftIndex = usersByDay.length/2-1;<br />
        let rightIndex = usersByDay.length/2;<br />
        let mediana = (usersByDay[leftIndex] + usersByDay[rightIndex])/2;<br />
        console.log('Индекс левого значения: ' + leftIndex + '. Индекс правого
        значения: ' + rightIndex)<br />
        console.log('Медиана: ' + mediana)<br />
        }<br />
      </code>
      <h3>Убийца снова дворецкий!</h3>
      <p>
        Подключив код для сортировки массива и для вычисления медианы, виодно
        что что-то не так. Ведь средняя посещаемость составляет <b>1032</b>, а
        медианная <b>896</b> человек в день. А это уже ниже ожидаемого значения
        в тысячу человек.
      </p>
      <p>
        Есть одна проблема, Кекс - кот старой закаолки и любит проценты. Чтобы
        его убедить в подставках, надо доказать, что среднее и медиана
        отличаются сильно, не менее, чем на 10 процентов.
      </p>
      <p>
        В нашем случае очень подозрительно, когда медиана ниже среднего
        значения. Осталось понять, как посчитать проценты.
      </p>
      <p>
        Для этого нужно поделить значение медианы на среднее значение. Например,
        если медиана составляет 80, а среднее значение 100, то:
      </p>
      <code>
        // Медиана составляет 80% от среднего <br />
        80 / 100 = 0.8
      </code>
      <p>
        Переформулираем задачу Кекса: если медиана составляет меньше, чем 0.9 от
        среднего, то есть подозрения в подставках.
      </p>
      <p>Осталось дрписать проверку и вывести рекомендации в консоль:</p>
      <code>
        if (median / avarageUsers &lt; 0.9) { <br />
        console.log("Есть подозрения в подставках"); <br />
        } else { <br />
        console.log("Подозрений в подставках нет"); <br />
        }
      </code>
    </main>
    <footer>
      <h3>Здесь могла быть ваша кувшинка</h3>
    </footer>
    <script src="Массив/Видеоблох.js"></script>
  </body>
</html>
