<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>Функции</title>
    <link rel="stylesheet" href="../../стили/Полигон.css" />
  </head>
  <body>
    <header>
      <img
        src="../../avatar/avatar1.jpg"
        width="90"
        height="90"
        alt="Лягушка"
      />
      <nav>
        <a href="../../Полигон.html">Назад</a>
      </nav>
    </header>
    <main>
      <h2>Функции</h2>
      <h3>Пристегните ремни</h3>
      <p>
        Вы только успели зайти в фоис, как получили письмо от Кекса с пометкой
        "срочно".
      </p>
      <p>
        <i
          >"Я хочу поехать в отпуск. Говорят, в Иркутске водится вкусный омуль,
          питерская корюшка мне совсем приелась.</i
        >
      </p>
      <p>
        <i
          >Посчитай, сколько бонусных воздушных миль я смогу получить с перелёта
          компанией "Кекс7". Моё чутьё охотника за скидками подсказывает, что
          тут есть, чем поживиться.</i
        >
      </p>
      <p>
        <i
          >Расстояние до Иркутска 4125 км. Количество миль равно 25% от этого
          расстояния.
        </i>
      </p>
      <p><i>Жду результат!"</i></p>
      <p>
        Для начала проясним, что такое "воздушные мили". Так называют бонусы от
        авиакоманий, которые можно накапливать после каждого полёта, а затем
        "оплатить" ими перелёт в какой-нибудь город. Бонусные мили не всегда
        связаны с настоящими физическими милями. Зачастую это бонусные очки,
        которые можно накопить до какой-то суммы. Бонусные мили начисляются
        по-разному. В "Кекс7", как мы уже узнали, бонусы - процент от расстояния
        перелёта
      </p>
      <p>
        В нашем коде расстояние хранится в переменной <span>distance</span>, а
        процент уже переведён в дробное число и хранится в переменной
        <span>percent</span>.
      </p>
      <p>
        Этих значений достаточно, чтобы получить нужное количество миль: умножим
        расстояние на процент.
      </p>
      <code>
        let distance = 4125; <br />
        let percent = 0.25; <br />
        let miles = distance * percent; <br />
        console.log('За полёт в Иркутск получим ' + miles + ' миль'); <br />
      </code>
      <h3>Дальний перелёт</h3>
      <p>
        Вы не первый день работаете с Кексом и знаете его шальной характер.
        Сегодня он летит в Иркутск, а завтра захочет куда-нибудь ещё.
      </p>
      <p>
        Давайте подстрахуемся и улучшим нашу программу, чтобы она учитывала
        условие для дальних перелётов.
      </p>
      <p>
        Если расстояние больше <span>10500</span> км, то количество наисленных
        миль составляет <span>35%</span> от дальности полёта, а не
        <span>25%</span>, как было изначально.
      </p>
      <code>
        if (distance > 10500) { <br />
        percent = 0.35;<br />
        } <br />
      </code>
      <h3>Идём на второй круг</h3>
      <p><i>Спасибо за расчёт!</i></p>
      <p>
        <i
          >Когда вернусь, хочу ещё слетать на Камчатку, поесть микижи да на
          вулканы посмотреть.</i
        >
      </p>
      <p>
        <i
          >Сколько я накоплю миль? Лететь аж 9 часов, мои страдания должны быть
          вознаграждены!</i
        >
      </p>
      <p>
        Ваше чутьё вас не подвело! Кекс задумал ещё одно путешествие, а у вас
        всё готово: формула есть, условие для дальних перелётов учтено.
      </p>
      <p>Добавим расчёт миль для полёта на Камчатку.</p>
      <p>
        Для этого на придётся повторить все шаги вичисления для первого
        путешествия. Алгоритм тот же, только расстояние другое, а может, и
        проценты. Проверим!
      </p>
      <p>
        Вы можете заметить, что результаты наших расчётов получаются не круглые.
        Всё в порядке, эо не ошибка, так работают вычисления в JavaScript. Чуть
        позже мы сделаем числа круглыми. А в позже обсудим, почему так
        происходит.
      </p>
      <h3>Функция-помощник</h3>
      <p>Вы заметили проблему?</p>
      <p>
        Программа работает, мили считаются, но что будет, если Кекс пойдёт
        вразнос и решит слетать ещё в десяток городов? Нам постоянно придётся
        копироват ону часть кода, менять расстояние, считать, а ещё каждый раз
        занаво объявлять одни и те же переменные, что нарушает правила языка.
        Мы, конечно, справимся с поставленной задачей, но потратим много
        времени, да и код разрастётся до сотни строк.
      </p>
      <p>
        Есть ли более удобный и грамотный способ сделать вычисления без
        копирвания? Есть! Написать <b>функцию</b>.
      </p>
      <p>
        Функция - кусок кода, который можно написать один раз, а затем
        многократно использовать. Функия не просто содержит в себе значение, как
        переменная, а выполнять какое-то действие и решать какую-то задачу:
        считать, сравнивать, ищет. Например, наша функция будет вычислять
        накопленные мили с перелёта.
      </p>
      <p>
        Но сначала посмотрим, из чего состоят функции и как они объявляются
        (создаются) в коде.
      </p>
      <code>
        let functionName = function () { <br />
        // Действия, которые выполняет функция или "тело функции" <br />
        }
      </code>
      <p>
        <span>functionName</span> - имя переменной, которая содержит в себе
        функцию. По этому имени мы сможем обращаться к функции и использовать её
        много раз. Давайте считать, что название переменной это и есть название
        функции.
      </p>
      <p>Есть и друге способы создания функций, о них мы поговори позже.</p>
      <p>
        Функции создаются не сложнее условий или циклов. Используем ключевое
        слово <span>function</span>, дальше добавляем круглые скобки. В фигурных
        скобках находятся действия, которые функция будет делать каждый раз, как
        мы к ней обратимся. Помните, как в циклах? Там код внутри
        <span>{ }</span> называется "телом цикла", а здесь "телом функции".
      </p>
      <p>Напишем функцию <span>calculateMiles</span> для расчёта миль.</p>
      <p>
        Обратите внимание на название. Функция буквально <i>вычисляет мили</i>,
        то есть <i>чо-то делает</i>. Это общепринятое правило именования -
        название функции должно содержать глагол.
      </p>
      <code>
        let calculateMiles = function () { <br />
        let distance = 4125; <br />
        let percent = 0.25; <br />
        if (distance > 10500) { <br />
        percent = 0.35; <br />
        } <br />
        <br />
        let miles = distance * percent; <br />
        console.log("За полёт в Иркутск получим " + miles + " миль"); <br />
        }
      </code>
      <h3>Функция, я вызываю тебя!</h3>
      <p>Функция готова, а дальше-то что? Как вычислить количество миль?</p>
      <p>
        Чтобы функция начала свою работу, её надо вызвать. Для этого нам и
        пригодится имя функции. Именно по нему мы обратимся к нашей функции и
        попросим её выполнить свой код.
      </p>
      <p>
        Если мы просто выведем функцию <span>console.log(functionName)</span>,
        то увидим в консоли весь код этой функции примерно в таком же виде, как
        его и написали, но никаких вычислений не произойдёт.
      </p>
      <p>Как же тогда запустить код из тела функции?</p>
      <p>
        Нужно обратиться к функции по её имени, а затем указать круглые скобки.
      </p>
      <code> functionName(); </code>
      <p>
        Обратите внимание, что вызов функции должен идти в коде после её
        определения.
      </p>
      <h3>У меня для тебя параметр</h3>
      <p>
        Мы написали функцию, вызвали её и посчитали мили, накопленные полётом в
        Иркутск. А что с полётом на Камчатку? Как посчитать результат второго
        путешествия?
      </p>
      <p>Тут пригодится очередная фишка функций.</p>
      <p>
        Мы можем записать хоть десяток вызовов <span>calculateMiles()</span>,
        результат будет одинаковым, потому что внутри функции находится
        переменные с фиксированными значениями, подходящими только для полёта в
        Иркутск. То есть <b>только для одного случая</b>.
      </p>
      <p>
        Внутри функции в переменной <span>distance</span> мы храним расстояние
        до Иркутска. Чтобы найти мили за другой полёт, надо поменять значение
        этой переменной. Но мы не будет занаво переписывать функцию с другими
        значениями <span>distance</span>. Мы сделаем функцию универсальной,
        чтобы её можно было написать один раз, а затем использовать под разные
        случаи. Для этого мы будем использовать <i>параметры</i>.
      </p>
      <p>
        <b>Параметры</b> - значения, с помощью которых мжно настраивать функции.
        Так мы можем узнать результат работы функции для разных случаев.
      </p>
      <p>Посмотрим, как это работает.</p>
      <code>
        let showtime = function (hours, minutes) { <br />
        console.log('Текущее время: ' + hours + ':' + minutes); <br />
        }; <br />
        <br />
        showtime(3, 15); // Выведет: Текущее время: 3:15 <br />
        showtime(16, 20); // Выведет: Текущее время: 16:20
      </code>
      <p>
        Чтобы функция работала с параметрами, их надо как-то передат и дать им
        названия. Разберёмся, как это делать.
      </p>
      <p>1. <b>Задаём параметры.</b></p>
      <code>
        let showtime = function (<b>hours</b>, <b>minutes</b>) { <br />
        ... <br />
        };
      </code>
      <p>
        С момента объявления функции, в круглых скобках, мы создаём параметры.
        Здесть всё, как с переменными: сначала задаём параметрам имена, которые
        описывают, что за значения будут в них записаны. Если параметров
        несколько, они записываются через запятую.
      </p>
      <p>2. <b>Используем параметры.</b></p>
      <code>
        let showtime = function (hours, minutes) { <br />
        console.log('Текущее время: ' + <b>hours</b> + ':' + <b>minutes</b>);
        <br />
        };
      </code>
      <p>
        Параметры работают так же, как переменные. Мы подставляем их вместо
        фиксированных значений в операции внтри функции. При выполнении кода
        вместо каждого параметра подставится его значение.
      </p>
      <p>3. <b>Функция получает значения параметров.</b></p>
      <code>
        showtime(<b>3</b>, <b>15</b>); // Выведет: Текущее время: <b>3:15</b>
        <br />
        showtime(<b>16</b>, <b>20</b>); // Выведет: Текущее время: <b>16:20</b>
      </code>
      <p>
        В предыдущих шагах мы разобрали, как функция работает с полученными
        параметрами. Но ещё не обсудили как сделать так, чтобы функция их
        получила. В момент вызова функции мы указываем в круглых скобках те
        значения, которые окажутся в параметрах. Мы пишем
        <span>showTime(16, 20)</span> и вместо <span>hours</span> в теле функции
        подставляется <span>16</span>, а вместо <span>minutes</span> число
        <span>20</span>.
      </p>
      <p>
        Давайте улучшим наш код, наконец, сделаем функцию
        <span>calculateMiles</span> универсальной и посчитаем накопленные мили
        за второй полёт.
      </p>
      <code>
        let calculateMiles = function (distance) { <br />
        let percent = 0.25; <br />
        if (distance > 10500) { <br />
        percent = 0.35; <br />
        } <br />
        <br />
        let miles = distance * percent; <br />
        console.log("За полёт получим: " + miles + " миль"); <br />
        }
      </code>
      <h3>Порядок параметров</h3>
      <p>
        Отвлечёмся ненадолго от подсчёта миль. С аргументами есть один нюанс -
        передавать их надо <b>в том же порядке</b>, в котором объявлены
        параметры функции.
      </p>
      <p>
        Рассмотрим на примере. У нас есть функция <span>getFavoriteBook</span>,
        которая выводит в консоль сообщение о любимой книге пользователя. У неё
        два параметра: первый называется <span>userName</span> (имя
        пользователя), второй <span>bookName</span> (название книги).
      </p>
      <code>
        <br />
        let getFavoriteBook = function (<b>userName, bookName</b>) { <br />
        console.log('Мен зовут ' + <b>userName</b> + '. Моя любимая книга: ' +
        <b>bookName</b>); <br />
        } <br />
      </code>
      <p>
        Допустим, нашего пользователя зовут Семён, а его любимая книга "Ёжик в
        тумане". Передадим эти аргументы в функцию. Сначала название книги, а
        затем имя пользователя:
      </p>
      <code>
        let getFavoriteBook = function (<b>userName, bookName</b>) { <br />
        // Параметр <b>userName</b> хранится 'Ёжик в тумане' <br />
        // Параметр <b>bookName</b> хранит 'Семён' <br />
        ... <br />
        } <br />
        <br />
        //Вызываем функцию <br />
        getFavoriteBook('Ёжик в тумане', 'Семён');<br />
        // Выведет: Меня зовут <b>Ёжик в тумане</b>. Моя любимая книга:
        <b>Семён</b>
      </code>
      <p>
        Кажется что-то пошло не так. Почему мы получили такой результат? Мы ведь
        передали имя пользователя и название книги - всё, как положено.
      </p>
      <p>
        Всё дело в порядке переданных значений. Параметры работают, как
        перемменные - значение из аргумента записывается в параметр, а потом
        используется внутри функции по имени. В нашем случае всё так и
        произошло. Первый параметр функции - <span>userName</span>, первый
        аргумент - <span>'Ёжик в тумане'</span>. Этот аргумент и записался в
        параметр <span>userName</span>, а аргумент <span>'Семён'</span> стал
        параметром <span>bookName</span>. Вы, конечно, знаете, гду тут имя, а
        где название книги, а вот JavaScript нет. Потому что порядок аргументов
        соответствует порядку параметров в функции. У нас параметры записаны в
        таком порядке: <span>userName, bookName</span>. Значит, первым должно
        быть передано имя пользователя, а затем название книги. И никак иначе.
      </p>
      <code>
        let getFavoriteBook = function (<b>userName, bookName</b>) { <br />
        // Параметр <b>userName</b> хранится 'Семён' <br />
        // Параметр <b>bookName</b> хранит 'Ёжик в тумане' <br />
        ... <br />
        } <br />
        <br />
        //Вызываем функцию <br />
        getFavoriteBook('Семён', 'Ёжик в тумане');<br />
        // Выведет: Меня зовут <b>Семён</b>. Моя любимая книга:
        <b>Ёжик в тумане</b> <br />
      </code>
      <p>
        видите, мы передали аргументы в правильном порядке и сообщение стало
        корректным.
      </p>
      <p>
        Обратите внимание, если у функции указан параметр, но аргумент не
        передан, то значение параметра в теле функции будет
        <span>underfined</span> - то есть ничего. Будьте внимательны.
      </p>
      <h3>Возвращение из функции</h3>
      <p>
        А что, если нам нужно получить значение из функции и как-то дальше его
        использовать?
      </p>
      <p>Функции умеют <b>возвращать</b> результат своей работы.</p>
      <p>
        Если кратко, то функция может выполнить код и отдать результат операций
        для дальнейшей работы с этим результатом. Он подставится в то место
        кода, где мы вызвали функцию.
      </p>
      <code>
        let increaseByTwo = function (number) {<br />
        let sum = 2 + number; <br />
        return sum;<br />
        }; <br />
        <br />
        increaseByTwo(1); // Функция вернёт 3 <br />
        increaseByTwo(2); // Функция вернёт 4
      </code>
      <p>Как работает код из примера?</p>
      <p>
        Чтобы функция вернула значение, мы используем оператор
        <span>return</span>. После оператора указываем, что именно надо вернуть.
        В нашем случае значение переменной <span>sum</span>. Когда программа
        доходит до строки с <span>return</span>, функция отдаёт результат своей
        работы и выполнение кода из тела функции останавливается, иными словами
        <i>происходит выход из функции.</i>
      </p>
      <p>Несколько вещей, которые нужно знать:</p>
      <ul>
        <li>
          Код, написанный <b>на новой строке</b> после <span>return</span>, не
          выполняется.
        </li>
        <li>
          Функция не может вернуть сразу много значений, она возвращает
          <b>только один</b> результат.
        </li>
        <li>
          Если внутри функции нет <span>return</span> или после
          <span>return</span> не указано, какое значение нужно вернуть, функция
          вернёт <span>underfined</span>, иными слова, <b>ничего</b>.
        </li>
      </ul>
      <p>
        Как было сказано выше, результат работы функций можно использовать в
        других операциях.
      </p>
      <code>
        console.log('Сумма чисел: ' + increaseByTwo(1)); <br />
        // Выведет: Сумма чисел: 3 <br />
        <br />
        console.log('Сумма чисел: ' + increaseByTwo(2)); <br />
        // Выведет: Сумма чисел: 4
      </code>
      <p>
        Кстати, в JavaScript есть встроенные функции языка, которые возвращают
        результат своей работы. Таких функций очень много. Вот те из них,
        которые мы будем использовать в заданиях для округления чисел:
      </p>
      <ul>
        <li>
          <span>Math.ceil(number)</span> - принимает на вход число и округляет
          его до целого в <b>большую</b> сторону.
        </li>
        <li>
          <span>Math.floor(number)</span> - делает то же самое, только округляет
          в <b>меньшую</b> сторону.
        </li>
        <li>
          <span>Math.round(number)</span> - округляет число до
          <b>ближайшего</b> целого значения.
        </li>
      </ul>
      <p>
        Округлим количество миль в нашей функции <span>calculateMiles</span>.
      </p>
      <code>
        if (distance > 10500) { <br />
        percent = 0.35; <br />
        } <br />
        <br />
        let miles = Math.round(distance * percent); <br />
        console.log("За полёт получим: " + miles + " миль"); <br />
        return miles <br />
        }
      </code>
      <h3>Деловая поездка</h3>
      <p>
        От Кекса пришла новая задача. Он вшёл во вкус и хочет копить мили и на
        рабочих поездках.
      </p>
      <p>
        В командировки Кекс летает другим перевозчиком - "Кексофлотом". У
        комании хитрая система накопления миль. Пассажиры бизнес-класса получают
        <span>22%</span> от всего пути, а пассажиры эконома только
        <span>18%</span>. При этом, если расстояние превышает
        <span>3500 км</span>, то процент увеличивается ещё на <span>15%</span>.
      </p>
      <p>
        Название прошлой функции для расчёта миль
        <span>calculateMiles</span> точно описывает цель этой функции и подходит
        для новой задачи. Оставим его.
      </p>
      <p>
        Новая функция будет принимать на вход два параметра: расстояние и
        какой-то знак, который укажет программе класс перелёта. С расстоянием
        всё просто - назовём параметр <span>distance</span>.
      </p>
      <p>А что делать со вторым параметром?</p>
      <p>
        В нашем случае для второго параметра достаточно только два варианта -
        бизнес-класс или нет. Потому что процент возрастает только для
        бизнес-класса, и нам важно не упустить именно этот момент и начислить
        дополнительные проценты. В таком случае подойдёт параметр, который будет
        содержать только булевы значения (<span>true</span> и
        <span>false</span>). Пускай <span>true</span> обозначает бизнес-класс, а
        <span>false</span> всё остальное.
      </p>
      <p>
        Осталось определиться с название второго параметра, подобные значения
        называют флагами, и называют их особым образом. Например, в нашем
        случаае подойдёт название <span>isBusinessClass</span>. То есть
        переменная как бы задаёт вопрос своему содержимому "Сейчас у нас
        бизнес-класс?", а содержимое отвечает на этот вопрос "да"
        (<span>true</span>) или "нет" (<span>false</span>).
      </p>
      <h3>Пиши, упрощай</h3>
      <p>
        Помните, мы говорили о том, что функция может возвращать результат своей
        работы, и подставляли вызов функции сразу в выражение? Примерно так:
      </p>
      <code>
        console.log('За перелёт получим ' + calculateMiles(4125) + ' миль');
      </code>
      <p>А сейчас давайте напишем код более грамотно.</p>
      <p>
        Раз функция возвращает значение, которое можно использовать где-то ещё
        (подставить в строку, добавим в математическую операцию), почему бы не
        записать результат работы этой функции в переменную и использовать
        именно её? Так код станет удобней читать и править.
      </p>
      <p>
        Представьте большую программу с кодом на сотни строк. Вы несколько раз
        используете вызов функции внутри каких-то выражений, и программа
        работает. А потом вы понимаете, что надо вызввать эту же функцию с
        другими аргументами, и вам или вашему коллеге приходится искать по всему
        коду эти вызовы функции и их испрвлять. А если вы что-то пропустите,
        программа будет работать некорректно.
      </p>
      <h3>Отбрось всё лишнее</h3>
      <p>
        Количество бонусных миль в Кексофлоте зависит от класса и расстояния.
        Чтобы завершить програму, можно в каждую ветку проверки на класс
        перелёта добавить проверки на растояние. Но такой вариант выглядит
        громоздко.
      </p>
      <p>
        Логика расчёта процентов довольно сложная, а хочется описать её
        максимально просто и изящно. Поэтому перед добавлением нового условия
        давайте изменим структуру существующего кода, но так, чтобы он работал
        как прежде. То есть займёмся рефакторингом.
      </p>
      <p>
        Посмотим на код <span>calculateMiles</span>. Внутри у нас два выхода из
        функции.
      </p>
      <code>
        let calculateMiles = function (distance, isBusinessClass) {<br />
        if (isBusinessClass) {<br />
        <b>return _;</b><br />
        } else {<br />
        <b>return _;</b><br />
        }<br />
        };
      </code>
      <p>
        Получется, если класс эконом, программа в любом случае не зайдёт внутрь
        первой ветки условия и пойдёт дальше. Поэтому ветка
        <span>else</span> здесь необязательна, её можно опустить.
      </p>
      <code>
        let calculateMiles = function (distance, isBusinessClass) {<br />
        if (isBusinessClass) {<br />
        <b>return _;</b><br />
        }<br />
        <b>return _;</b><br />
        };
      </code>
      <h3>Сделай мне красиво</h3>
      <p>
        Первй шаг рефакторинга сделан. Самое главное, что функция работает так
        же, как и до рефакторинга. Значит можно двигаться дальше. Смотрите, в
        функции дублируется код для расчёта миль. Выражения отличаются толко
        значением процентов:
      </p>
      <code>
        let calculateMiles = function (distance, isBusinessClass) { <br />
        if (isBusinessClass) { <br />
        return <b>distance * 0.22</b>; <br />
        } <br />
        return <b>distance * 0.18</b>; <br />
        };
      </code>
      <p>
        давайте взглянем на решение с другой стороны: что если в условиях
        считать процент, а не дублировать расчёт миль? Мы можем
        переформулировать задачу так, что базовый процент равен 18, а если класс
        перелёта бизнес, то процент увеличивается на 4. Затем в конце функции
        один раз считаем и возврщаем мили.
      </p>
      <code>
        let calculateMiles = function (distance, isBusinessClass) { <br />
        <b>// Вводим процент</b>
        if (isBusinessClass) { <br />
        <b>// Изменяем процент</b>; <br />
        } <br />
        <b>// Рассчитываем и возвращаем мили</b>; <br />
        };
      </code>
      <p>
        Второй шаг рефакторинга такой: создаём перемемнную <span>percent</span>,
        которая будет меняться в зависимости от условия, а возвращать из функции
        будем результат выражения <span>distance * percent</span>.
      </p>
      <p>
        Такой код станет понятней, да и точка выхода из функции будет только
        одна. Функцию станет проще читать, потому что условия для изменения
        процента теперь теперь можно делать не вложенными, а последовательными.
      </p>
      <h3>Просто добавь процент</h3>
      <p>
        Второй шаг рефакторинга позади. В консоли те же результаты: 660 миль и
        540 миль. Значит, логику мы не испортили. и рефакторинг прошёл успешно.
      </p>
      <p>
        Благодаря тому, что мы отрефакторили наш код, вписывать в функцию ещё
        один <span>if</span> совсем несложно:
      </p>
      <code>
        let calculateMiles = function (distance, isBusinessClass) { <br />
        let percent = 0.18 <br />
        if (isBusinessClass) { <br />
        percent += 0.04; <br />
        } <br />
        if (distance > 3500) { <br />
        // Ещё раз изменяем процент <br />
        } <br />
        return distance * percent; <br />
        };
      </code>
      <h3>Позови меня тихо по имени</h3>
      <p>
        <i
          >Знаешь, я хоть и деловой, но и мне чужды простые мечты. Я очень хочу
          повидать мр, посетить много далёких городов, например, Токио. Там всё,
          что я люблю: рыба, природа и технологии. Давай-ка выясним, как мне
          побыстрей обстряпать это дельце?</i
        >
      </p>
      <p>
        <i
          >Впереди у меня много командировок в два города: в испанску Валенсию и
          португальский Лиссабон.</i
        >
      </p>
      <p>
        <i
          >Полётами в какой из городо я быстрее накоплю мили в Токио? Мне нужно
          15000 миль. В Валенсию полечу бизнесом, а вот в Лиссбаон придётся
          тащиться экономом.</i
        >
      </p>
      <p><i>Жду от тебя ответа! До связи!</i></p>
      <p>
        Перед нами новая задача и новая программа. Если задуматься, функция
        подсчёта миль, которую мы написали раньше, нам здесь очень пригодится.
        Сначала с её помощью мы узнаем, сколько миль можно получить с одного
        перелёта, а затем выясним, сколько таких полётов нужно совершить, чтобы
        накопить <span>15000</span> миль до Токио. Кекс хочет слетать и в другие
        города, но сначала мы решим задачу на одном примере, а потом легко
        масштабируем решение и для других расстояний.
      </p>
      <p>
        Мы создадим ещё одну функцию, которая будет считать количество полётов,
        а затем из неёё вызовём нашу первую функцию с подсчётом миль и
        воспользуемся полученным значением.
      </p>
      <p>
        Звучит сложней, чем выглядит на самом деле. Хороший код всегда состоит
        из множества частей, каждая из котрых занимается только своей задачей.
        Как у нас: одна функция считает мили, а дугая будет считать полёты. В
        таком случае очень удобно использовать одну функцию для решения задач
        другой. Например, чтобы посчитать количество полётов, нам понадобится
        снаала узнать количество миль, которое Кекс получит за один полёт по
        направлению. А как это сделать? Вызвать функцию
        <span>calculateMiles</span>, записать результат в переменную и
        использовать в дальнейших вычислениях в функции подсчёта полётов.
      </p>
      <p>Давайе закрепим на практике!</p>
      <p>
        Создадим функцию <span>calculateFlights</span>. Пока рассчитаем полёты
        для первого варианта, полёта в Валению, расстояние туа составляет
        <span>3118</span> км. Напишем функцию за несколько шагов, сначала просто
        протестируем вызов одной функции из другой.
      </p>
      <code>
        let calculateFlights = function (distance, isBusinessClass, milesTarget)
        {<br />
        let miles = calculateMiles(distance, isBusinessClass);<br />
        console.log('Мили за переёт' + miles);<br />
        } <br />
      </code>
      <h3>Вижу цель</h3>
      <p>
        Теперь, когда мы знаем количество миль за один полёт, ничего не мешает
        нам узнать сколько раз придётся слетать по одному маршруту, чтобы
        заполучить поездку в Токио.
      </p>
      <p>
        Добавим для функции <span>calculateFlights</span> ещё один параметр,
        который мы пока не использовали. Он будет содержать количество
        необходимых миль. Сейчас это мили до Токио, но вдруг Кекс захочет
        накопить на полёт ещё куда-нибудь? Достаточно будет поменять значение
        аргумента и вызвать функцию.
      </p>
      <p>
        Раз мы делаем универсальную программу, то имя нового параметра тоже
        должно быть универсальным. Поэтому название вроде
        <span>milesToTokyo</span> нам не подойдёт, оно слишком конкретное и не
        преиспользуемое. Выберем <span>milesTarget</span>. Такое имя подходит
        лучше, потому что с таким параметром мы сможем посчитать количество
        полётов хоть до Сиетла.
      </p>
      <p>
        Чтобы получить количество полётов, нам нужно разделить
        <span>milesTarget</span> на мили, накопленные с одного полёта. Обратите
        внимание, что результат может оказаться не целым числом. Так как речь
        идёт о полётах, не учитвать дробную часть при округлении не правильно.
        Например, если необходимо <span>25.2</span> полётов для накопления
        <span>15000</span> миль, это неправильно, что в итоге перелётов должно
        быть <span>26</span>. Иначе мы не доберём совсем немного миль. Поэтому в
        нашей задаче мы округлим результат вычислений с помощью
        <span>Math.ceil()</span>.
      </p>
      <code>
        let calculateFlights = function (distance, isBusinessClass, milesTarget)
        {<br />
        let miles = calculateMiles(distance, isBusinessClass);<br />
        console.log('Мили за переёт' + miles);<br />
        let flights = Math.ceil(milesTarget / miles);<br />
        console.log('Количество полётов: ' + flights);<br />
        }<br />
      </code>
      <h3>Сколько вешать в полётах?</h3>
      <p>
        Теперь у нас есть функция, которая считает, а сколько полётов по одному
        и тому же маршруту можно накопить необходимое количество миль.
      </p>
      <p>
        Чтобы узнать, как Кексу скорее оказаться в Токио, надо сравнить
        количество полётов по каждому из направлений. Для этого нам нужно
        вызвать функцию <span>calculateFlights</span> дважды, для полётов в
        Валенсию и Лиссабон, с одинаковым значением третьего аргумента (<span
          >1500</span
        >
        миль до Токио).
      </p>
      <p>
        Теперь, чтобы понять, что выгоднее, давайте выясним, сколько раз Кексу
        нужно смотатся по работе в Лиссабон, чтобы наконец оказаться на отдыхе в
        желанном Токио? Расстояние до столицы Португалии <span>3617</span> км.
      </p>
      <code>
        let calculateFlights = function (distance, isBusinessClass, milesTarget)
        { <br />
        let miles = calculateMiles(distance, isBusinessClass); <br />
        let flights = Math.ceil(milesTarget / miles); <br />
        return flights <br />
        };
      </code>
      <h3>Немного приберёмся</h3>
      <p>
        Отрефакторим наш код. а уже затем закончим писать программу для Кекса.
      </p>
      <p>Зачем снова рефакторинг?</p>
      <p>
        Дело в том, что дальше нужно будет сравнить полученные результаты и
        вывести рекомендации для босса. Получается, нам придётся несколько раз
        использовать работы функции <span>calculateFlights</span>. Поэтому
        логично и правильно записать эти результаты в переменные и использовать
        их дальше. Если мы вдург захотим получить данные для других город, мы
        просто изменим значения аргументов в одном единственном месте, а не по
        всему коду.
      </p>
      <p>
        Как лучше назвать переменные, которые содержат в себе количество полётов
        до Лиссбаона и Валенсии? Первое, что приходит на ум, дать переменным
        конкретные названия: <span>flightToValencia</span> и
        <span>flightToLisbon</span> - но такие названия слишком частные. Если
        Кекс захочет полететь в какой-нибудь канадский Виннипег вместо Валенсии,
        переменную придётся переименовывать. И так каждый раз, когда направление
        полёта поменеятся.
      </p>
      <p>
        Можно отталкиваться не от направления, а от класса перелёта, и назвать
        переменные <span>flightsEconom</span> и <span>flightsBusiness</span>.
        Такой вариант тоже не самй лучший, потому что мы летаем в разные города,
        меняется не только класс, но и расстояния.
      </p>
      <p>
        Назовём переменные максимально просто:
        <span>flightsVariantFirst</span> и <span>flightsVariantSecond</span>.
        Тогда внутри у них могут быть любые расстояния и классы перелёта.
      </p>
      <code>
        let flightsVariantFirst = calculateFlights(3118, true, 15000); <br />
        let flightsVariantSecond = calculateFlights(3617, false, 15000); <br />
      </code>
      <h3>Кто быстрей?</h3>
      <p>Осталось совсем немного.</p>
      <p>
        Сейчас мы знаем результаты и для Валенсии, и для Лиссбаона. Осталось
        добавить код, который сравнит их и скажет, как Кексу быстрее оказаться в
        заветном Токио. Используем условия <span>if...else</span>. Чем меньше
        полётов надо потратить на накопление миль, тем лучше.
      </p>
      <code>
        if (flightsVariantFirst > flightsVariantSecond) { <br />
        console.log('Быстрей накопишь полётами в эконом до Лиссбаона! Количество
        полётов: ' + flightsVariantSecond); <br />
        } else { <br />
        console.log('Быстрей накопишь полётами в бизнес до Валенсии! Количество
        полётов: ' + flightsVariantFirst) <br />
        }
      </code>
      <h3>Копим на круглосветку</h3>
      <p>
        Мы узнали, что мили до Токио проще накопить полётами до Лиссбаона в
        экономе. А что с остальными городами? Кекс предупреждал, что Токио -
        только часть его планов. Кроме Токио Кекс хочет бесплатно слетать в
        Саскатун (3000 миль) и Асунсьон (7500 миль).
      </p>
      <p>
        Конечно, мы не будет вызывать функцию
        <span>calculateFlights</span> самостоятельно для каждого расстояния. Мы
        запишем все мили в массив (не забудем добавить туда Токио) и будем
        перебирать, вызывая на каждой итерации функцию
        <span>calculateFlights</span> для полётов в Валенсию и Лиссабон. В
        функцию будем передавать текущий элемент массива - необходимое
        количество миль для полёта в какой-то город из списка Кекса.
      </p>
      <p>
        Чем удобно использование массива и цикла? Мы можем мастабировать решение
        на любое количество городов. Буд их хоть 2, хоть 10, хот 100. Цикл будет
        перебирать массив, вызывать функцию для подстчёта полётов, а затем
        сравнивать результаты. И так для каждого элемента массива.
      </p>
      <p>
        Давайте добавим массив с циклом, и наконец, скажем Кексу, как ему копить
        на путешествя его мечта.
      </p>
      <code>
        let target = [3000, 7500, 15000]; <br>

        for (i = 0; i &lt; target.length; i++) { <br>
          let flightsVariantFirst = calculateFlights(3118, true, target[i]); <br>
          let flightsVariantSecond = calculateFlights(3617, false, target[i]); <br>
        // Весь остальной код <br>
        }
      </code>
    </main>
    <footer>
      <h3>Здесь могла быть ваша кувшинка</h3>
    </footer>
  </body>
  <script src="Функции/Функции.js"></script>
</html>
