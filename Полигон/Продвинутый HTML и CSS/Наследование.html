<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>Наследование и каскадирование</title>
    <link rel="stylesheet" href="../../стили/Полигон.css" />
  </head>
  <body>
    <header>
      <img src="../../avatar/avatar1.jpg" width="90" height="90" alt="Лягушка" />
      <nav>
        <a href="../../Полигон.html">Назад</a>
      </nav>
    </header>
    <main>
      <h2>Наследование и каскадирование</h2>
      <h3>Иерархическое дерево</h3>
      <p>
        HTML-документ представляет собой иерархическое дерево. Это значит, что у
        каждого элемента (кроме корневого) есть только один родитель, то есть
        элемент, внутри которого он располагается. У корневого раздела одитель
        отсутствует. Рассморим простейшую страницу:
      </p>
      <code>
        &lt;html&gt; <br />
        &lt;head&gt;&lt;/head&gt; <br />
        &lt;body&gt; <br />
        &lt;p&gt;Текст документа&lt;/p&gt; <br />
        &lt;p class="text"&gt;ВЫделенная
        &lt;span&gt;строка&lt;/span&gt;&lt;/p&gt; <br />
        &lt;/body&gt; <br />
        &lt;/html&gt;
      </code>
      <p>
        В данном примере видно, что у элемента <span>span</span> родителем
        является <span>p.text</span>, а у <span>p.text</span> родитель -
        <span>body</span>.
      </p>
      <p>
        Иерархическая структура документа определяет основы концепции
        наследования.
      </p>
      <h3>Наследование</h3>
      <p>
        Наследование в CSS - механизм, с помощью которого значения свойств
        элемента-родителя передаются его элементам-потомкам.
      </p>
      <p>
        Стили, присвоенные некоторому элемемнту, наследуются всеми потомками
        (вложенными элементами), если они не переопределны явно. Например,
        размер шрифта и его цвет достаточно применить к <span>body</span>, чтобы
        все элементы внутри имели те же свойства.
      </p>
      <p>
        Наследование позволяет сократить размер таблицы стилей, но если стилей
        много, то отследить какой родитель элемента установил некоторое
        свойство, становится сложнее.
      </p>
      <h3>Наследование "на пальцах"</h3>
      <p>
        Давайте на простых прмиерах подробнее разберёмся, в чём же преимущество
        наследования.
      </p>
      <p>Расмотрим пример:</p>
      <code>
        &lt;p class="text"&gt;Строка с выделенным
        &lt;span&gt;словом&lt;.span&gt;&lt;/p&gt;
      </code>
      <p>
        Представим, что на нужно установить краный цвет текста для всего текста.
        Зададим CSS-свойство следующим образом:
      </p>
      <code>
        .text { <br />
        color:red; <br />
        }
      </code>
      <p>
        Благодаря наследоваию цвет текста в теге <span>span</span> автоматически
        станет красным:
      </p>
      <code style="color: red"> Строка с выделенным словом </code>
      <p>А так бы выглядел результат, если бы наследование не сработало:</p>
      <code style="color: red">
        Строка с выделенным
        <span style="color: black; border: 0px; background-color: inherit"
          >словом</span
        >
      </code>
      <p>
        Нам пришлось бы отдельно прописывать цвет текста для тега
        <span>span</span>. И тогда устанвока таких простых свойств как стиль
        шрифта стала бы большой проблемой: нужно было бы задавать свойства для
        всех возможных вложенных тегов.
      </p>
      <h3>Наследуемые свойства</h3>
      <p>
        Навярняка вы обращали внимание, что не все свойства наследуются
        тегами-потомками от их родителей.
      </p>
      <p>
        Действительно, было бы странно, если бы свойство
        <span>border</span> автоматически устанавливалось для всех вложенных
        элементов.
      </p>
      <p>
        К наследуемым свойствам относятся в первую очередь свойства,
        определяющие параметры оторбражения текста:
      </p>
      <p>
        <span>font-size</span>, <span>fon-style</span>, <span>color</span>,
        <span>text-align</span>, <span>line-height</span>,
        <span>letter-spacing</span>, <span>word-spacing</span>,
        <span>white-space</span> и т.д.
      </p>
      <p>
        Также к наследуемым свойствам относятся <span>list-style</span>,
        <span>cursor</span>, <span>visibility</span>,
        <span>border-collapse</span> и некоторые другие. Но они используются
        значительно реже.
      </p>
      <p>Весь список наследуемых свойств можно посмотртеть в стандарте CSS</p>
      <p>
        Эти свойства можно и нужно задавать через предков, следуя семантике
        документа.
      </p>
      <p>
        Например, параметры текста заастую не меняются в пределах отдельных
        блоков страницы: меню, основного содержания, информационных панелей.
        Поэтому общие параметры текст (цвет, размер, гарнитура) обычно указывают
        в стилях самих блоков.
      </p>
      <h3>Ненаследуемые свойства</h3>
      <p>
        К ним относятся параметры позиционирования, размеров, отступов, фона,
        рамок и т.д.
      </p>
      <p>
        А именно: <span>background</span>, <span>border</span>,
        <span>padding</span>, <span>margin</span>, <span>width</span>,
        <span>height</span>, <span>position</span> и др.
      </p>
      <p>
        Не наследуются они из соображений здравого смысла. Например, если для
        какого-либо блока установлен внутренний отступ, автоматически выставлять
        ткаой же отступ каждому вложенному элементу нет никакой надобности. Эти
        параметры чаще всего уникальны для каждого отдельного блока.
      </p>
      <h3>Принудтельное наследование</h3>
      <p>
        Для каждого свойства может быть задано значение <span>inherit</span>.
      </p>
      <p>
        Оно означает, что данное свойство принимает такое же значение, как и у
        родительского элемента. Значение <span>inherit</span> может быть
        использовано для усиления наследуемых значений, а также в свойствах,
        которые обычно не наследуются.
      </p>
      <p>Запись выглядит следующим образом:</p>
      <code>
        p { <br />
        background: inherit; <br />
        }
      </code>
      <p>
        В данном случае у тегов <span>p</span> свойство
        <span>background</span> будет таким же, как и у их родительских тегов.
      </p>
      <h3>Каскадирование</h3>
      <p>
        CSS расшифровывается как "Cascading style sheets" или "каскадные таблицы
        стилей".
      </p>
      <p>
        Каскадность обозначает, что к одному и тому же элементу может
        применяться несколько CSS-справил (наборов CSS-свойств). Среди этих
        свойств могут быть и конфликтующие между собой. Поэтому существует
        инструкции, которые определяют, каким будет финальный набор свойств
        элемента.
      </p>
      <p>Например, для элемента:</p>
      <code>&lt;p class="text" style="color:red;"&gt;&lt;/p&gt;</code>
      <p>CSS-правила существуют как минимум в трёх разных местах:</p>
      <ol>
        <li>
          в подключаемом файле <span>style.css</span> для селекторов
          <span>p</span> или <span>.text</span>;
        </li>
        <li>в атрибуте <span>style</span>;</li>
        <li>в стандартных стилях отображения, встроенных в браузер.</li>
      </ol>
      <p>
        Каскадирование как раз и определяет, какие именно свойства из этих
        источников пименятся к данном абзацу.
      </p>
      <p>
        Имеется три основные концепции, управляющие порядком, в котором
        применяются CSS-свойства:
      </p>
      <ol>
        <li>важность;</li>
        <li>специфичность;</li>
        <li>порядок исходного кода.</li>
      </ol>
      <p>
        Самым важными для нас являются последние две и подробнее о них мы
        поговорим отдельно.
      </p>
      <h3>Специфичность 1</h3>
      <p>
        Разберём пример. Вот HTML-код, в котором есть абзац с двумя классами:
      </p>
      <code> &lt;p class="red blue"&gt;Синий или красный?&lt;/p&gt; </code>
      <p>А вот CSS-код с двумяя правилами для этих классов:</p>
      <code>
        .blue { <br />
        color: blue; <br />
        } <br />
        <br />
        .red { <br />
        color: red; <br />
        }
      </code>
      <p>
        Вопрос: какого цвета будет текст абзаца? Какое из CSS-правил
        приоритетнее?
      </p>
      <p>Ответ: красного цвета, второе правило приоритетнее.</p>
      <p>
        Это происходит потому, что селекторы у прваил одинакового типа, и
        соответственно обладают одинаковой специфичностью. В таком случае более
        высоким приоритетом обладает то правило, которое расположено в CSS-коде
        <i>ниже</i>. В нашем случае это правило для класса <span>red</span>.
      </p>
      <h3>Специфичность 2</h3>
      <p>Чуть более сложный пример. Тот же HTML:</p>
      <code> &lt;p class="red blue"&gt;Синий или красный?&lt;/p&gt; </code>
      <p>Немного другой CSS:</p>
      <code>
        p.blue { <br />
        color: blue; <br />
        } <br />
        <br />
        .red { <br />
        color: red; <br />
        }
      </code>
      <p>
        В этом случае текст абзаца будет синим. Происходит это потому, что
        селектор <span>p.blue</span> <i>более специфичный</i>, чем селектор
        <span>.red</span>.
      </p>
      <p>Простое объяснение специфичности звучит так:</p>
      <p>
        Чем меньше количество элементов потенциально может выбрать селеткор, тем
        он специфичнее.
      </p>
      <p>
        В нашем примере селектор <span>.red</span> выберет <i>все теги</i> с
        нужным классм, а селектор <span>p.blue</span> выберет
        <i>только абзацы</i> с нужным классом.
      </p>
      <h3>Специфичность 3</h3>
      <p>А теперь посмотрим, как ведут себя контекстные селекторы:</p>
      <code>
        &lt;div class="experiment"&gt; <br />
        &lt;p class="red blue"&gt;Синий или красный?&lt;/p&gt; <br />
        &lt;/div&gt;
      </code>
      <p>И используем контекстные селекторы для второго правила:</p>
      <code>
        p.blue { <br />
        color: blue; <br />
        } <br />
        <br />
        .experiment .red { <br />
        color: red; <br />
        }
      </code>
      <p>Какой теперь будет цвет текста? Красного.</p>
      <h3>Специфичность 4</h3>
      <p>
        Как вы уже знаете, существуют селекторы не только по классам, но и по
        <span>id</span>. Они начинаются с решётки <span>#</span>.
      </p>
      <p>HTML:</p>
      <code>
        &lt;div id="experiment-1" class="experiment"&gt; <br />
        &lt;p class="red blue"&gt;Синий или красный?&lt;/p&gt; <br />
        &lt;/div&gt;
      </code>
      <p>CSS:</p>
      <code>
        #experiment-1 .blue { <br />
        color: blue; <br />
        } <br />
        <br />
        .experiment .red { <br />
        color: red; <br />
        }
      </code>
      <p>
        Особенность атрибута <span>id</span> заключается в том, что его значение
        должно быть уникальным в пределах страницы. То есть, может существовать
        только один тег с определённым значением <span>id</span>.
      </p>
      <p>
        Получается, что селектор по <span>id</span> может выбрать только один
        элемент. И поэтому он на порядок специфичнее селекоров по тегам,
        классам, а также комбинаций этих селекторов.
      </p>
      <h3>Специфичность 5</h3>
      <p>
        CSS-правила, которые прописаны в <span>style</span> обладают наивысшим
        приоритетом. Такой способ задания стилей не приветствуется в
        профессиональной вёрстке сайтов и годится только для создания быстрых
        прототипов.
      </p>
      <p>
        Однако существует способ переопределить из подключаемых CSS-файов даже
        стили, заданные в атрибуте <span>style</span>. Для этого нужно
        использовать ключевое лово <span>!important</span>. Оно задаёт
        CSS-свойству усиленный приоритет. Вот пример:
      </p>
      <p>HTML:</p>
      <code>
        &lt;p class="red blue"&gt;Синий или красный?&lt;/p&gt; <br />
      </code>
      <p>CSS:</p>
      <code>
        .blue { <br />
        color: blue !important; <br />
        }
      </code>
      <p>Цвет текста в этом примере будет синим.</p>
      <p>
        При вёрстке не рекомендуется часто использовать <span>!important</span>.
        По возможности старайтесь обходиться без него.
      </p>
      <h3>Расчёт значения специфичности</h3>
      <p>
        Специфичность селектора разбивается на 4 группы - <span>a</span>,
        <span>b</span>, <span>c</span>, <span>d</span>:
      </p>
      <ul>
        <li>
          если стили встроенные, то есть определён как <span>style="..."</span>,
          то <span>a=1</span>, иначе <span>a=0</span>;
        </li>
        <li>
          значение <span>b</span> равно количеству идентификаторов (тех, которые
          начинаются с <span>#</span>) в селекторе;
        </li>
        <li>
          значени <span>c</span> равно количеству классов, псевдоклассов и
          селеткоров атрибутов;
        </li>
        <li>
          значение <span>d</span> равно количеству селекторов типов элементов и
          псевдо-элементом.
        </li>
      </ul>
      <p>
        После этого полученное значение пиводится к числу (обычно в десятичной
        системе счисления). Селектор, обладающий болшим значением специфичности,
        обладает и большим приоритетом.
      </p>
      <h3>Специфичность, последнее</h3>
      <p>
        Если два CSS-правило применяются к одному и тому же элементу и имеют
        одинаковую специфичность, то более приоритетным будет то правило,
        которое появится в коде позже другого.
      </p>
      <h3>Перекрёстное наследование</h3>
      <p>
        При создании стилей для сходных по внешнему виду или функциональности
        элементов, которые могут использоваться на странице неоднократно, очень
        удобно пользоваться перекрёстным наследованием.
      </p>
      <p>Приём этотт заключается в следующем:</p>
      <ol>
        <li>создаётся базовый стиль для таких элементов;</li>
        <li>
          определяются вспомогательные стили, которые применяются к элементам по
          мере необходимости;
        </li>
        <li>
          элемент наследует базовый стиль и один или несколько вспомогательных.
        </li>
      </ol>
      <p><b>Пример:</b></p>
      <p>
        На странице используются кнопки разного назначения: для отправки форм,
        для сброса информации в полях формы, как элемент навигации и т.д.
      </p>
      <p>
        Можно вынсти общее оформление (размеры, отступы и так далее) для всех
        кнопок в отдельное CSs-правило для класса, например,
        <span>.button</span>.
      </p>
      <p>
        А затем создать доплнительные CSS-правила, в которых будут определены
        только различающиеся свойства этих кнопок, например, цвет фона. Для этих
        правил можно исползовать такие названия: <span>.button-send</span>,
        <span>.button-clear</span>, <span>.button-navigation</span>.
      </p>
      <p>
        Каждая кнопка в HTML-коде будет иметь два класса: общий и
        дополнительный.
      </p>
    </main>
    <footer>
      <h3>Здесь могла быть ваша кувшинка</h3>
    </footer>
  </body>
</html>
