<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>Селекторы 2 часть</title>
    <link rel="stylesheet" href="../../стили/Полигон.css" />
  </head>
  <body>
    <header>
      <img src="../../avatar/avatar1.jpg" width="90" height="90" alt="Лягушка" />
      <nav>
        <a href="../../Полигон.html">Назад</a>
      </nav>
    </header>
    <main>
      <h2>Селекторы 2 часть</h2>
      <h3>Объединение селекторов</h3>
      <p>Иногда может потребоваться выбрать элементы, которые одновременно удовлетворяют сразу нескольким условиям.</p>
      <p>В CSS есть запись, которая фактически выполняет операцию логического умножения, "И". Селекторы, применяемые к одному элементу, в этом случае пишутся без пробелов.</p>
      <code>
        .class1.class2 {}
      </code>
      <p>Стили будут применяться ко всем элементам, которые одновременно имеют класс <span>class1</span> и <span>class2</span>. Вед это же не новость для вас, что HTML-элементы могут одновременно иметь несколько классов.</p>
      <p>По такому же принципу можно объединять любое количество абсолютно разных селекторов. И чем больше селекторов вы объединяете, тем больше условий должно совпасть для применения стилей.</p>
      <p>В програмировании похожую операцию часто обозначают <span>&&</span>.</p>
      <h3>Псевдокласс :not</h3>
      <p>Псевдокласс :not(селектор) является отрицающим селектором. С его помощью можно выбать элементы, которые НЕ содержат указанный селектор:</p>
      <code>
        li:not(:last-child) {}
      </code>
      <p>Этот селектор выберет все теги &lt;li&gt;, НЕ являющиеся последними в их родителе.</p>
      <p>Псевдокласс <span>:not</span> похож на оператор <span>!</span> в программировании:</p>
      <code>
        if (!selector) {...}
      </code>
      <p>В качестве селектора могут указываться псевдоклассы, теги, идентификаторы, классы и селекторы атрибутов. Нельзя использовать двойной псевдокласс <span>:not</span>, то есть конструкция <span>:not(:not(...))</span> не сработает.</p>
      <p>Также в комбинации с <span>:not</span> не принимаются:</p>
      <ul>
        <li>объединение cелекторов: например, <span>li:not(.класс)</span> - некорректный селектор;</li>
        <li>псевдоэлементы: <span>li:not(::after))</span> - неправилна запись;</li>
        <li>селекторы-потомки, групповые селекторы или комбинации: например нельзя писать <span>li:not(a span)</span> или <span>li:not(a + span)</span>.</li>
      </ul>
      <h3>Комбинируем :not</h3>
      <p>Отрицающий селекор <span>:not</span>, как и любые другие селектоы, можно комбинировать с другими. Например:</p>
      <code>
        li:not(:first-child):not(last-child) {}
      </code>
      <p>Выберет все теги <span>&lt;li&gt;</span>, которые НЕ являются первыми и последними в их родителе.</p>
      <p>Объединять можно неограниченное количество селекторов.</p>
      <h3>Псевдокласс :nth-last-child</h3>
      <p>В первом главе про селекторы мы уже рассматривали псевдокласс <span>:nth-child</span>, сейчас посмотрим на <span>:nth-last-child</span>.</p>
      <p>Псевдокласс <span>:nth-last-child</span> используется дл добавления стиля к элементам на основе нумерации в дереве элементов. В отличие от псевдокласса <span>:nth-child</span>, отсчёт ведётся не от первого элемента, а от последнего. Вот и все различия.</p>
      <h3>Псевдокласс :first-of-type</h3>
      <p>Псевдокласс <span>:first-of-type</span> очень похож на <span>:first-child</span>. Он выбирает первый дочерний элемент родителя, только с учётом типа элементов.</p>
      <p>Например, есть список с картами и блок с текстом. У списков и у блока с текстом общий родитель - <span>body</span>.</p>
      <code>
        &lt;body&gt; <br>
        &lt;div class="paper"&gt; ... &lt;/div&gt; <br>
        &lt;ul class="cards"&gt; ... &lt;/ul&gt; <br>
        &lt;ul class="cards"&gt; ... &lt;/ul&gt; <br>
        &lt;/body&gt;
      </code>
      <p>Сравним две записи:</p>
      <code>
        ul:first-child { <br>
          background-color: #ffffee; <br>
        } <br>
        <br>
        ul:first-of-type { <br>
          background-color: #ffffee; <br>
        }
      </code>
      <p>Верхний селектор выбирает перывй дочерний элемент в родителе, причёт этот элемент должен быть <span>ul</span>. В нашем случае не выберется ничего, потому что первым дочерним элементом <span>body</span> является <span>div</span>.</p>
      <p>Нижний селектор выбирает первый <span>ul</span> среди всех дочерних <span>ul</span> в своём родителе.</p>
      <h3>Псевдокласс :last-of-type</h3>
      <p>Псевдокласс <span>:last-of-type</span> работает аналогично, только выбирает <i>последний</i> дочерний элемент родителя с учётом типа.</p>
      <p>Пример записи:</p>
      <code>
        ul:last-of-type { <br>
          ... <br>
        }
      </code>
      <h3>Псевдокласс :nth-of-type</h3>
      <p>Псевдокласс <span>:nth-of-type</span> работает почти так же, как и <span>:nth-child</span>. Разница заключается в том,что он учитывает тип элемента.</p>
      <p>Ещё пример. Если мы используем такие селекторы:</p>
      <code>
        ul:nth-child(2) {} <br>
        ul:nth-of-type(2) {}
      </code>
      <p>То верхний селектор выберет второй по счёту дочерний элемент и этот элемент должен быть <span>ul</span>.</p>
      <p>А нижний селектор выберет второй по счёту <span>ul</span> среди дочерних <span>ul</span>.</p>
      <h3>Псевдокласс :nth-last-of-type</h3>
      <p>Наверняка, вы и сами уже прекрасно догодались, как будет работать <span>:nth-last-of-type</span>.</p>
      <p>Элементы выбираются по их расположению, отсчёт ведётся от конца, учитывается тип элемента.</p>
      <p>Пример записи:</p>
      <code>
        ul:nth-last-of-type(2) {}
      </code>
      <p>Когда набор элементов не очень большой, все эти псевдоклассы <span>:nth-child</span>, <span>:nth-of-type</span>, <span>:nth-last-child</span>, <span>:nth-last-of-type</span> можно легко заменить один другим.</p>
      <p>На более сложных структурах зачастую бываетудобнее использовать только определённые из них. ННапример, когда нужно выделять второй элемент с конца, но количество элементов в списке изменятеся.</p>
      <h3>Селектор последующих элементов</h3>
      <p>Ранее мы уже рассматривали соседние селекторы, которые записываются как <span>селекто1 + селектор2</span>.</p>
      <p>Есть похожий селектор <span>селектор1 ~ селектор2</span>. Стили применятся к элементу, подходящему под <span>селектор2</span>, только если перед ним расположен элемент, подхдящий под <span>селектор1</span>. Оба элемента должны принадлежать одному родителю.</p>
      <p>Отличие от соседнего селектора состоит в том, что ежду элементами <span>селектор1</span> и <span>селектор2</span> могут находиться другие элементы. Поэтому будем называть <span>селектор1 ~ селектор2</span> селектором последующих элементов.</p>
      <p>Сравним</p>
      <code>
        &lt;ul class="cards"&gt; <br>
        &lt;li class="king diamond"&gt; <br>
        &lt;li class="queen heart"&gt; <br>
        &lt;li class="jack spade"&gt; <br>
        &lt;li class="ace heart"&gt; <br>
        &lt;li class="king club"&gt; <br>
        &lt;/ul&gt;
      </code>
      <code>
        .queen.heart + li { <br>
          background-color: #ffff99; <br>
        } <br>
        <br>
        .king.diamond ~ li { <br>
          background-color: #99ddff; <br>
        }
      </code>
      <p>В первом случае выделится один элемент, расположенная сразу за указанной.</p>
      <p>Во втором случае выделятся все карты, которые стоят за указанным элементом.</p>
      <h3>Псевдокласс :empty</h3>
      <p>Псевдокласс <span>:empty</span>, выбирает только те теги, у которых нет дочерних элементов (в том числе текстовых узлов). Учтите, что даже переход на новую строку считаетя текстовым узлом, помните об это в процессе проектирования структуры страницы.</p>
      <p>Пример:</p>
      <code>
        ul:empty { <br>
          ... <br>
        }
      </code>
      <p>Вв данном случае выберутся все пустые элементы <span>ul</span>.</p>
      <h3>Псевдокласс :only-child</h3>
      <p>Псевдокласс <span>:only-child</span> пригодистя, когда нужно прописать индивидуальные стили для элемента, который является единственным дочерним элементом внутри родительского контейнера.</p>
      <p>Пример:</p>
      <code>
        li:only-child { <br>
          ... <br>
        }
      </code>
      <p>Сработает, когда этот <span>&lt;li&gt;</span> в спсике единственный.</p>
      <p>Селекторв <span>:only-child</span> эквивалентен селектору <span>elem:last-child:first-child</span>.</p>
      <h3>Пссевдкласс :only-of-type</h3>
      <p>Псевдокласс <span>:only-of-type</span> работает почти так же, как и <span>:only-child</span>. Отличие состоит в том, что он учитывает тип элемента.</p>
      <p>Пример:</p>
      <code>
        p:only-of-type { <br>
          ... <br>
        }
      </code>
      <p>В данном случае стили будут применены к элементу <span>p</span>, если это единственный <span>p</span> внутри своего родителя.</p>
      <h3>Псевдоэлемент ::before</h3>
      <p>Псевдоэлемент <span>before</span> позволяет с помощью CSS добавить <i>псевдотег</i> внутрь другого элемента и оформить его. Содержимое псевдотега задаётся с помощью свойства <span>content</span>.</p>
      <p>Например, у нас есть такой HTML:</p>
      <code>
        &lt;div class="queen heart"&gt; <br>
        &lt;em&gt;Дама&lt;/em&gt;
        &lt;/div&gt;
      </code>
      <p>Добавим CSS-правило с необычным селектором с двойным двоеточием:</p>
      <code>
        .heart::before { content: "Черви"}
      </code>
      <p>И HTML изменится вот так:</p>
      <code>
        &lt;div class="queen heart"&gt; <br>
        &lt;before&gt;Черви&lt;/before&gt; <br>
        &lt;em&gt;Дама&lt;/em&gt; <br>
        &lt;/div&gt;
      </code>
      <p>Но! Исходный HTML-код не изменится, тег <span>&lt;before&gt;</span> не попадёт в код страницы, а будет "виртуально" существовать где-то в баузерах. Поэтому мы и используем приставку <i>псевдо</i>.</p>
      <p>Ведёт себя псевдотег так же, как обычный <span>&lt;span&gt;</span> с текстом. Ему можно задавать дополнительные стили, например:</p>
      <code>
        .heart::before { <br>
          content: "Черви"; <br>
          color: red; <br>
        }
      </code>
      <p>Чтобы псевдоэлемент появился, ему необходимо задавать свойство <span>content</span>. Достаточно даже пустой строки в значении свойства - <span>content: "";</span></p>
      <h3>Псевдоэлемент ::after</h3>
      <p>Псевдоэлемент <span>after</span> аналогично <span>before</span>. Отличие заключается в том, чо он добавляет псевдотег не в начале, а конец элемемнта. Например:</p>
      <code>
        .heart::after {content: "Черви";}
      </code>
      <p>Даст такой результат</p>
      <code>
        &lt;div class="queen heart"&gt; <br>
        &lt;em&gt;Дама&lt;/em&gt; <br>
        &lt;after&gt;Черви&lt;/after&gt; <br>
        &lt;/div&gt;
      </code>
      <p>Псевдоэлементы <span>before</span> и <span>after</span> можно использовать одновременно. Это означает, что с помощью CSS вы можете добавить к любоу элементу на странице два псевдоэлемента.</p>
      <p>Обратите внимание, что псевдоэлементы пишутся с двойным двоеточием. Этим они отличаются от псевдоклассов, которые используют одинарное двоеточие.</p>
      <h3>Позиционирование псевдоэлементов</h3>
      <p>Вы можете задавать псевдоэлементам любые CSS-свойства. Можно менять тип элемента, задавать ему позиционирвоание, отступы, фон и так далее.</p>
      <p>Этими возможностями особенно часто используются при создании различных декоративных эффекторв. Это очень удобно.</p>
      <p>Во-первых, не нужно добавлять лишний тег под каждую очередную мелкую иконку.</p>
      <p>Во-вторых, можно управлять этими иконками/декоративными элементами только с помощью CSS, что открывает огромный простор для создания интересных динамических эффектов.</p>
      <h3>Псевдоэлементы ::first-line и ::first-letter</h3>
      <p>Псевдоэлемент <span>first-line</span> задаёт стиль первой строки форматированного текста. Длина этой строки зависит от многих факторов, таких как используемый шрифт, размер окна браузера, ширина блока, языка и так далее. В правилах стиля допустимо использовать только свойство, относящиеся к шрифту, изменению цвета текста и фона.</p>
      <p>Пример использования:</p>
      <code>
        p::first-line{ }
      </code>
      <p>Аналогично псевдоэлемент <span>first-letter</span> определяет стиль первого символа в тексте элемента, к которому добавляется. К этому псевдоэлементу могут применяться только стилевые свойства, связанные со свойствами шрифта, полями, отступами, границами, цветом и фоном.</p>
      <p>Пример использования:</p>
      <code>p::first-letter</code>
    </main>
    <footer>
      <h3>Здесь могла быть ваша кувшинка</h3>
    </footer>
  </body>
</html>
