<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>Лужа</title>
    <link rel="stylesheet" href="../стили/Лужа.css" />
    <link rel="stylesheet" href="../стили/Полигон.css" />
  </head>
  <body>
    <header>
      <img src="../avatar/avatar1.jpg" width="90" height="90" alt="Лягушка" />
      <nav>
        <ul>
          <li><a href="../Лужа.html">Назад</a></li>
        </ul>
      </nav>
    </header>
    <main>
      <h3>Словарик Git</h3>
      <ul>
        <li>
          <p>
            HEAD - это символическое имя текущего выбранного коммита — это, по
            сути, тот коммит, над которым мы в данный момент работаем.
          </p>
        </li>
        <li>
          <p>Pull Request - запрос на слияние</p>
        </li>
      </ul>
      <h3>Относительные ссылки</h3>
      <ul>
        <li>
          <p>
            [commit]^ - перемещение на 1 коммит назад по отношению к указанному
            коммиту
          </p>
        </li>
        <li>
          <p>
            [commit]~[num] - перемещние на указанное количество коммитов назад
            по отношению к указанному коммиту
          </p>
        </li>
      </ul>
      <h3>Команды для работы с локальным репозиторием</h3>
      <ul>
        <li><p>git commit - создаёт коммит</p></li>
        <li>
          <p>git branch [name] - создаёт новую ветку с указанным именем</p>
        </li>
        <li>
          <p>
            git branch -f [branch name] [branch name/commit]~[num] - перемещение
            ветки. Переносит указанную ветку [branch] на указанную ветку или
            коммит [branch/commit]. Так же можно добавить ~[num], чтобы
            переместить ветку [branch] на предков ветки или коммита
            [branch/commit]
          </p>
        </li>
        <li>
          <p>git checkout [branch name] - переключает на указанную ветку</p>
        </li>
        <li>
          <p>
            git checkout -b [branch name] - создаёт новую ветку и переключаается
            на неё
          </p>
        </li>
        <li>
          <p>
            git tag [tag name] [commit] - создаёт тег с указанным именем на
            указанном коммите.
          </p>
        </li>
        <li>
          <p>
            git describe [ref] - показывает, как далеко текущее состояние от
            ближайшего тега. ref — это что-либо, что указывает на конкретный
            коммит.
          </p>
          <p>
            Эта команда выведит в консоль следующее: [tag]_[numCommits]_g[hash].
            Где tag – это ближайший тег в истории изменений, numCommits – это на
            сколько далеко мы от этого тега, а hash – это хеш коммита, который
            описывается.
          </p>
        </li>
        <h4>Слияние веток</h4>
        <li>
          <p>
            git merge [branch name] (слияние) - объединяет нынешнюю ветку с
            указанной в одну
          </p>
        </li>
        <li>
          <p>
            git rebase [branch name 1] [brunch name 2] (перебазирование) -
            перемещает все коммиты: от общего коммита двух веток до последнего
            коммита текущей ветки на вершину указанной ветки. Переносит ветку 2
            в последний коммит ветки 1 .Единственная проблема - ветка, на
            вершину которой перенеслись все коммиты, не обновлятся до последнх
            изменений, поэтому нужно снова использовать git rebase, указывая уже
            ветку, на которой было произведенно прошлое перебазирование.
          </p>
        </li>
        <h4>Отмена изменений</h4>
        <li>
          <p>
            git reset [name] (для локальных репозиториев) - отменяет изменения,
            перенося ссылку на ветку назад, на более старый коммит. Переносит
            нынешнюю ссылку на коммиты относительной той, которая указана.
            Перенесёт ветку назад, как будто некоторых коммитов вовсе и не было.
            Нужно указывать ^ или ~, которые показывают на сколько коммитов
            назад нужно сдвинуться.
          </p>
        </li>
        <li>
          <p>
            git revert [name] (для удалённых репозиториев) - создаёт новый
            коммит, содержащий изменения полностью противоположные тем, что
            сделаны на указанном коммите. После revert можно сделать push, и
            поделиться изменениями с остальными.
          </p>
        </li>
        <h4>Перемещение изменений</h4>
        <li>
          <p>
            git cherry-pick [commit 1] [commit 2] [...] - простой и
            прямолинейный способ сказать, что ты хочешь копировать несколько
            коммитов на место, где сейчас находишься (HEAD). Подойдёт когда
            точно известно, какие коммиты нужны (и известны их точные хеши).
          </p>
        </li>
        <li>
          <p>
            git rebase -i [name]~[num] - интерактивный rebase. Если добавить -i,
            то Git откроет интерфейс просмотра того, какие коммиты готовы к
            копированию на цель rebase (target). Также показываются хеши
            коммитов и комментарии к ним. Можно использовать либо ветки, либо
            относительные ссылки [name]~[num], чтобы указать цель для Rebase
          </p>
          <p>
            После открытия окна интерактивного rebase есть три варианта для
            каждого коммита:
          </p>
          <ul>
            <li>
              <p>
                Можно сменить положение коммита по порядку, переставив строчку с
                ним в редакторе
              </p>
            </li>
            <li>
              <p>
                Можно "выкинуть" коммит из ребейза. Для этого есть pick -
                переключение его означает, что нужно выкинуть коммит.
              </p>
            </li>
            <li><p>Можно соединить коммиты</p></li>
          </ul>
        </li>
      </ul>
      <h3>Команды для работы с удалённым репозиторием</h3>
      <ul>
        <li>
          <p>git clone - создаст локальную копию удалённого репозитория</p>
        </li>
        <li>
          <p>
            git fetch [origin] [local branch] - извлекает данные из удалённого
            репозитория и переносит на локальный. Команла выполняет две основные
            операции: связывается с указанным удалённым репозиторием и забирает
            все те данные проекта, которых у вас ещё нет, при этом у вас должны
            появиться ссылки на все ветки из этого удалённого репозитория.
            Фактически, git fetch синхронизирует локальное представление
            удалённых репозиториев с тем, что является актуальным на текущий
            момент времени.
          </p>
          <p>
            Важно отметить, что команда git fetch забирает данные в ваш
            локальный репозиторий, но не сливает их с какими-либо вашими
            наработками и не модифицирует то, над чем вы работаете в данный
            момент.
          </p>
          <p>
            Если указывать аргументы, то его принцип работы будет похож на git
            push, только наоборот: вместо того, чтобы закачивать на удалённый
            репозиторий локальные коммиты, он будет скачивать с удалённого
            репозитория коммиты на локальный репозиторий. Тут так же можно
            использовать синтаксис [источник]:[получатель], но в отличии от git
            push, они будут поменяны местами. [Источник] - это место на
            удалённом репозитории, а [получатель] - - место в локальном
            репозитории, в который следует помещать коммиты.
          </p>
        </li>
        <li>
          <p>
            git pull [origin] [local branch] - совмещает в себе 2 команды: fetch
            и merge - скачивает изменеия с удалённого репозитория и объединяет с
            локальными.
          </p>
          <p>
            Если указать аргументы, то git pull сначала притянет обновления на
            указанную локальную ветку и объединит обвноления с веткой, на
            которой мы находимся.
          </p>
          <p>
            Если добавить синтаксис [источник]:[получатель], то команда создат
            ветку [получатель] репозиторий, скачает на неё изменения с ветки
            [источник] удалённого репозитория, а затем объединит ветку с веткой,
            на которой мы находимся
          </p>
        </li>
        <li>
          <p>
            git push [origin] [local branch] - отвечает за загрузку ваших
            изменений в указанный удалённый репозиторий, а также включение ваших
            коммитов в состав удалённого репозитория. Указывая [local branch],
            мы тем самым говорим git-у откуда будут приходить и уходить наши
            коммиты.
          </p>
          <p>
            В том случае, когда вам необходимо разделить источник и получатель
            аргумента, соедините их вместе, используя двоеточие: git push origin
            [источник]:[получатель]
          </p>
        </li>
        <li>
          <p>
            git pull --rebase - аналог для совместно вызванных fetch и rebase.
            Скачивает данные с удалённого репозитория и объединяет их с
            локальными.
          </p>
        </li>
        <li>
          <p>
            git branch -u [remote branch] [local branch] - способ указать ветке
            отслеживать удалённую ветку. Указывает локальной ветке следить за
            удалённой веткой. А если вы ещё при этом находитесь на локальной
            ветке, то её можно не указывать
          </p>
        </li>
      </ul>
    </main>
    <footer>
      <h3>Здесь могла быть ваша кувшинка</h3>
    </footer>
    <script src="Лужа.js"></script>
  </body>
</html>
